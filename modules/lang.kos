#
# Copyright (c) 2014-2017 Chris Dragan
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.
#

fun range(first_arg, args...)
{
    var start = 0
    var stop  = 0
    var step  = 1

    if args.size == 0 {
        stop = first_arg
    }
    else {
        start = first_arg
        stop  = args[0]
    }

    if args.size > 1 {
        step = args[1]
    }

    if step > 0 {
        for var i = start; i < stop; i += step {
            yield i
        }
    }
    else if step < 0 {
        for var i = start; i > stop; i += step {
            yield i
        }
    }
}

object.prototype.iterator = fun
{
    if typeof this == "object" {
        return shallow(this)
    }
    else {
        return fun(value) { yield value } (this)
    }
}

do {
    fun iterator
    {
        for var i = 0; i < this.size; i += 1 {
            yield this[i]
        }
    }

    array.prototype.iterator  = iterator
    string.prototype.iterator = iterator
    buffer.prototype.iterator = iterator
}

function.prototype.iterator = Î»->(this)

array.prototype.insert = fun(first_arg, second_arg, args...)
{
    var begin    = first_arg
    var end      = begin
    var iterable = void

    if args.size == 0 {
        iterable = second_arg
        if end == void {
            begin = this.size
        }
    }
    else {
        end      = second_arg
        iterable = args[0]
    }

    if typeof iterable == "array" {
        return this.insert_array(begin, end, iterable)
    }
    else {
        const size = this.size
        if begin == void {
            begin = 0
        }
        if end == void {
            end = size
        }
        if begin < 0 {
            begin += size
        }
        if end < 0 {
            end += size
        }
        if begin < 0 {
            begin = 0
        }
        if end > size {
            end = size
        }
        if end < begin {
            end = begin
        }

        const iterator = iterable.iterator()

        if begin < end {
            for var value in iterator {
                this[begin] = value
                begin += 1
                if begin >= end {
                    break
                }
            }
        }

        return this.insert_array(begin, end, array(iterator))
    }
}

buffer.prototype.insert = fun(first_arg, second_arg, args...)
{
    var   begin    = first_arg
    var   end      = begin
    var   iterable = void
    const size     = this.size

    if args.size == 0 {
        iterable = second_arg
        if end == void {
            begin = size
        }
    }
    else {
        end      = second_arg
        iterable = args[0]
    }

    if begin == void {
        begin = 0
    }
    if end == void {
        end = size
    }
    if begin < 0 {
        begin += size
    }
    if end < 0 {
        end += size
    }
    if begin < 0 {
        begin = 0
    }
    if end > size {
        end = size
    }
    if end < begin {
        end = begin
    }

    if typeof iterable != "buffer" {
        iterable = buffer(iterable.iterator())
    }

    const new_size = this.size + iterable.size + begin - end
    if new_size > size {
        this.resize(new_size)
    }
    if end < size {
        this.copy_buffer(begin + iterable.size, this, end)
    }
    if new_size < size {
        this.resize(new_size)
    }

    if iterable.size {
        return this.copy_buffer(begin, iterable)
    }
    else {
        return this
    }
}

buffer.prototype.unpack_string = fun
{
    return this.unpack("s")[0]
}

do {
    fun indices
    {
        return range(this.size)
    }

    array.prototype.indices  = indices
    string.prototype.indices = indices
    buffer.prototype.indices = indices
}

do {
    fun just_buf(ch, size)
    {
        const ord = ch.get_char_code(0)

        const buf = ord < 0x80 ? buffer(size) : array(size)
        return string(buf.fill(ord))
    }

    string.prototype.ljust = fun(size, args...)
    {
        if args.size {
            assert typeof args[0] == "string"
            assert args[0].size   == 1
        }

        if this.size >= size {
            return this
        }

        return this + just_buf(args.size ? args[0] : " ", size - this.size)
    }

    string.prototype.rjust = fun(size, args...)
    {
        if args.size {
            assert typeof args[0] == "string"
            assert args[0].size   == 1
        }

        if this.size >= size {
            return this
        }

        return just_buf(args.size ? args[0] : " ", size - this.size) + this
    }

    string.prototype.zfill = fun(size, args...)
    {
        if args.size {
            assert typeof args[0] == "string"
            assert args[0].size   == 1
        }

        if this.size >= size {
            return this
        }

        const fill = just_buf(args.size ? args[0] : "0", size - this.size)

        const sign = this.size ? this[0] : ""

        if sign == "+" || sign == "-" {
            return stringize(sign, fill, this[1:])
        }
        else {
            return fill + this
        }
    }
}

fun map(op, args...)
{
    assert typeof op == "function"

    fun map_f(source)
    {
        const transform = op
        for var elem in source {
            yield transform(elem)
        }
    }

    if args.size > 0 {
        return map_f(args[0])
    }
    else {
        return map_f
    }
}

fun filter(op, args...)
{
    assert typeof op == "function"

    fun filter_f(source)
    {
        const condition = op
        for var elem in source {
            if condition(elem) {
                yield elem
            }
        }
    }

    if args.size > 0 {
        return filter_f(args[0])
    }
    else {
        return filter_f
    }
}

fun reduce(op, init, args...)
{
    assert typeof op == "function"

    fun reduce_f(source)
    {
        const fold  = op
        var   accum = init
        for var elem in source {
            accum = fold(accum, elem)
        }
        return accum
    }

    if args.size > 0 {
        return reduce_f(args[0])
    }
    else {
        return reduce_f
    }
}

fun count(op, args...)
{
    var count_f = typeof op == "function" ?
        fun(source)
        {
            const test  = op
            var   count = 0
            for var elem in source {
                if test(elem) {
                    count += 1
                }
            }
            return count
        }
        :
        fun(source)
        {
            const val   = op
            var   count = 0
            for var elem in source {
                if elem == val {
                    count += 1
                }
            }
            return count
        }

    if args.size > 0 {
        return count_f(args[0])
    }
    else {
        return count_f
    }
}

fun all(op, args...)
{
    var all_f = typeof op == "function" ?
        fun(source)
        {
            const test = op
            for var elem in source {
                if ! test(elem) {
                    return false
                }
            }
            return true
        }
        :
        fun(source)
        {
            const val = op
            for var elem in source {
                if elem != val {
                    return false
                }
            }
            return true
        }

    if args.size > 0 {
        return all_f(args[0])
    }
    else {
        return all_f
    }
}

fun any(op, args...)
{
    var any_f = typeof op == "function" ?
        fun(source)
        {
            const test = op
            for var elem in source {
                if test(elem) {
                    return true
                }
            }
            return false
        }
        :
        fun(source)
        {
            const val = op
            for var elem in source {
                if elem == val {
                    return true
                }
            }
            return false
        }

    if args.size > 0 {
        return any_f(args[0])
    }
    else {
        return any_f
    }
}

object.prototype.map = fun(transform)
{
    return map(transform, this)
}

object.prototype.filter = fun(transform)
{
    return filter(transform, this)
}

object.prototype.reduce = fun(transform, init)
{
    return reduce(transform, init, this)
}

object.prototype.count = fun(transform)
{
    return count(transform, this)
}

object.prototype.all = fun(transform)
{
    return all(transform, this)
}

object.prototype.any = fun(transform)
{
    return any(transform, this)
}

fun method(obj, func)
{
    return fun(args...) -> (func.apply(obj, args))
}

do {
    const hex_digits = [ 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
                         0x37, 0x39, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66 ]

    integer.prototype.hex = fun
    {
        const codes = buffer(18)
        var i       = 17
        var value   = this

        repeat {
            codes[i] = hex_digits[value & 15]
            value >>>= 4
            i       -= 1
        } while value

        codes[i] = 0x78
        i       -= 1
        codes[i] = 0x30

        return string(codes[i:])
    }
}

fun hex(value)
{
    return value.hex()
}

# TODO move to debug module
fun backtrace
{
    try {
        throw void
    }
    catch const e {
        return e.backtrace[1:]
    }
}
