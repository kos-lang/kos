#
# Copyright (c) 2014-2018 Chris Dragan
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.
#

/* @item lang range()
 *
 *     range(stop)
 *     range(start, stop, step = 1)
 *
 * A generator which produces an arithmetic progression of numbers.
 *
 * Returns an iterator function, which yields subsequent numbers in
 * the specified range.
 *
 * `start`, `stop` and `step` arguments are integers or floats.
 *
 * `start` specifies the first number returned by the iterator.  `start`
 * defaults to `0`.
 *
 * `step` specified the increment which is added to subsequently returned
 * numbers.  If `step` is greater than zero, the generated sequence is
 * ascending.  If `step` is negative, the generated sequence is descending.
 * If `step` is zero, no numbers are generated.
 *
 * `stop` specifies the number ending the sequence, but not included in it.
 * The iterator terminates when it reaches or exceeds `stop`.
 *
 * Examples:
 *
 *     > range(5) -> print_elements
 *     0, 1, 2, 3, 4
 *     > range(1, 5) -> print_elements
 *     1, 2, 3, 4
 *     > range(0, 16, 4) -> print_elements
 *     0, 4, 8, 12
 *     > range(0) -> print_elements
 *     
 *     > range(2, -8, -2) -> print_elements
 *     2, 0, -2, -4, -6
 *     > for const x in range(2) { print(x) }
 *     0
 *     1
 */
fun range(start, args...)
{
    var   stop  = 0
    var   step  = 1
    const nargs = args.size

    if nargs {
        stop  = args[0]
    }
    else {
        stop  = start
        start = 0
    }

    if nargs > step { // args.size > 1
        step = args[1]
    }

    if step > 0 {
        for ; start < stop; start += step {
            yield start
        }
    }
    else if step < 0 {
        for ; start > stop; start += step {
            yield start
        }
    }
}

/* @item lang object.prototype.iterator()
 *
 *     object.prototype.iterator()
 *
 * A generator which produces properties of an object in a shallow manner,
 * i.e. without descending into prototypes.
 *
 * Returns an iterator function, which yields 2-element arrays, which are
 * [key, value] pairs of subsequent properties of the object.
 *
 * The order of the elements yielded is unspecified.
 *
 * This is equivalent to `shallow()` function.
 *
 * If the object is not of type `object`, e.g. if it is an integer,
 * a float, a boolean, a void or a non-generator function, the iterator yields
 * the object itself.  Prototypes of array, string, buffer and function override
 * this generator.
 *
 * The `iterator()` function is also implicitly invoked by the `for-in` loop
 * statement.
 *
 * Examples:
 *
 *     > { red: 1, green: 10, blue: 100 }.iterator() -> print_elements
 *     ["red", 1], ["green", 10], ["blue", 100]
 *     > 1.5.iterator() -> print_elements
 *     1.5
 *     > true.iterator() -> print_elements
 *     true
 *     > for const k, v in { x: 10, y: -2 } { print(k, v) }
 *     x 10
 *     y -2
 */
object.prototype.iterator = fun
{
    if typeof this == "object" {
        return shallow(this)
    }
    else {
        return fun(value) { yield value } (this)
    }
}

do {
    fun iterator
    {
        var   i  = 0
        const _1 = 1
        for ; i < this.size; i += _1 {
            yield this[i]
        }
    }

    /* @item lang array.prototype.iterator()
     *
     *     array.prototype.iterator()
     *
     * A generator which produces subsequent elements of an array.
     *
     * Returns an iterator function, which yields subsequent elements.
     *
     * The `iterator()` function is also implicitly invoked by the `for-in` loop
     * statement.
     *
     * Example:
     *
     *     > for const v in [ 1, 2, 3 ] { print(v) }
     *     1
     *     2
     *     3
     */
    array.prototype.iterator = iterator

    /* @item lang string.prototype.iterator()
     *
     *     string.prototype.iterator()
     *
     * A generator which produces subsequent elements of a string.
     *
     * Returns an iterator function, which yields single-character strings
     * containing subsequent characters of the string.
     *
     * The `iterator()` function is also implicitly invoked by the `for-in` loop
     * statement.
     *
     * Examples:
     *
     *     > "koslang".iterator() -> print_elements
     *     k, o, s, l, a, n, g
     *     > for const v in "foo" { print(v) }
     *     f
     *     o
     *     o
     */
    string.prototype.iterator = iterator

    /* @item lang buffer.prototype.iterator()
     *
     *     buffer.prototype.iterator()
     *
     * A generator which produces subsequent elements of a buffer.
     *
     * Returns an iterator function, which yields integers, which are
     * subsequent elements of the buffer.
     *
     * The `iterator()` function is also implicitly invoked by the `for-in` loop
     * statement.
     *
     * Examples:
     *
     *     > buffer([1, 2, 3]).iterator() -> print_elements
     *     1, 2, 3
     *     > for const v in buffer([10, 11, 12]) { print(v) }
     *     10
     *     11
     *     12
     */
    buffer.prototype.iterator = iterator
}

/* @item lang generator.prototype.iterator()
 *
 *     generator.prototype.iterator()
 *
 * Returns the generator itself (`this`).
 *
 * The `iterator()` generator is also implicitly invoked by the `for-in` loop
 * statement.
 *
 * This allows passing an iterator from an instantiated generator to be
 * passed to a `for-in` loop.
 *
 * Examples:
 *
 *     > for const x in range(2) { print(x) }
 *     0
 *     1
 */
generator.prototype.iterator = () => (this)

/* @item lang generator.prototype.slice()
 *
 *     generator.prototype.slice(begin, end)
 *
 * A generator which produces a range of elements returned from an iterator
 * function.
 *
 * Returns an iterator function, which yields the specified subset of elements
 * yielded by the iterator function on which it is invoked.
 *
 * `begin` and `end` specify the range of elements to generate.
 * `begin` is the index of the first element and `end` is the index
 * of the element trailing the last element to extract.
 * A negative index is an offset from the end of the range generated by the
 * iterator on which this function is invoked, such that `-1` indicates the
 * last element, and so on.  If either `begin` or `end` is negative, the
 * returned value is an array instead of an iterator, which is still iterable.
 * If `begin` is `void`, it is equivalent to `0`.  If `end` is `void`, all
 * elements will be returned until the iterator is finished.
 *
 * Conceptually, all `begin` elements are skipped, then elements from
 * `begin` index and up to, but excluding `end` index are returned.
 *
 * This function is invoked by the slice operator.
 *
 * Examples:
 *
 *     > range(10).slice(3, 6) -> print_elements
 *     3, 4, 5
 *     > range(10).slice(7, void) -> print_elements
 *     7, 8, 9
 */
generator.prototype.slice = fun(begin, end)
{
    begin = begin == void ? 0   : integer(begin)
    end   = end   == void ? end : integer(end)

    if begin < 0 || (end != void && end < 0) {
        return [this...][begin:end];
    }
    else {
        return fun(that, begin, end) {
            var i = 0

            if i < begin {
                for const skip in that {
                    i += 1
                    if i >= begin {
                        break
                    }
                }
            }

            if end == void {
                for const elem in that {
                    yield elem
                }
            }
            else if i < end {
                for const elem in that {
                    yield elem
                    i += 1
                    if i >= end {
                        break
                    }
                }
            }
        } (this, begin, end)
    }
}

/* @item lang array.prototype.insert()
 *
 *     array.prototype.insert(pos, iterable)
 *     array.prototype.insert(begin, end, iterable)
 *
 * Inserts elements into an array, possibly replacing existing elements.
 *
 * The array is modified in-place.
 *
 * Returns the array itself (`this`).
 *
 * `pos` specifies the array index at which elements are to be inserted.
 * If `pos` is negative, it is relative to the array's size.
 * If `pos` is `void`, elements are inserted at the end of the array.
 *
 * `begin` and `end` specify a range of elements to be removed from the
 * array and replaced by the inserted elements.  A negative `begin` or
 * `end` is relative to the array's size.  `begin` is the index of the
 * first element to be removed and `end` is the index of the first element
 * after the removed range which will stay.  If `begin` is equal to `end`,
 * they are both equivalent to `pos`.
 *
 * `iterable` is an iterable object on which `iterator()` function is invoked
 * to obtain elements to be inserted into the array.
 *
 * Examples:
 *
 *     > [1, 2, 3].insert(0, ["foo"])
 *     ["foo", 1, 2, 3]
 *     > [1, 2, 3].insert(-1, ["foo"])
 *     [1, 2, "foo", 3]
 *     > [1, 2, 3, 4].insert(1, 2, "foo")
 *     [1, "f", "o", "o", 3, 4]
 *     > [1, 2, 3, 4].insert(0, 3, [])
 *     [4]
 */
array.prototype.insert = fun(begin, iterable, args...)
{
    var end = begin

    if args.size {
        end      = iterable
        iterable = args[0]
    }
    else {
        if end == void {
            begin = this.size
        }
    }

    if typeof iterable == "array" {
        return this["insert_array"](begin, end, iterable)
    }
    else {
        const size = this.size
        if begin == void {
            begin = 0
        }
        if end == void {
            end = size
        }
        if begin < 0 {
            begin += size
        }
        if end < 0 {
            end += size
        }
        if begin < 0 {
            begin = 0
        }
        if end > size {
            end = size
        }
        if end < begin {
            end = begin
        }

        const iterator = iterable.iterator()

        if begin < end {
            for var value in iterator {
                this[begin] = value
                begin += 1
                if begin >= end {
                    break
                }
            }
        }

        return this["insert_array"](begin, end, [iterator...])
    }
}

/* @item lang buffer.prototype.insert()
 *
 *     buffer.prototype.insert(pos, obj)
 *     buffer.prototype.insert(begin, end, obj)
 *
 * Inserts elements into a buffer, possibly replacing existing elements.
 *
 * The buffer is modified in-place.
 *
 * Returns the buffer itself (`this`).
 *
 * `pos` specifies the buffer index at which elements are to be inserted.
 * If `pos` is negative, it is relative to the buffer's size.
 * If `pos` is `void`, elements are inserted at the end of the buffer.
 *
 * `begin` and `end` specify a range of elements to be removed from the
 * buffer and replaced by the inserted elements.  A negative `begin` or
 * `end` is relative to the buffer's size.  `begin` is the index of the
 * first element to be removed and `end` is the index of the first element
 * after the removed range which will stay.  If `begin` is equal to `end`,
 * they are both equivalent to `pos`.
 *
 * `iterable` is an iterable object on which `iterator()` function is invoked
 * to obtain elements to be inserted into the buffer.  The elements to be
 * inserted, which are yielded by the iterator, must be numbers from 0 to 255.
 */
buffer.prototype.insert = fun(begin, iterable, args...)
{
    var   end  = begin
    const size = this.size

    if args.size {
        end      = iterable
        iterable = args[0]
    }
    else {
        if end == void {
            begin = size
        }
    }

    if begin == void {
        begin = 0
    }
    if end == void {
        end = size
    }
    if begin < 0 {
        begin += size
    }
    if end < 0 {
        end += size
    }
    if begin < 0 {
        begin = 0
    }
    if end > size {
        end = size
    }
    if end < begin {
        end = begin
    }

    if typeof iterable != "buffer" {
        iterable = buffer(typeof iterable == "string" ? iterable : iterable.iterator())
    }

    const new_size = this.size + iterable.size + begin - end
    if new_size > size {
        this.resize(new_size)
    }
    if end < size {
        this.copy_buffer(begin + iterable.size, this, end)
    }
    if new_size < size {
        this.resize(new_size)
    }

    if iterable.size {
        return this.copy_buffer(begin, iterable)
    }
    else {
        return this
    }
}

do {
    fun indices
    {
        return range(this.size)
    }

    /* @item lang array.prototype.indices()
     *
     *     array.prototype.indices()
     *
     * A generator which produces subsequent indices of array elements.
     *
     * Returns an iterator function, which yields subsequent indices of
     * the array's elements in ascending order.
     *
     * `a.indices()` is equivalent to `range(a.size)`, where `a` is some
     * array.
     *
     * Example:
     *
     *     > [ "a", "b", "c" ].indices() -> print_elements
     *     0, 1, 2
     */
    array.prototype.indices = indices

    /* @item lang string.prototype.indices()
     *
     *     string.prototype.indices()
     *
     * A generator which produces subsequent indices of string elements.
     *
     * Returns an iterator function, which yields subsequent indices of
     * the string's elements in ascending order.
     *
     * `s.indices()` is equivalent to `range(s.size)`, where `s` is some
     * string.
     *
     * Example:
     *
     *     > "foobar".indices() -> print_elements
     *     0, 1, 2, 3, 4, 5
     */
    string.prototype.indices = indices

    /* @item lang buffer.prototype.indices()
     *
     *     buffer.prototype.indices()
     *
     * A generator which produces subsequent indices of buffer elements.
     *
     * Returns an iterator function, which yields subsequent indices of
     * the buffer's elements in ascending order.
     *
     * `b.indices()` is equivalent to `range(b.size)`, where `b` is some
     * buffer.
     *
     * Example:
     *
     *     > buffer(4).indices() -> print_elements
     *     0, 1, 2, 3
     */
    buffer.prototype.indices = indices
}

/* @item lang string.prototype.ljust()
 *
 *     string.prototype.ljust(size, fill = " ")
 *
 * Left-justifies a string.
 *
 * Returns a new, left-justified string of the requested size.
 *
 * `size` is the length of the returned string.  If `size` is less than
 * the length of the current string, the current string is returned
 * unmodified.
 *
 * `fill` is a string of length 1 containing the character to add on the right
 * side of the string to justify it.  The function throws an exception if
 * `fill` is not a string or has a different length than 1.  `fill` defaults
 * to a space character.
 *
 * Examples:
 *
 *     > "abc".ljust(5)
 *     "abc  "
 *     > "abc".ljust(7, ".")
 *     "abc...."
 *     > "abc".ljust(1)
 *     "abc"
 */
string.prototype.ljust = fun(size, fill = " ")
{
    assert typeof fill == "string"
    assert fill.size   == 1

    if this.size >= size {
        return this
    }

    return this + fill.repeat(size - this.size)
}

/* @item lang string.prototype.rjust()
 *
 *     string.prototype.rjust(size, fill = " ")
 *
 * Right-justifies a string.
 *
 * Returns a new, right-justified string of the requested size.
 *
 * `size` is the length of the returned string.  If `size` is less than
 * the length of the current string, the current string is returned
 * unmodified.
 *
 * `fill` is a string of length 1 containing the character to add on the left
 * side of the string to justify it.  The function throws an exception if
 * `fill` is not a string or has a different length than 1.  `fill` defaults
 * to a space character.
 *
 * Examples:
 *
 *     > "abc".rjust(5)
 *     "  abc"
 *     > "abc".rjust(7, ".")
 *     "....abc"
 *     > "abc".rjust(1)
 *     "abc"
 */
string.prototype.rjust = fun(size, fill = " ")
{
    assert typeof fill == "string"
    assert fill.size   == 1

    if this.size >= size {
        return this
    }

    return fill.repeat(size - this.size) + this
}

/* @item lang string.prototype.zfill()
 *
 *     string.prototype.zfill(size, fill = "0")
 *
 * Zero-fills a string, assuming it contains a number.
 *
 * Returns a new string of the requested size.  If the original string starts
 * with a `+` or `-` character, this character remains at the beginning of
 * the returned string.
 *
 * `size` is the length of the returned string.  If `size` is less than
 * the length of the current string, the current string is returned
 * unmodified.
 *
 * `fill` is a string of length 1 containing the character to add on the left
 * side of the string (after the `+` or `-` sign) to achieve the requested
 * length.  The function throws an exception if `fill` is not a string or has
 * a different length than 1.  `fill` defaults to `"0"`.
 *
 * Examples:
 *
 *     > "123".zfill(5)
 *     "00123"
 *     > "+123".zfill(7)
 *     "+000123"
 *     > "+abc".zfill(6, "-")
 *     "+--abc"
 */
string.prototype.zfill = fun(size, fill = "0")
{
    assert typeof fill == "string"
    assert fill.size   == 1

    if this.size >= size {
        return this
    }

    const fill = fill.repeat(size - this.size)

    const sign = this.size ? this[0] : ""

    if sign == "+" || sign == "-" {
        return stringify(sign, fill, this[1:])
    }
    else {
        return fill + this
    }
}

/* @item lang whitespace
 *
 *     whitespace
 *
 * A string containing all characters considered as whitespace by some
 * functions.
 */
const whitespace = " \r\n\t\f\v\xA0\x{2028}\x{2029}\x{FEFF}"

/* @item lang eol
 *
 *     eol
 *
 * A string containing all characters considered as end of line markers by
 * some functions.
 */
const eol = "\n\r\v\f\x1C\x1D\x1E\x85\x{2028}\x{2029}"

/* @item lang string.prototype.lstrip()
 *
 *     string.prototype.lstrip(chars = whitespace)
 *
 * Removes all leading whitespace characters from a string.
 *
 * Returns a new string with all whitespace characters removed from
 * its beginning.
 *
 * `chars` is a string, which specifies the list of characters treated
 * as whitespace.  It defaults to `lang.whitespace`.
 *
 * Example:
 *
 *     > "  foo  ".lstrip()
 *     "foo  "
 */
string.prototype.lstrip = fun(chars = whitespace)
{
    const pos = this.scan(chars, false)
    if pos != -1 {
        return this[pos :]
    }
    return ""
}

/* @item lang string.prototype.rstrip()
 *
 *     string.prototype.rstrip(chars = whitespace)
 *
 * Removes all trailing whitespace characters from a string.
 *
 * Returns a new string with all whitespace characters removed from
 * its end.
 *
 * `chars` is a string, which specifies the list of characters treated
 * as whitespace.  It defaults to `lang.whitespace`.
 *
 * Example:
 *
 *     > "  foo  ".rstrip()
 *     "  foo"
 */
string.prototype.rstrip = fun(chars = whitespace)
{
    const pos = this.rscan(chars, false)
    return this[: pos + 1]
}

/* @item lang string.prototype.strip()
 *
 *     string.prototype.strip(chars = whitespace)
 *
 * Removes all leading and trailing whitespace characters from a string.
 *
 * Returns a new string with all whitespace characters removed from
 * its beginning and end.
 *
 * `chars` is a string, which specifies the list of characters treated
 * as whitespace.  It defaults to `lang.whitespace`.
 *
 * Example:
 *
 *     > "  foo  ".strip()
 *     "foo"
 */
string.prototype.strip = fun(chars = whitespace)
{
    const lpos = this.scan(chars, false)
    if lpos != -1 {
        const rpos = this.rscan(chars, false)
        return this[lpos : rpos + 1]
    }
    return ""
}

/* @item lang string.prototype.split()
 *
 *     string.prototype.split(sep = void, max_split = -1)
 *
 * A generator which splits a string and produces subsequent parts.
 *
 * Returns an iterator function, which yields subsequent parts of
 * the string.  The parts result from splitting the string using
 * the `sep` separator.
 *
 * `sep` is a string which is used as a separator.  It must be non-empty.
 * The source string is split into parts by finding any occurences of
 * the separator.  The separator is not part of the resulting strings.
 *
 * `sep` defaults to `void`, which indicates that a sequence of whitespaces
 * of any length should be used to split the string.
 *
 * `max_split` indicates the maximum number of parts into which the string
 * is going to be split.  By default it is -1, in which case the number
 * of resulting parts is unlimited.
 *
 * Examples:
 *
 *     > "a  b    c     d".split() -> print_elements
 *     a, b, c, d
 *     > "a--b--c--d--e--f".split("--", 3) -> print_elements
 *     a, b, c--d--e--f
 */
string.prototype.split = fun(sep = void, max_split = -1)
{
    assert sep != ""

    var splits_left = max_split
    if splits_left == 0 {
        return
    }
    if splits_left < 0 {
        splits_left = 0x10000
    }

    if sep == void {
        const chars = whitespace

        var pos = this.scan(chars, false)
        if pos == -1 {
            return
        }

        for ; splits_left > 1; splits_left -= 1 {
            const end = this.scan(chars, pos)
            if end == -1 {
                yield this[pos:]
                return
            }
            yield this[pos:end]

            pos = this.scan(chars, end, false)
            if pos == -1 {
                return
            }
        }

        yield this[pos:]
    }
    else {
        var pos = 0

        for ; splits_left > 1; splits_left -= 1 {
            const end = this.find(sep, pos)
            if end == -1 {
                yield this[pos:]
                return
            }
            yield this[pos:end]

            pos = end + sep.size
        }

        yield this[pos:]
    }
}

/* @item lang string.prototype.split_lines()
 *
 *     string.prototype.split_lines(keep_ends = false)
 *
 * A generator which produces subsequent lines extracted from a string.
 *
 * Returns an iterator function, which yields strings, which are subsequent
 * lines, resulting from splitting the string using EOL characters from
 * `lang.eol`.
 *
 * Two subsequent EOL characters will yield an empty line, except if a CR
 * characters is followed by an LF character, in which case they are kept
 * together as one line separator.
 *
 * `keep_ends` is a boolean, which indicates whether the EOL characters
 * should be kept at the ends of the lines.  It defaults to `false`.
 *
 * Examples:
 *
 *     > "line1\nline2\nline3".split_lines() -> print_elements
 *     line1, line2, line3
 */
string.prototype.split_lines = fun(keep_ends = false)
{
    var   pos   = 0
    const len   = this.size
    const chars = eol

    loop {
        if pos == len {
            return
        }

        const end = this.scan(chars, pos)
        if end == -1 {
            yield this[pos:]
            return
        }

        const endp1 = end + 1
        if this[end] == "\r" && endp1 < len && this[endp1] == "\n" {
            const endp2 = end + 2
            yield this[pos : keep_ends ? endp2 : end]
            pos = endp2
            continue
        }
        else {
            yield this[pos : keep_ends ? endp1 : end]
            pos = endp1
        }
    }
}

/* @item lang keys()
 *
 *     keys(iterable)
 *
 * A generator which produces first elements of each element from an iterable
 * object.  When iterating objects (including `lang.deep()` and
 * `lang.shallow()`), object keys are yielded.
 *
 * Returns an iterator function, which iterates over the elements of an iterable
 * object, then for each of the elements extracts its first sub-element and
 * yields it.
 *
 * This is typically useful to iterate over keys of an object.  Normally
 * iterating over an object yields pairs (two-element arrays) containing
 * object keys and values.  The `keys` function can convert that
 * sequence to just keys.
 *
 * Examples:
 *
 *     > keys({ A: 1, B: 2, C: 3}) -> print_elements
 *     A, C, B
 *     > keys(["kos", "lang", "first"]) -> print_elements
 *     k, l, f
 */
fun keys(iterable)
{
    for const x in iterable {
        yield x.iterator()()
    }
}

/* @item lang map()
 *
 *     map(op)
 *     map(op, iterable)
 *
 * A generator which applies a function to each element of an iterable object.
 *
 * The first variant with one argument returns another function, which can
 * then be applied on any iterable object to map it.
 *
 * The second variant applies the provided function to the elements of
 * the specified iterable object.  It returns an iterator function, which
 * yields subsequent elements mapped through the `op` function.
 *
 * `op` is the function to invoke on each element of the iterable object.
 *
 * `iterable` is an object on which `iterator()` is invoked to obtain subsequent
 * elements of it, which are then mapped.
 *
 * Examples:
 *
 *     > map(x => (x*10), [1, 2, 3, 4]) -> print_elements
 *     10, 20, 30, 40
 *     > const plus2 = map(x => (x + 2))
 *     > plus2([10, 11, 12, 13]) -> print_elements
 *     12, 13, 14, 15
 */
fun map(op, args...)
{
    assert typeof op == "function"

    fun map_f(source)
    {
        const transform = op
        for var elem in source {
            yield transform(elem)
        }
    }

    if args.size {
        return map_f(args[0])
    }
    else {
        return map_f
    }
}

/* @item lang filter()
 *
 *     filter(op)
 *     filter(op, iterable)
 *
 * A generator which filters elements of an iterable object using the provided
 * function.
 *
 * The first variant with one argument returns another function, which can
 * then be applied on any iterable object to filter it.
 *
 * The second variant uses the provided function on the elements of
 * the specified iterable object.  It returns an iterator function, which
 * yields subsequent elements for which the function returns a truthy value.
 *
 * `op` is the function to invoke on each element of the iterable object.
 *
 * `iterable` is an object on which `iterator()` is invoked to obtain subsequent
 * elements of it, which are then filtered.
 *
 * Examples:
 *
 *     > filter(x => (x < 0), [1, -2, 3, 4, -5, -6]) -> print_elements
 *     -2, -5, -6
 *     > const odd = filter(x => (x & 1))
 *     > odd([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) -> print_elements
 *     9, 7, 5, 3, 1
 */
fun filter(op, args...)
{
    assert typeof op == "function"

    fun filter_f(source)
    {
        const condition = op
        for var elem in source {
            if condition(elem) {
                yield elem
            }
        }
    }

    if args.size {
        return filter_f(args[0])
    }
    else {
        return filter_f
    }
}

/* @item lang reduce()
 *
 *     reduce(op, init)
 *     reduce(op, init, iterable)
 *
 * Performs left fold operation on subsequent elements of an iterable object.
 *
 * The first variant returns a function which can then be directly applied
 * to any iterable object.
 *
 * The second variant performs the application of the left fold operation as
 * follows:
 *
 *     const a = [e1, e2, e3, ...]
 *     const reduce = op(op(op(op(init, e1), e2), e3), ...)
 *
 * `op` is the function which is the reduction operator.
 *
 * `init` is the initial element to use for the fold.
 *
 * `iterable` is an object on which `iterator()` is invoked to obtain subsequent
 * elements of it, on which the reduction is performed.
 *
 * Examples:
 *
 *     > reduce((x, y) => (x + y), 0, [1, 1, 1, 2, 5])
 *     10
 *     > const count_non_zero = reduce((x, y) => (x + (y ? 1 : 0)), 0)
 *     > count_non_zero([0, 0, 4, 0, 0, 5, 6, 0])
 *     3
 */
fun reduce(op, init, args...)
{
    assert typeof op == "function"

    fun reduce_f(source)
    {
        const fold  = op
        var   accum = init
        for var elem in source {
            accum = fold(accum, elem)
        }
        return accum
    }

    if args.size {
        return reduce_f(args[0])
    }
    else {
        return reduce_f
    }
}

/* @item lang sum()
 *
 *     sum(iterable, init = 0)
 *
 * Sums all elements of an iterable.
 *
 * Performs an addition of all elements of the `iterable` object using the `+=`
 * operator.  Elements are retrieved through the `iterator()` function.
 *
 * `init` is an optional initial value to which all subsequent elements are
 * added and defaults to `0`.
 *
 * The function can also be used with strings, in which case `init` must be
 * provided as a string.
 *
 * Examples:
 *
 *     > sum([10, 20, 11, 15])
 *     56
 *     > sum(["Hello", ", ", "World!"], "")
 *     "Hello, World!"
 */
fun sum(iterable, total = 0)
{
    for const elem in iterable {
        total += elem
    }
    return total
}

/* @item lang count()
 *
 *     count(op)
 *     count(op, iterable)
 *
 * Counts elements of an iterable object with a predicate.
 *
 * The first variant returns a function which can then be used with various
 * iterable objects to count their elements.
 *
 * The second variant counts all elements of an iterable object, retrieved
 * through the `iterator()` function, using `op` to test elements.
 *
 * If `op` is a function, applies it to every element and then counts for
 * how many elements the `op` function returns `true`.
 *
 * If `op` is not a function, counts how many elements equal to `op` by
 * comparing each element to `op` using `==` operator.
 *
 * Examples:
 *
 *     > count(x => (x > 0), [-1, 1, 2, -3, 4])
 *     3
 *     > const count_numbers = count(x => (x instanceof number))
 *     > count_numbers([10, 2, "foo", 30, "bar", 4])
 *     4
 *     > count("o", "monologue")
 *     3
 */
fun count(op, args...)
{
    var count_f = typeof op == "function" ?
        fun(source)
        {
            const test  = op
            var   count = 0
            for var elem in source {
                if test(elem) {
                    count += 1
                }
            }
            return count
        }
        :
        fun(source)
        {
            const val   = op
            var   count = 0
            for var elem in source {
                if elem == val {
                    count += 1
                }
            }
            return count
        }

    if args.size {
        return count_f(args[0])
    }
    else {
        return count_f
    }
}

/* @item lang all()
 *
 *     all(op)
 *     all(op, iterable)
 *
 * Determines if all elements of an iterable object fulfill a condition.
 *
 * The first variant returns a function which can then be used with various
 * iterable objects to test their elements.
 *
 * The second variant returns `true` if all elements of an iterable object,
 * retrieved through the `iterator()` function, test positively against
 * the `op` predicate and the test evaluates to a truthy value.
 * Otherwise returns `false`.
 *
 * The function stops iterating over elements as soon as the `op` predicate
 * evaluates to a falsy value.
 *
 * If the `op` predicate is a function, it is invoked for each element
 * passed as an argument and then its return value is used as the result
 * of the test.
 *
 * If `op` is not a function, the test is performed by comparing each element
 * against each element using the `==` operator.
 *
 * Examples:
 *
 *     > all(x => (x > 0), [1, 2, 3, 4])
 *     true
 *     > all(x => (x > 0), [0, 1, 2, 3])
 *     false
 *     > const all_numbers = all(x => (typeof x == "number"))
 *     > all_numbers([1, 2, 3, 4])
 *     true
 *     > all_numbers([1, 2, "foo", 3])
 *     false
 */
fun all(op, args...)
{
    var all_f = typeof op == "function" ?
        fun(source)
        {
            const test = op
            for var elem in source {
                if ! test(elem) {
                    return false
                }
            }
            return true
        }
        :
        fun(source)
        {
            const val = op
            for var elem in source {
                if elem != val {
                    return false
                }
            }
            return true
        }

    if args.size {
        return all_f(args[0])
    }
    else {
        return all_f
    }
}

/* @item lang any()
 *
 *     any(op)
 *     any(op, iterable)
 *
 * Determines if any elements of an iterable object fulfill a condition.
 *
 * The first variant returns a function which can then be used with various
 * iterable objects to test their elements.
 *
 * The second variant returns `true` if one or more elements of an iterable object,
 * retrieved through the `iterator()` function, test positively against
 * the `op` predicate and the test evaluates to a truthy value.
 * Otherwise returns `false`.
 *
 * The function stops iterating over elements as soon as the `op` predicate
 * evaluates to a truthy value.
 *
 * If the `op` predicate is a function, it is invoked for each element
 * passed as an argument and then its return value is used as the result
 * of the test.
 *
 * If `op` is not a function, the test is performed by comparing each element
 * against each element using the `==` operator.
 *
 * Examples:
 *
 *     > any(x => (x > 0), [0, 20, -1, -20])
 *     true
 *     > any(x => (x < 0), [0, 1, 2, 3])
 *     false
 *     > const any_numbers = any(x => (typeof x == "number"))
 *     > any_numbers(["a", "b", 1])
 *     true
 *     > any_numbers(["a", "b", "c"])
 *     false
 */
fun any(op, args...)
{
    var any_f = typeof op == "function" ?
        fun(source)
        {
            const test = op
            for var elem in source {
                if test(elem) {
                    return true
                }
            }
            return false
        }
        :
        fun(source)
        {
            const val = op
            for var elem in source {
                if elem == val {
                    return true
                }
            }
            return false
        }

    if args.size {
        return any_f(args[0])
    }
    else {
        return any_f
    }
}

/* @item lang object.prototype.map()
 *
 *     object.prototype.map(op)
 *
 * A generator which applies a function to each element of the object.
 *
 * Returns an iterator function, which yields values returned from the `op`
 * function called on each subsequent element of the object.  Elements
 * are obtained through the `iterator()` function.
 *
 * Example:
 *
 *     > [1, 3, 5, 7].map(x => (x * 2)) -> print_elements
 *     2, 6, 10, 14
 */
object.prototype.map = fun(transform)
{
    return map(transform, this)
}

/* @item lang object.prototype.filter()
 *
 *     object.prototype.filter(op)
 *
 * A generator which filters object elements.
 *
 * Returns an iterator function, which yields elements of the object,
 * for which the `op` function return a truthy value.  The elements are
 * obtained through the `iterator()` function.
 *
 * Example:
 *
 *     > [1, 2, 3, 4, 5, 6].filter(x => (x & 1)) -> print_elements
 *     1, 3, 5
 */
object.prototype.filter = fun(op)
{
    return filter(op, this)
}

/* @item lang object.prototype.reduce()
 *
 *     object.prototype.reduce(op, init)
 *
 * Performs left fold operation on subsequent elements of the object,
 * which are obtained through the `iterator()` function.
 *
 * The left fold operation is applied as follows (pseudo-code):
 *
 *     const a = [e1, e2, e3, ...]
 *     const reduce = op(op(op(op(init, e1), e2), e3), ...)
 *
 * `op` is the function which is the reduction operator.
 *
 * `init` is the initial element to use for the fold.
 *
 * Example:
 *
 *     > [1, 3, 7, 4, 6].reduce((x, y) => (x + y), 0)
 *     21
 */
object.prototype.reduce = fun(op, init)
{
    return reduce(op, init, this)
}

/* @item lang object.prototype.count()
 *
 *     object.prototype.count()
 *     object.prototype.count(op)
 *
 * Counts elements of the object with a predicate.
 *
 * Counts all elements of the object, retrieved through the `iterator()`
 * function, using `op` to test elements.
 *
 * If `op` is not specified, counts all elements retrieved through the
 * `iterator()` function.
 *
 * If `op` is a function, applies it to every element and then counts for
 * how many elements the `op` function returns `true`.
 *
 * If `op` is not a function, counts how many elements equal to `op` by
 * comparing each element to `op` using `==` operator.
 *
 * Examples:
 *
 *     > "monologue".count("o")
 *     3
 *     > range(3, 43, 5).count()
 *     8
 */
object.prototype.count = fun(args...)
{
    if args.size {
        return count(args[0], this)
    }
    else {
        var num = 0
        for const elem in this {
            num += 1
        }
        return num
    }
}

/* @item lang object.prototype.all()
 *
 *     object.prototype.all(op)
 *
 * Determines if all elements of the object fulfill a condition.
 *
 * Returns `true` if all elements of the object,
 * retrieved through the `iterator()` function, test positively against
 * the `op` predicate and the test evaluates to a truthy value.
 * Otherwise returns `false`.
 *
 * The function stops iterating over elements as soon as the `op` predicate
 * evaluates to a falsy value.
 *
 * If the `op` predicate is a function, it is invoked for each element
 * passed as an argument and then its return value is used as the result
 * of the test.
 *
 * If `op` is not a function, the test is performed by comparing each element
 * against each element using the `==` operator.
 *
 * Example:
 *
 *     > [0, 1, 2, 3].all(x => (x > 0))
 *     false
 */
object.prototype.all = fun(op)
{
    return all(op, this)
}

/* @item lang object.prototype.any()
 *
 *     object.prototype.any(op)
 *
 * Determines if any elements of the object fulfill a condition.
 *
 * Returns `true` if one or more elements of the object,
 * retrieved through the `iterator()` function, test positively against
 * the `op` predicate and the test evaluates to a truthy value.
 * Otherwise returns `false`.
 *
 * The function stops iterating over elements as soon as the `op` predicate
 * evaluates to a truthy value.
 *
 * If the `op` predicate is a function, it is invoked for each element
 * passed as an argument and then its return value is used as the result
 * of the test.
 *
 * If `op` is not a function, the test is performed by comparing each element
 * against each element using the `==` operator.
 *
 * Example:
 *
 *     > [1, 2, -1, 3, 4].any(x => (x < 0))
 *     true
 */
object.prototype.any = fun(op)
{
    return any(op, this)
}

/* @item lang method()
 *
 *     method(obj, func)
 *
 * Memorizes an object and a function to be called on that object.
 *
 * Returns a new function, which when called, will call the specified
 * function `func` with the specified object `obj` passed as `this`.
 *
 * `obj` is the object on which the function will be invoked.
 * `func` is a function which is to be applied to the object.
 *
 * Example:
 *
 *     > const my_array = []
 *     > const append = method(my_array, my_array.push)
 *     > append(10)
 *     0
 *     > append(20)
 *     1
 *     > my_array
 *     [10, 20]
 */
fun method(obj, func)
{
    if typeof func == "string" {
        func = obj[func]
    }
    assert typeof func == "function"
    return (args...) => (func.apply(obj, args))
}

var hex = void

do {
    const hex_digits = [ 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
                         0x38, 0x39, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66 ]

    /* @item lang hex()
     *
     *     hex(number)
     *
     * Converts an integer to a string containing hexadecimal representation of it.
     *
     * Example:
     *
     *     > hex(123)
     *     "0x7b"
     */
    hex = fun(value)
    {
        assert typeof value == "integer"

        const codes  = buffer(18)
        const digits = hex_digits
        var   i      = 17
        const _15    = 15
        const _4     = 4
        const _1     = 1

        repeat {
            codes[i] = digits[value & _15]
            value >>>= _4
            i       -= _1
        } while value

        codes[i] = 0x78
        i       -= _1
        codes[i] = 0x30

        return string(codes[i:])
    }

    /* @item lang integer.prototype.hex()
     *
     *     integer.prototype.hex()
     *
     * Converts the integer to a string containing hexadecimal representation of it.
     *
     * Example:
     *
     *     > 123 .hex()
     *     "0x7b"
     */
    integer.prototype.hex = fun
    {
        return hex(this)
    }
}

do {
    fun reverse
    {
        var   dst = this.size
        const obj = typeof this == "buffer" ? buffer() : array()
        obj.resize(dst)
        const _1 = 1
        for var src = 0; dst; src += _1 {
            dst -= _1
            obj[dst] = this[src]
        }
        return obj
    }

    /* @item lang array.prototype.reverse()
     *
     *     array.prototype.reverse()
     *
     * Returns a new array with elements in reverse order.
     *
     * Example:
     *
     *     > [1, 2, 3, 4].reverse()
     *     [4, 3, 2, 1]
     */
    array.prototype.reverse = reverse

    /* @item lang buffer.prototype.reverse()
     *
     *     buffer.prototype.reverse()
     *
     * Returns a new buffer with elements in reverse order.
     *
     * Example:
     *
     *     > buffer([10, 20, 30]).reverse()
     *     <30, 20, 10>
     */
    buffer.prototype.reverse = reverse
}

/* @item lang array.prototype.repeat()
 *
 *     array.prototype.repeat(num)
 *
 * Creates a repeated array.
 *
 * `num` is a non-negative number of times to repeat the array.
 *
 * If `num` is a float, it is converted to integer using floor mode.
 *
 * Example:
 *
 *     > [7, 8, 9].repeat(4)
 *     [7, 8, 9, 7, 8, 9, 7, 8, 9, 7, 8, 9]
 */
array.prototype.repeat = fun(num)
{
    assert num >= 0
    const old_size  = this.size
    const new_size  = old_size * num
    const new_array = []
    new_array.resize(new_size)
    for var i = 0; i < new_size; i += old_size {
        new_array.insert_array(i, i + old_size, this)
    }
    return new_array
}

/* @item lang buffer.prototype.repeat()
 *
 *     buffer.prototype.repeat(num)
 *
 * Creates a repeated buffer.
 *
 * `num` is a non-negative number of times to repeat the buffer.
 *
 * If `num` is a float, it is converted to integer using floor mode.
 *
 * Example:
 *
 *     > buffer([7, 8, 9]).repeat(4)
 *     <07, 08, 09, 07, 08, 09, 07, 08, 09, 07, 08, 09>
 */
buffer.prototype.repeat = fun(num)
{
    assert num >= 0
    const old_size  = this.size
    const new_size  = old_size * num
    const new_buf = buffer(new_size)
    for var i = 0; i < new_size; i += old_size {
        new_buf.copy_buffer(i, this)
    }
    return new_buf
}

var sort = void

do {

    const less = (x, y) => (x < y)

    /* @item lang array.prototype.sort()
     *
     *     array.prototype.sort(compare = (x, y) => (x < y))
     *
     * Sorts array in-place according to the ordering specified by `compare`.
     *
     * Returns void.
     *
     * `compare` is a function which returns `true` if its first argument
     * should come sorted before its second argument and returns `false`
     * otherwise.  `compare` defaults to "less-than" operator.
     *
     * Example:
     *
     *     > [8, 5, 6, 0, 10, 2].sort()
     *     [0, 2, 5, 6, 8, 10]
     */
    array.prototype.sort = fun(compare = less)
    {
        if this.size > 1 {
            if (compare == less) {
                fun inner_sort(a, begin, end)
                {
                    const _1 = 1
                    end -= _1
                    var pivot = a[end]
                    var mid   = begin - _1
                    var i     = begin
                    while i < end {
                        const v = a[i]
                        if v < pivot {
                            mid += _1
                            a[i] = a[mid]
                            a[mid] = v
                            i += _1
                            continue
                        }
                        i += _1
                    }

                    mid += _1
                    if pivot < a[mid] {
                        a[end] = a[mid]
                        a[mid] = pivot
                    }

                    if begin + _1 < mid {
                        inner_sort(a, begin, mid)
                    }
                    if mid + 2 < end + _1 {
                        return inner_sort(a, mid + _1, end + _1)
                    }
                }
                inner_sort(this, 0, this.size)
            }
            else {
                fun inner_sort(a, begin, end, compare)
                {
                    const _1  = 1
                    end      -= _1
                    var pivot = a[end]
                    var mid   = begin - _1
                    var i     = begin
                    while i < end {
                        const v = a[i]
                        if compare(v, pivot) {
                            mid += _1
                            a[i] = a[mid]
                            a[mid] = v
                            i += _1
                            continue
                        }
                        i += _1
                    }

                    mid += _1
                    if compare(pivot, a[mid]) {
                        a[end] = a[mid]
                        a[mid] = pivot
                    }

                    if begin + _1 < mid {
                        inner_sort(a, begin, mid, compare)
                    }
                    if mid + 2 < end + _1 {
                        return inner_sort(a, mid + _1, end + _1, compare)
                    }
                }
                inner_sort(this, 0, this.size, compare)
            }
        }
    }

    /* @item lang sort()
     *
     *     sort(compare = (x, y) => (x < y))
     *     sort(compare, iterable)
     *     sort(iterable)
     *
     * Sorts elements from an iterable object.
     *
     * Returns an array with elements extracted from the iterable object and sorted.
     *
     * The first variant returns a sort function, which can then be used
     * to sort any iterable object and has a built-in compare predicate.
     * The usage of the returned function is the same as the second and
     * third variant.
     *
     * The second and third variant return an array containing elements extracted
     * from an iterable object and sorted according to the `compare` function.  The
     * elements are retrieved from the iterable object through its `iterator()`
     * function.
     *
     * `compare` is a function which returns `true` if its first argument
     * should come sorted before its second argument and returns `false`
     * otherwise.  `compare` defaults to `<` operator in the first and the
     * third variant.
     *
     * Examples:
     *
     *     > sort("kos language") -> print_elements
     *      , a, a, e, g, g, k, l, n, o, s, u
     *     > sort((x, y) => (x[0] < y[0]), { foo: 1, bar: 2, baz: 3 }) -> print_elements
     *     [bar, 2], [baz, 3], [foo, 1]
     */
    sort = fun(compare = less, args...)
    {
        if typeof compare != "function" {
            args.resize(1)
            args[0] = compare
            compare = less
        }

        fun sort(iterable)
        {
            const a = array(iterable.iterator()...)
            if ! a.size {
                return a
            }
            a.sort(compare)
            return a
        }

        return args.size ? sort(args[0]) : sort
    }
}

/* @item lang reverse()
 *
 *     reverse(iterable)
 *
 * A generator which produces elements of an iterable object in reverse order.
 *
 * Returns an iterator function, which yields elements of the iterable object
 * in backwards order.
 *
 * Examples:
 *
 *     > reverse(range(4)) -> print_elements
 *     3, 2, 1, 0
 *     > reverse("language") -> print_elements
 *     e, g, a, u, g, n, a, l
 */
fun reverse(iterable)
{
    switch typeof iterable {

        default:
            iterable = [ iterable ... ]
            fallthrough

        case "string", "array", "buffer":
            for var i = iterable.size; i; {
                i -= 1
                yield iterable[i]
            }
    }
}

/* @item lang enumerate()
 *
 *     enumerate(iterable)
 *
 * A generator which produces indexed elements of an iterable object.
 *
 * Returns an iterator function, which yields pairs (2-element arrays) containing
 * consecutive indices and elements from the iterable object.
 *
 * Examples:
 *
 *     > enumerate(["kos", "lang", "uage"]) -> print_elements
 *     [0, kos], [1, lang], [2, uage]
 *     > enumerate("lang") -> print_elements
 *     [0, l], [1, a], [2, n], [3, g]
 */
fun enumerate(iterable)
{
    var   i  = 0
    const _1 = 1
    for var elem in iterable {
        yield [i, elem]
        i += _1
    }
}

/* @item lang zip()
 *
 *     zip(iterable0, iterable1...)
 *
 * A generator which produces arrays with elements from each iterable object.
 *
 * Returns an iterator function, which yields arrays.  Each array yielded has
 * one element from each input iterable object.
 *
 * Example:
 *
 *     > zip(range(4), "abcd") -> print_elements
 *     [0, a], [1, b], [2, c], [3, d]
 */
fun zip(a, b...)
{
    if b.size == 0 {
        return a
    }

    return fun(a, b) {
        const _1     = 1
        const b_size = b.size
        const size   = _1 + b_size

        const iter = []
        iter.resize(size)
        iter[0] = a.iterator()
        for var i = 0; i < b_size; i += _1 {
            iter[i + _1] = b[i].iterator()
        }

        loop {
            const out = []
            out.resize(size)

            for var i = 0; i < size; i += _1 {
                out[i] = iter[i]()
            }

            yield out
        }
    } (a, b)
}

/* @item lang print_elements()
 *
 *     print_elements(iterable, separator = ", ", end = "\n")
 *
 * Prints all elements from an iterable object on stdout.
 *
 * Elements are extracted from `iterable` object through its `iterator()`
 * function, then printed using `lang.print_()` function.
 *
 * The optional `separator` is a string to be printed between
 * the items.  It defaults to a comma.
 *
 * The optional `end` is a string to be printed after the last item
 * or if there are no items.  It defaults to a new line character.
 *
 * Examples:
 *
 *     > print_elements("kos")
 *     k, o, s
 *     > print_elements("kos", "\n", "")
 *     k
 *     o
 *     s
 *     > range(5) -> print_elements
 *     0, 1, 2, 3, 4
 */
fun print_elements(iterable, separator = ", ", end = "\n")
{
    var first = true
    for const elem in iterable {
        if first {
            first = false
        }
        else {
            print_(separator)
        }
        print_(elem)
    }
    print_(end)
}

/* @item lang print_lines()
 *
 *     print_lines(iterable)
 *
 * Prints all elements from an iterable object on stdout on separate lines.
 *
 * Elements are extracted from `iterable` object through its `iterator()`
 * function, then printed using `lang.print()` function.
 *
 * If there are no elements, nothing is printed.
 *
 * Examples:
 *
 *     > print_lines("kos")
 *     k
 *     o
 *     s
 *     > range(3) -> print_lines
 *     0
 *     1
 *     2
 */
fun print_lines(iterable)
{
    for const elem in iterable {
        print(elem)
    }
}

/* @item lang count_elements()
 *
 *     count_elements(iterable)
 *
 * Counts elements of an iterable object.
 *
 * Returns the number of elements retrieved from the iterable object.
 *
 * Elements are extracted from `iterable` object through its `iterator()`
 * function and counted.
 *
 * Examples:
 *
 *     > count_elements([1, 10, 100, 1000])
 *     4
 *     > range(2, 10, 2) -> count_elements
 *     4
 */
fun count_elements(iterable)
{
    var num_elems = 0
    const _1 = 1
    for const elem in iterable {
        num_elems += _1
    }
    return num_elems
}

# TODO move to debug module
/* @item lang backtrace()
 *
 *     backtrace()
 *
 * Returns backtrace from the place of the invocation.
 *
 * The backtrace returned is identical to the backtrace obtained
 * from an exception object.
 */
fun backtrace
{
    try {
        throw void
    }
    catch const e {
        return e.backtrace[1:]
    }
}
