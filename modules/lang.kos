#
# Copyright (c) 2014-2017 Chris Dragan
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.
#

/* @item lang range()
 *
 *     range(stop)
 *     range(start, stop, step = 1)
 *
 * A generator which produces an arithmetic progression of numbers.
 *
 * Returns an iterator function, which produces subsequent numbers in
 * the specified range.
 *
 * `start`, `stop` and `step` arguments are integers or floats.
 *
 * `start` specifies the first number returned by the iterator.  `start`
 * defaults to `0`.
 *
 * `step` specified the increment which is added to subsequently returned
 * numbers.  If `step` is greater than zero, the generated sequence is
 * ascending.  If `step` is negative, the generated sequence is descending.
 * If `step` is zero, no numbers are generated.
 *
 * `stop` specifies the number ending the sequence, but not included in it.
 * The iterator terminates when it reaches or exceeds `stop`.
 *
 * Examples:
 *
 *     > array(range(5))
 *     [0, 1, 2, 3, 4]
 *     > array(range(1, 5))
 *     [1, 2, 3, 4]
 *     > array(range(0, 16, 4))
 *     [0, 4, 8, 12]
 *     > array(range(0))
 *     []
 *     > array(range(2, -8, -2))
 *     [2, 0, -2, -4, -6]
 *     > for const x in range(2) { print(x) }
 *     0
 *     1
 */

fun range(first_arg, args...)
{
    var start = 0
    var stop  = 0
    var step  = 1

    if args.size {
        start = first_arg
        stop  = args[0]
    }
    else {
        stop = first_arg
    }

    if args.size > 1 {
        step = args[1]
    }

    if step > 0 {
        for var i = start; i < stop; i += step {
            yield i
        }
    }
    else if step < 0 {
        for var i = start; i > stop; i += step {
            yield i
        }
    }
}

/* @item lang object.prototype.iterator()
 *
 *     object.prototype.iterator()
 *
 * A generator which produces properties of an object in a shallow manner,
 * i.e. without descending into prototypes.
 *
 * Returns an iterator function, which produces 2-element arrays which are
 * [key, value] pairs of subsequent properties of an object.  The elements
 * returned are not in any particular order.
 *
 * If the object is not of type `object`, e.g. if it is an integer,
 * a float, a boolean or a void, the generator produces the object itself.
 * Prototypes of array, string, buffer and function override this generator.
 *
 * The `iterator` function is also implicitly invoked by the `for-in` loop
 * statement.
 *
 * Examples:
 *
 *     > array({ red: 1, green: 10, blue: 100 }.iterator())
 *     [["red", 1], ["green", 10], ["blue", 100]]
 *     > array(1.5.iterator())
 *     [1.5]
 *     > array(true.iterator())
 *     [true]
 *     > for const k, v in { x: 10, y: -2 } { print(k, v) }
 *     x 10
 *     y -2
 */

object.prototype.iterator = fun
{
    if typeof this == "object" {
        return shallow(this)
    }
    else {
        return fun(value) { yield value } (this)
    }
}

do {
    fun iterator
    {
        for var i = 0; i < this.size; i += 1 {
            yield this[i]
        }
    }

    /* @item lang array.prototype.iterator()
     *
     *     array.prototype.iterator()
     *
     * A generator which produces subsequent elements of an array.
     *
     * The `iterator` function is also implicitly invoked by the `for-in` loop
     * statement.
     *
     * Example:
     *
     *     > for const v in [ 1, 2, 3 ] { print(v) }
     *     1
     *     2
     *     3
     */
    array.prototype.iterator = iterator

    /* @item lang string.prototype.iterator()
     *
     *     string.prototype.iterator()
     *
     * A generator which produces subsequent elements of a string.
     *
     * Returns an iterator function, which produces single-character strings
     * containing subsequent characters of the string.
     *
     * The `iterator` function is also implicitly invoked by the `for-in` loop
     * statement.
     *
     * Examples:
     *
     *     > array("koslang".iterator())
     *     [ "k", "o", "s", "l", "a", "n", "g" ]
     *     > for const v in "foo" { print(v) }
     *     f
     *     o
     *     o
     */
    string.prototype.iterator = iterator

    /* @item lang buffer.prototype.iterator()
     *
     *     buffer.prototype.iterator()
     *
     * A generator which produces subsequent elements of a buffer.
     *
     * Returns an iterator function, which produces integers which are
     * subsequent elements of the buffer.
     *
     * The `iterator` function is also implicitly invoked by the `for-in` loop
     * statement.
     *
     * Examples:
     *
     *     > array(buffer([1, 2, 3]).iterator())
     *     [ 1, 2, 3 ]
     *     > for const v in buffer([10, 11, 12]) { print(v) }
     *     10
     *     11
     *     12
     */
    buffer.prototype.iterator = iterator
}

/* @item lang function.prototype.iterator()
 *
 *     function.prototype.iterator()
 *
 * Returns the function itself (this).
 *
 * The `iterator` function is also implicitly invoked by the `for-in` loop
 * statement.
 *
 * This allows passing an iterator from an instantiated generator to be
 * passed to a `for-in` loop.
 *
 * Examples:
 *
 *     > for const x in range(2) { print(x) }
 *     0
 *     1
 */
function.prototype.iterator = λ->(this)

/* @item lang array.prototype.insert()
 *
 *     array.prototype.insert(pos, iterable)
 *     array.prototype.insert(begin, end, iterable)
 *
 * Inserts elements into an array, possibly replacing existing elements.
 *
 * The array is modified in-place.
 *
 * Returns the array itself (this).
 *
 * `pos` specifies the array index at which elements are to be inserted.
 * If `pos` is negative, it is relative to the array's size.
 * If `pos` is `void`, elements are inserted at the end of the array.
 *
 * `begin` and `end` specify a range of elements to be removed from the
 * array and replaced by the inserted elements.  A negative `begin` or
 * `end` is relative to the array's size.  `begin` is the index of the
 * first element to be removed and `end` is the index of the first element
 * after the removed range which will stay.  If `begin` is equal to `end`,
 * they are both equivalent to `pos`.
 *
 * `iterable` is an iterable object on which `iterator` function is invoked
 * to obtain elements to be inserted into the array.
 *
 * Examples:
 *
 *     > [1, 2, 3].insert(0, "foo")
 *     [ "foo", 1, 2, 3 ]
 *     > [1, 2, 3].insert(-1, "foo")
 *     [ 1, 2, "foo", 3 ]
 *     > [1, 2, 3, 4].insert(1, 2, "foo")
 *     [ 1, "foo", 3, 4]
 *     > [1, 2, 3, 4].insert(0, 3, [])
 *     [ 4 ]
 */
array.prototype.insert = fun(first_arg, second_arg, args...)
{
    var begin    = first_arg
    var end      = begin
    var iterable = void

    if args.size {
        end      = second_arg
        iterable = args[0]
    }
    else {
        iterable = second_arg
        if end == void {
            begin = this.size
        }
    }

    if typeof iterable == "array" {
        return this.insert_array(begin, end, iterable)
    }
    else {
        const size = this.size
        if begin == void {
            begin = 0
        }
        if end == void {
            end = size
        }
        if begin < 0 {
            begin += size
        }
        if end < 0 {
            end += size
        }
        if begin < 0 {
            begin = 0
        }
        if end > size {
            end = size
        }
        if end < begin {
            end = begin
        }

        const iterator = iterable.iterator()

        if begin < end {
            for var value in iterator {
                this[begin] = value
                begin += 1
                if begin >= end {
                    break
                }
            }
        }

        return this.insert_array(begin, end, array(iterator))
    }
}

/* @item lang buffer.prototype.insert()
 *
 *     buffer.prototype.insert(pos, iterable)
 *     buffer.prototype.insert(begin, end, iterable)
 *
 * Inserts elements into an buffer, possibly replacing existing elements.
 *
 * The buffer is modified in-place.
 *
 * Returns the buffer itself (this).
 *
 * `pos` specifies the buffer index at which elements are to be inserted.
 * If `pos` is negative, it is relative to the buffer's size.
 * If `pos` is `void`, elements are inserted at the end of the buffer.
 *
 * `begin` and `end` specify a range of elements to be removed from the
 * buffer and replaced by the inserted elements.  A negative `begin` or
 * `end` is relative to the buffer's size.  `begin` is the index of the
 * first element to be removed and `end` is the index of the first element
 * after the removed range which will stay.  If `begin` is equal to `end`,
 * they are both equivalent to `pos`.
 *
 * `iterable` is an iterable object on which `iterator` function is invoked
 * to obtain elements to be inserted into the buffer.  The elements to be
 * inserted, produced by the iterator, must be numbers from 0 to 255.
 */
buffer.prototype.insert = fun(first_arg, second_arg, args...)
{
    var   begin    = first_arg
    var   end      = begin
    var   iterable = void
    const size     = this.size

    if args.size {
        end      = second_arg
        iterable = args[0]
    }
    else {
        iterable = second_arg
        if end == void {
            begin = size
        }
    }

    if begin == void {
        begin = 0
    }
    if end == void {
        end = size
    }
    if begin < 0 {
        begin += size
    }
    if end < 0 {
        end += size
    }
    if begin < 0 {
        begin = 0
    }
    if end > size {
        end = size
    }
    if end < begin {
        end = begin
    }

    if typeof iterable != "buffer" {
        iterable = buffer(iterable.iterator())
    }

    const new_size = this.size + iterable.size + begin - end
    if new_size > size {
        this.resize(new_size)
    }
    if end < size {
        this.copy_buffer(begin + iterable.size, this, end)
    }
    if new_size < size {
        this.resize(new_size)
    }

    if iterable.size {
        return this.copy_buffer(begin, iterable)
    }
    else {
        return this
    }
}

/* @item lang buffer.prototype.unpack_string()
 *
 *     buffer.prototype.unpack_string()
 *
 * Unpacks an UTF-8 string from a buffer.
 *
 * The buffer is assumed to contain subsequent bytes of an UTF-8 string,
 * which is then unpacked.
 *
 * Returns the unpacked string.
 *
 * Example:
 *
 *     > print(buffer([110, 97, 195, 175, 118, 101]).unpack_string())
 *     naïve
 */
buffer.prototype.unpack_string = fun
{
    return this.unpack("s")[0]
}

do {
    fun indices
    {
        return range(this.size)
    }

    /* @item lang array.prototype.indices()
     *
     *     array.prototype.indices()
     *
     * A generator which produces subsequent indices of array elements.
     *
     * Returns an iterator function, which produces subsequent indices of
     * the array's elements in ascending order.
     *
     * `a.indices()` is equivalent to `range(a.size)`, where `a` is some
     * array.
     *
     * Example:
     *
     *     > array([ "a", "b", "c" ].indices())
     *     [ 0, 1, 2 ]
     */
    array.prototype.indices = indices

    /* @item lang string.prototype.indices()
     *
     *     string.prototype.indices()
     *
     * A generator which produces subsequent indices of string elements.
     *
     * Returns an iterator function, which produces subsequent indices of
     * the string's elements in ascending order.
     *
     * `s.indices()` is equivalent to `range(s.size)`, where `s` is some
     * string.
     *
     * Example:
     *
     *     > array("foobar".indices())
     *     [ 0, 1, 2, 3, 4, 5 ]
     */
    string.prototype.indices = indices

    /* @item lang buffer.prototype.indices()
     *
     *     buffer.prototype.indices()
     *
     * A generator which produces subsequent indices of buffer elements.
     *
     * Returns an iterator function, which produces subsequent indices of
     * the buffer's elements in ascending order.
     *
     * `b.indices()` is equivalent to `range(b.size)`, where `b` is some
     * buffer.
     *
     * Example:
     *
     *     > array(buffer(4).indices())
     *     [ 0, 1, 2, 3 ]
     */
    buffer.prototype.indices = indices
}

/* @item lang string.prototype.ljust()
 *
 *     string.prototype.ljust(size, fill = " ")
 *
 * Left-justifies a string.
 *
 * Returns a new, left-justified string of the requested size.
 *
 * `size` is the length of the returned string.  If `size` is less than
 * the length of the current string, the current string is returned
 * unmodified.
 *
 * `fill` is a string of length 1 containing the character to add on the right
 * side of the string to justify it.  The function throws an exception if
 * `fill` is not a string or has a different length than 1.  `fill` defaults
 * to a space character.
 *
 * Examples:
 *
 *     > "abc".ljust(5)
 *     "abc  "
 *     > "abc".ljust(7, ".")
 *     "abc...."
 *     > "abc".ljust(1)
 *     "abc"
 */
string.prototype.ljust = fun(size, fill = " ")
{
    assert typeof fill == "string"
    assert fill.size   == 1

    if this.size >= size {
        return this
    }

    return this + fill.repeat(size - this.size)
}

/* @item lang string.prototype.rjust()
 *
 *     string.prototype.rjust(size, fill = " ")
 *
 * Right-justifies a string.
 *
 * Returns a new, right-justified string of the requested size.
 *
 * `size` is the length of the returned string.  If `size` is less than
 * the length of the current string, the current string is returned
 * unmodified.
 *
 * `fill` is a string of length 1 containing the character to add on the left
 * side of the string to justify it.  The function throws an exception if
 * `fill` is not a string or has a different length than 1.  `fill` defaults
 * to a space character.
 *
 * Examples:
 *
 *     > "abc".rjust(5)
 *     "  abc"
 *     > "abc".rjust(7, ".")
 *     "....abc"
 *     > "abc".rjust(1)
 *     "abc"
 */
string.prototype.rjust = fun(size, fill = " ")
{
    assert typeof fill == "string"
    assert fill.size   == 1

    if this.size >= size {
        return this
    }

    return fill.repeat(size - this.size) + this
}

/* @item lang string.prototype.zfill()
 *
 *     string.prototype.zfill(size, fill = "0")
 *
 * Zero-fills a string, assuming it contains a number.
 *
 * Returns a new string of the requested size.  If the original string starts
 * with a `+` or `-` character, this character remains at the beginning of
 * the returned string.
 *
 * `size` is the length of the returned string.  If `size` is less than
 * the length of the current string, the current string is returned
 * unmodified.
 *
 * `fill` is a string of length 1 containing the character to add on the left
 * side of the string (after the `+` or `-` sign) to achieve the requested
 * length.  The function throws an exception if `fill` is not a string or has
 * a different length than 1.  `fill` defaults to `"0"`.
 *
 * Examples:
 *
 *     > "123".zfill(5)
 *     "00123"
 *     > "+123".zfill(7)
 *     "+000123"
 *     > "+abc".zfill(6, "-")
 *     "+--abc"
 */
string.prototype.zfill = fun(size, fill = "0")
{
    assert typeof fill == "string"
    assert fill.size   == 1

    if this.size >= size {
        return this
    }

    const fill = fill.repeat(size - this.size)

    const sign = this.size ? this[0] : ""

    if sign == "+" || sign == "-" {
        return stringify(sign, fill, this[1:])
    }
    else {
        return fill + this
    }
}

const whitespace = " \r\n\t\f\v\0\xA0\x{2028}\x{2029}\x{FEFF}"
const eol        = "\n\r\v\f\x1C\x1D\x1E\x85\x{2028}\x{2029}"

do {
    string.prototype.lstrip = fun(chars = whitespace)
    {
        const pos = this.scan(chars, false)
        if pos != -1 {
            return this[pos :]
        }
        return ""
    }

    string.prototype.rstrip = fun(chars = whitespace)
    {
        const pos = this.rscan(chars, false)
        return this[: pos + 1]
    }

    string.prototype.strip = fun(chars = whitespace)
    {
        const lpos = this.scan(chars, false)
        if lpos != -1 {
            const rpos = this.rscan(chars, false)
            return this[lpos : rpos + 1]
        }
        return ""
    }

    string.prototype.split = fun(sep = void, max_split = -1)
    {
        assert sep != ""

        var splits_left = max_split
        if splits_left == 0 {
            return
        }
        if splits_left < 0 {
            splits_left = 0x10000
        }

        if sep == void {
            const chars = whitespace

            var pos = this.scan(chars, false)
            if pos == -1 {
                return
            }

            for ; splits_left > 1; splits_left -= 1 {
                const end = this.scan(chars, pos)
                if end == -1 {
                    yield this[pos:]
                    return
                }
                yield this[pos:end]

                pos = this.scan(chars, end, false)
                if pos == -1 {
                    return
                }
            }

            yield this[pos:]
        }
        else {
            var pos = 0

            for ; splits_left > 1; splits_left -= 1 {
                const end = this.find(sep, pos)
                if end == -1 {
                    yield this[pos:]
                    return
                }
                yield this[pos:end]

                pos = end + sep.size
            }

            yield this[pos:]
        }
    }

    string.prototype.split_lines = fun(keep_ends = false)
    {
        var   pos   = 0
        const len   = this.size
        const chars = eol

        loop {
            if pos == len {
                return
            }

            const end = this.scan(chars, pos)
            if end == -1 {
                yield this[pos:]
                return
            }

            const endp1 = end + 1
            if this[end] == "\r" && endp1 < len && this[endp1] == "\n" {
                const endp2 = end + 2
                yield this[pos : keep_ends ? endp2 : end]
                pos = endp2
                continue
            }
            else {
                yield this[pos : keep_ends ? endp1 : end]
                pos = endp1
            }
        }
    }
}

fun first(iterable)
{
    for const x in iterable {
        yield x[0]
    }
}

fun map(op, args...)
{
    assert typeof op == "function"

    fun map_f(source)
    {
        const transform = op
        for var elem in source {
            yield transform(elem)
        }
    }

    if args.size {
        return map_f(args[0])
    }
    else {
        return map_f
    }
}

fun filter(op, args...)
{
    assert typeof op == "function"

    fun filter_f(source)
    {
        const condition = op
        for var elem in source {
            if condition(elem) {
                yield elem
            }
        }
    }

    if args.size {
        return filter_f(args[0])
    }
    else {
        return filter_f
    }
}

fun reduce(op, init, args...)
{
    assert typeof op == "function"

    fun reduce_f(source)
    {
        const fold  = op
        var   accum = init
        for var elem in source {
            accum = fold(accum, elem)
        }
        return accum
    }

    if args.size {
        return reduce_f(args[0])
    }
    else {
        return reduce_f
    }
}

fun sum(iterable, init = 0)
{
    var total = init
    for const elem in iterable {
        total += elem
    }
    return total
}

fun count(op, args...)
{
    var count_f = typeof op == "function" ?
        fun(source)
        {
            const test  = op
            var   count = 0
            for var elem in source {
                if test(elem) {
                    count += 1
                }
            }
            return count
        }
        :
        fun(source)
        {
            const val   = op
            var   count = 0
            for var elem in source {
                if elem == val {
                    count += 1
                }
            }
            return count
        }

    if args.size {
        return count_f(args[0])
    }
    else {
        return count_f
    }
}

fun all(op, args...)
{
    var all_f = typeof op == "function" ?
        fun(source)
        {
            const test = op
            for var elem in source {
                if ! test(elem) {
                    return false
                }
            }
            return true
        }
        :
        fun(source)
        {
            const val = op
            for var elem in source {
                if elem != val {
                    return false
                }
            }
            return true
        }

    if args.size {
        return all_f(args[0])
    }
    else {
        return all_f
    }
}

fun any(op, args...)
{
    var any_f = typeof op == "function" ?
        fun(source)
        {
            const test = op
            for var elem in source {
                if test(elem) {
                    return true
                }
            }
            return false
        }
        :
        fun(source)
        {
            const val = op
            for var elem in source {
                if elem == val {
                    return true
                }
            }
            return false
        }

    if args.size {
        return any_f(args[0])
    }
    else {
        return any_f
    }
}

object.prototype.map = fun(transform)
{
    return map(transform, this)
}

object.prototype.filter = fun(transform)
{
    return filter(transform, this)
}

object.prototype.reduce = fun(transform, init)
{
    return reduce(transform, init, this)
}

object.prototype.count = fun(transform)
{
    return count(transform, this)
}

object.prototype.all = fun(transform)
{
    return all(transform, this)
}

object.prototype.any = fun(transform)
{
    return any(transform, this)
}

fun method(obj, func)
{
    if typeof func == "string" {
        func = obj[func]
    }
    assert typeof func == "function"
    return fun(args...) -> (func.apply(obj, args))
}

do {
    const hex_digits = [ 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
                         0x37, 0x39, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66 ]

    integer.prototype.hex = fun
    {
        const codes = buffer(18)
        var i       = 17
        var value   = this

        repeat {
            codes[i] = hex_digits[value & 15]
            value >>>= 4
            i       -= 1
        } while value

        codes[i] = 0x78
        i       -= 1
        codes[i] = 0x30

        return string(codes[i:])
    }
}

fun hex(value)
{
    return value.hex()
}

do {
    fun reverse
    {
        var   dst = this.size
        const obj = typeof this == "buffer" ? buffer(dst) : array(dst)
        for var src = 0; dst; src += 1 {
            dst -= 1
            obj[dst] = this[src]
        }
        return obj
    }

    array.prototype.reverse  = reverse
    buffer.prototype.reverse = reverse
}

fun aaa_default_sort(x, y) { return x < y }

array.prototype.sort = fun(compare = aaa_default_sort)
{
    fun inner_sort(a, begin, end)
    {
        if begin + 1 >= end {
            return
        }

        const test = compare
        end -= 1
        var pivot = a[end]
        var mid   = begin - 1
        var i     = begin
        while i < end {
            const v = a[i]
            if test(v, pivot) {
                mid += 1
                a[i] = a[mid]
                a[mid] = v
                i += 1
                continue
            }
            i += 1
        }

        mid += 1
        if test(pivot, a[mid]) {
            a[end] = a[mid]
            a[mid] = pivot
        }

        inner_sort(a, begin, mid)
        return inner_sort(a, mid + 1, end + 1)
    }
    inner_sort(this, 0, this.size)
    return this
}

fun sort(iterable, compare = aaa_default_sort)
{
    const a = array(iterable.iterator())
    if ! a.size {
        return void.iterator()
    }
    return a.sort(compare).iterator()
}

# TODO move to debug module
fun backtrace
{
    try {
        throw void
    }
    catch const e {
        return e.backtrace[1:]
    }
}
