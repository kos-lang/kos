#
# Copyright (c) 2014-2018 Chris Dragan
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.
#

import lang.array
import lang.print

/* @item iter generator()
 *
 *     generator(iterable)
 *
 * Creates a generator function, which caches another generator.
 *
 * Returns a generator function, which can be instantiated many times.
 *
 * If `iterable` is a function, it is assumed to be a generator or an
 * iterator, its elements are cached, so that the returned generator
 * function can be instantiated multiple times.
 *
 * If the returned generator is instantiated twice and processed
 * in parallel, the behavior is undefined.
 *
 * If `iterable` is not a function, the behavior of the returned
 * generator upon instantiation will be equivalent to calling
 * `iterable.iterator()`.
 */
fun generator(iterable)
{
    if typeof iterable == "function" {
        const cache       = []
        var   initialized = false
        return fun
        {
            if initialized {
                return cache.iterator()
            }
            else {
                return fun
                {
                    initialized = true
                    for var elem in iterable {
                        cache.push(elem)
                        yield elem
                    }
                } /* Prime the generator */ ()
            }
        }
    }
    else {
        return fun { return iterable.iterator() }
    }
}

/* @item iter empty()
 *
 *     empty()
 *
 * Empty generator.
 *
 * This generator, when instantiated, never yields any objects and
 * terminates immediately.
 */
fun empty
{
    if false {
        yield void
    }
}

/* @item iter iproduct()
 *
 *     iproduct(range_sizes...)
 *
 * A generator which produces permutations of multiple 0-based ranges.
 *
 * Returns an iterator function, which yields subsequent permutations
 * of the specified ranges.
 *
 * The arguments of this function are integers, which specify how many
 * elements each range contains.  The number of input arguments is equal
 * to the number of ranges. The first range is innermost, the last range
 * is outermost.
 *
 * `iter.iproduct(n, m)` is equivalent to `iter.product(range(n), range(m))`.
 *
 * Example:
 *
 *     > iter.iproduct(2, 3) -> print_elements
 *     [0, 0], [1, 0], [0, 1], [1, 1], [0, 2], [1, 2]
 *     > iter.iproduct(3, 2) -> print_elements
 *     [0, 0], [1, 0], [2, 0], [0, 1], [1, 1], [2, 1]
 */
fun iproduct(args...)
{
    const dim = args.size

    if dim == 0 {
        return
    }

    if dim == 1 {
        const num = args[0]
        for var i = 0; i < num; i += 1 {
            yield i
        }
        return
    }

    const step = [0].repeat(dim)

    for var i = 0; i < dim; i += 1 {
        if args[i] <= 0 {
            return
        }
    }

    loop {
        // Make a copy to prevent fiddling outside of the function
        yield [step...]

        for var i = 0; i < dim; i += 1 {
            const next = step[i] + 1
            if next >= args[i] {
                if i + 1 == dim {
                    return
                }
                step[i] = 0
            }
            else {
                step[i] = next
                break
            }
        }
    }
}

/* @item iter product()
 *
 *     product(iterables...)
 *
 * A generator which produces permutations of the output of multiple other
 * generators.
 *
 * Returns an iterator function, which yields arrays containing subsequent
 * permutations of values from input iterable objects.
 *
 * The arguments, `iterables`, are objects on which `iterator()` is invoked
 * to obtain generators for each iterable object.
 *
 * Example:
 *
 *     > iter.product(range(5, 7), "xyz") -> print_elements
 *     [5, x], [6, x], [5, y], [6, y], [5, z], [6, z]
 */
fun product(args...)
{
    const dim = args.size

    if dim == 0 {
        return empty()
    }

    if dim == 1 {
        return args[0].iterator()
    }

    const generators = []
    for var i = 0; i < dim; i += 1 {
        generators.push(generator(args[i]))
    }

    fun product_from_generators(args...)
    {
        if (args.size == 1) {
            for var elem in args[0]() {
                const a = []
                a.resize(dim)
                a[0] = elem
                yield a
            }
            return
        }

        const outer_gen = args.pop()
        const offs      = args.size

        for var elem in outer_gen() {
            for var other in product_from_generators(args...) {
                other[offs] = elem
                yield other
            }
        }
    }

    return product_from_generators(generators...)
}

/* @item iter cycle()
 *
 *     cycle(iterable)
 *
 * A generator which cycles forever over elements of an interable object.
 *
 * Returns an iterator function, which yields subsequent elements of an
 * iterable object cyclically, infinitely.  Once yielding the last element,
 * it starts from the beginning and yields the first and subsequent elements
 * again.
 *
 * `iterable` is an object on which `iterator()` is invoked to obtain subsequent
 * elements of it.  It is wrapped with `iter.generator()`, so that when
 * `iterable` is a function, the elements are cached, so they can be yielded
 * again.
 */
fun cycle(iterable)
{
    const gen = generator(iterable)
    loop {
        for var elem in gen() {
            yield elem
        }
    }
}

/* @item iter reverse()
 *
 *     reverse(iterable)
 *
 * A generator which produces elements of an iterable object in reverse order.
 *
 * For strings, arrays and buffers, returns the object of the same type
 * containing elements in reverse order.
 *
 * For objects of other type, returns an iterator function, which yields
 * elements of the iterable object in backwards order.
 *
 * Examples:
 *
 *     > iter.reverse(range(4)) -> print_elements
 *     3, 2, 1, 0
 *     > iter.reverse("language")
 *     "egaugnal"
 */
fun reverse(iterable)
{
    switch typeof iterable {

        default:
            iterable = [ iterable ... ]
            return fun(iterable_inner) {
                for var i = iterable_inner.size; i; {
                    i -= 1
                    yield iterable_inner[i]
                }
            } (iterable)

        case "string", "array", "buffer":
            return iterable.reverse()
    }
}

