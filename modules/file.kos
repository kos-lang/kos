#
# Copyright (c) 2014-2017 Chris Dragan
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.
#

import lang.buffer

/* @item file ro
 *
 *     ro
 *
 * Flag used with `file.file` and `file.open`.  Indicates that the file is to
 * be opened for reading only.
 *
 * File must exist if this flag is used, or else exception is thrown.
 */
const ro = "rb"

/* @item file rw
 *
 *     rw
 *
 * Flag used with `file.file` and `file.open`.  Indicates that the file is to
 * be opened for reading and writing.
 *
 * File must exist if this flag is used, or else exception is thrown.
 */
const rw = "r+b"

/* @item file create_flag
 *
 *     create_flag
 *
 * Flag used with `file.file` and `file.open`.  Indicates that the file is to
 * be created if it does not exist or truncated if it exists and then opened
 * for reading and writing.
 */
const create_flag = "w+b"

/* @item file append_flag
 *
 *     append_flag
 *
 * Flag used with `file.file` and `file.open`.  Indicates that the file is to
 * be created if it does not exist or opened at at the end for appending.
 * The file is always opened for reading and writing with this flag.
 */
const append_flag = "a+b"

/* @item file open()
 *
 *     open(filename, flags = rw)
 *
 * Opens a file.
 *
 * Returns opened file object.
 *
 * `filename` is the path to the file to open.
 *
 * Optional `flags` specify open mode.  `flags` default to `rw`.
 *
 * It is recommended to use the `file.open()` function in conjunction with
 * the `with` statement.
 *
 * Example:
 *
 *     > with const f = file.open("my.txt", file.create_flag) { f.print("hello") }
 */
fun open(filename, flags = rw)
{
    return file(filename, flags)
}

/* @item file create()
 *
 *     create(filename)
 *
 * Creates a new or truncates an existing file, opens for reading and writing.
 *
 * Returns opened file object.
 *
 * `filename` is the path to the file to create or truncate.
 *
 * It is recommended to use the `file.create()` function in conjunction with
 * the `with` statement.
 *
 * Example:
 *
 *     > with const f = file.create("my.txt") { f.print("hello") }
 */
fun create(filename)
{
    return file(filename, create_flag)
}

/* @item file append()
 *
 *     append(filename)
 *
 * Creates a new or opens an existing file in append mode, opens for reading
 * and writing.
 *
 * Returns opened file object.
 *
 * `filename` is the path to the file to create or truncate.
 *
 * It is recommended to use the `file.append()` function in conjunction with
 * the `with` statement.
 *
 * Example:
 *
 *     > with const f = file.append("my.txt") { f.print("hello") }
 */
fun append(filename)
{
    return file(filename, append_flag)
}

/* @item file file.prototype.read()
 *
 *     file.prototype.read()
 *     file.prototype.read(size [, buffer])
 *
 * Reads bytes from an opened file object.
 *
 * Returns a buffer containing the bytes read.
 *
 * The first variant reads as many bytes as it can, possibly until the end
 * of file.
 *
 * The second variant reads up to `size` bytes, or less if the file does not
 * have that many bytes.  It never reads more than `size` bytes.
 *
 * If `buffer` is specified, bytes are appended to it and that buffer is
 * returned instead of creating a new buffer.
 */
file.prototype.read = fun(in_size = 0x7FFFFFFFFFFFFFFF, in_buf = void)
{
    const size     = in_size
    const buf      = in_buf || buffer()
    var   num_read = 0

    while ! this.eof && num_read < size {
        const prev_size = buf.size
        const to_read   = size - num_read

        this.read_some(to_read > 0x10000 ? 0x10000 : to_read, buf)

        const actual_read = buf.size - prev_size
        if ! actual_read {
            break
        }

        num_read += actual_read
    }

    return buf
}

/* @item file file.prototype.read_lines()
 *
 *     file.prototype.read_lines(keep_ends = false, gran = 0x10000)
 *
 * A generator which produces subsequent lines of text read from a file.
 *
 * Returns an iterator function, which yields subsequent lines read
 * from the file on subsequent invocations.  The lines returned by the
 * iterator function are strings.
 *
 * `keep_ends` tells whether the EOL character sequences should be kept
 * as part of the returned lines.  It defaults to `false`.
 *
 * `gran` is the internal granularity at which the file is read.  It
 * defaults to 64KB.
 */
file.prototype.read_lines = fun(keep_ends = false, gran = 0x10000)
{
    if gran <= 0 {
        gran = 0x10000
    }

    const buf  = buffer()
    var   pos  = 0
    var   crlf = 0

    repeat {
        this.read_some(gran, buf)

        if pos > 0 && buf[pos-1] == 13 {
            pos -= 1
        }

        for ; pos < buf.size; pos += 1 {
            var c = buf[pos]
            if c == 13 {
                const next = pos + 1
                if next < buf.size && buf[next] != 10 {
                    c    = 10
                    crlf = 0
                }
                else {
                    crlf = 1
                }
            }
            else {
                crlf = 0
            }
            if c == 10 {
                const end = pos + 1

                const strend = keep_ends ? end : pos - crlf

                yield buf.unpack("s\(strend)")[0]

                buf.copy_buffer(0, buf, end)
                buf.resize(buf.size - end)

                pos -= end
            }
        }
    } while pos < buf.size || ! this.eof

    if pos > 0 {
        yield buf.unpack("s\(buf.size)")[0]
    }
}
