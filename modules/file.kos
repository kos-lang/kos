#
# Copyright (c) 2014-2017 Chris Dragan
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.
#

import lang.buffer

# Flags for open() and for file constructor
const ro          = "rb"  # open read-only, file must exist
const rw          = "r+b" # open read-write, file must exist
const create_flag = "w+b" # create new or truncate existing, read-write
const append_flag = "a+b" # create new or append at the end of existing, read-write

fun open(filename, flags = rw)
{
    return file(filename, flags)
}

fun create(filename)
{
    return file(filename, create_flag)
}

fun append(filename)
{
    return file(filename, append_flag)
}

file.prototype.read = fun(in_size = 0x7FFFFFFFFFFFFFFF, in_buf = void)
{
    const size     = in_size
    const buf      = in_buf || buffer()
    var   num_read = 0

    while ! this.eof && num_read < size {
        const prev_size = buf.size
        const to_read   = size - num_read

        this.read_some(to_read > 0x10000 ? 0x10000 : to_read, buf)

        const actual_read = buf.size - prev_size
        if ! actual_read {
            break
        }

        num_read += actual_read
    }

    return buf
}

file.prototype.read_lines = fun(keep_ends = false, gran = 0x10000)
{
    if gran <= 0 {
        gran = 0x10000
    }

    const buf  = buffer()
    var   pos  = 0
    var   crlf = 0

    repeat {
        this.read_some(gran, buf)

        if pos > 0 && buf[pos-1] == 13 {
            pos -= 1
        }

        for ; pos < buf.size; pos += 1 {
            var c = buf[pos]
            if c == 13 {
                const next = pos + 1
                if next < buf.size && buf[next] != 10 {
                    c    = 10
                    crlf = 0
                }
                else {
                    crlf = 1
                }
            }
            else {
                crlf = 0
            }
            if c == 10 {
                const end = pos + 1

                const strend = keep_ends ? end : pos - crlf

                yield buf.unpack("s\(strend)")[0]

                buf.copy_buffer(0, buf, end)
                buf.resize(buf.size - end)

                pos -= end
            }
        }
    } while pos < buf.size || ! this.eof

    if pos > 0 {
        yield buf.unpack("s\(buf.size)")[0]
    }
}
