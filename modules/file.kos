#
# Copyright (c) 2014-2017 Chris Dragan
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.
#

import lang.buffer;

# Flags for open() and for file constructor
const ro     = "rb";  # open read-only, file must exist
const rw     = "r+b"; # open read-write, file must exist
const create = "w+b"; # create new or truncate existing, read-write
const append = "a+b"; # create new or append at the end of existing, read-write

fun open(filename, args...)
{
    const flags = args.size > 0 ? args[0] : rw;
    return new file(filename, flags);
}

file.prototype.read = fun(args...)
{
    const size     = args.size > 0 ? args[0] : 0x7FFFFFFFFFFFFFFF;
    const buf      = args.size > 1 ? args[1] : new buffer;
    var   num_read = 0;

    while ! this.eof && num_read < size {
        const prev_size = buf.size;
        const to_read   = size - num_read;

        this.read_some(to_read > 0x10000 ? 0x10000 : to_read, buf);

        const actual_read = buf.size - prev_size;
        if ! actual_read {
            break;
        }

        num_read += actual_read;
    }

    return buf;
};

file.prototype.read_lines = fun(args...)
{
    const gran = (args.size > 0 && args[0] > 0) ? args[0] : 0x10000;
    const buf  = new buffer;
    var   pos    = 0;

    do {
        this.read_some(gran, buf);

        if pos > 0 && buf[pos-1] == 13 {
            pos -= 1;
        }

        for ; pos < buf.size; pos += 1 {
            const c = buf[pos];
            if c == 10 || (c == 13 && pos+1 < buf.size && buf[pos+1] != 10) {
                const end = pos + 1;

                yield buf.unpack("s\(end)")[0];

                buf.copy_buffer(0, buf, end);
                buf.resize(buf.size - end);

                pos -= end;
            }
        }
    }
    while pos < buf.size || ! this.eof;

    if pos > 0 {
        yield buf.unpack("s\(buf.size)")[0];
    }
};
