# SPDX-License-Identifier: MIT
# SPDX-FileCopyrightText: Copyright (c) 2014-2024 Chris Dragan

/* @item base range()
 *
 *     range(stop)
 *     range(start, stop, step = 1)
 *
 * A generator which produces an arithmetic progression of numbers.
 *
 * Returns an iterator function, which yields subsequent numbers in
 * the specified range.
 *
 * `start`, `stop` and `step` arguments are integers or floats.
 *
 * `start` specifies the first number returned by the iterator.  `start`
 * defaults to `0`.
 *
 * `step` specified the increment which is added to subsequently returned
 * numbers.  If `step` is greater than zero, the generated sequence is
 * ascending.  If `step` is negative, the generated sequence is descending.
 * If `step` is zero, no numbers are generated.
 *
 * `stop` specifies the number ending the sequence, but not included in it.
 * The iterator terminates when it reaches or exceeds `stop`.
 *
 * Examples:
 *
 *     > range(5) -> array
 *     [0, 1, 2, 3, 4]
 *     > range(1, 5) -> array
 *     [1, 2, 3, 4]
 *     > range(0, 16, 4) -> array
 *     [0, 4, 8, 12]
 *     > range(0) -> array
 *     []
 *     > range(2, -8, -2) -> array
 *     [2, 0, -2, -4, -6]
 *     > for const x in range(2) { print(x) }
 *     0
 *     1
 */
public fun range(start, args...)
{
    var   stop  = 0
    var   step  = 1
    const nargs = args.size

    if nargs {
        stop  = args[0]
    }
    else {
        stop  = start
        start = 0
    }

    if nargs > step { // args.size > 1
        step = args[1]
    }

    if step > 0 {
        while start < stop {
            yield start
            start += step
        }
    }
    else if step < 0 {
        while start > stop {
            yield start
            start += step
        }
    }
}

/* @item base object.prototype.iterator()
 *
 *     object.prototype.iterator()
 *
 * A generator which produces properties of an object in a shallow manner,
 * i.e. without descending into prototypes.
 *
 * Returns an iterator function, which yields 2-element arrays, which are
 * [key, value] pairs of subsequent properties of the object.
 *
 * The order of the elements yielded is unspecified.
 *
 * This is equivalent to `shallow()` function.
 *
 * If the object is not of type `object`, e.g. if it is an integer,
 * a float, a boolean or a non-generator function, the iterator yields
 * the object itself.  Prototypes of array, string, buffer and function override
 * this generator.
 *
 * Note that `void` object does not have any properties, not even `iterator()`
 * function, so it is not possible to iterate over it.
 *
 * The `iterator()` function is also implicitly invoked by the `for-in` loop
 * statement.
 *
 * Examples:
 *
 *     > { red: 1, green: 10, blue: 100 }.iterator() -> array
 *     [["red", 1], ["green", 10], ["blue", 100]]
 *     > 1.5.iterator() -> array
 *     [1.5]
 *     > true.iterator() -> array
 *     [true]
 *     > for const k, v in { x: 10, y: -2 } { print(k, v) }
 *     x 10
 *     y -2
 */
object.prototype.iterator = fun
{
    if typeof this == "object" {
        return shallow(this)
    }
    else {
        return fun(value) { yield value } (this)
    }
}

fun iterator
{
    for const i in range(this.size) {
        yield this[i]
    }
}

/* @item base array.prototype.iterator()
 *
 *     array.prototype.iterator()
 *
 * A generator which produces subsequent elements of an array.
 *
 * Returns an iterator function, which yields subsequent elements.
 *
 * The `iterator()` function is also implicitly invoked by the `for-in` loop
 * statement.
 *
 * Example:
 *
 *     > for const v in [ 1, 2, 3 ] { print(v) }
 *     1
 *     2
 *     3
 */
array.prototype.iterator = iterator

/* @item base string.prototype.iterator()
 *
 *     string.prototype.iterator()
 *
 * A generator which produces subsequent elements of a string.
 *
 * Returns an iterator function, which yields single-character strings
 * containing subsequent characters of the string.
 *
 * The `iterator()` function is also implicitly invoked by the `for-in` loop
 * statement.
 *
 * Examples:
 *
 *     > "koslang".iterator() -> array
 *     ["k", "o", "s", "l", "a", "n", "g"]
 *     > for const v in "foo" { print(v) }
 *     f
 *     o
 *     o
 */
string.prototype.iterator = iterator

/* @item base buffer.prototype.iterator()
 *
 *     buffer.prototype.iterator()
 *
 * A generator which produces subsequent elements of a buffer.
 *
 * Returns an iterator function, which yields integers, which are
 * subsequent elements of the buffer.
 *
 * The `iterator()` function is also implicitly invoked by the `for-in` loop
 * statement.
 *
 * Examples:
 *
 *     > buffer([1, 2, 3]).iterator() -> array
 *     [1, 2, 3]
 *     > for const v in buffer([10, 11, 12]) { print(v) }
 *     10
 *     11
 *     12
 */
buffer.prototype.iterator = iterator

/* @item base generator.prototype.iterator()
 *
 *     generator.prototype.iterator()
 *
 * Returns the generator itself (`this`).
 *
 * The `iterator()` generator is also implicitly invoked by the `for-in` loop
 * statement.
 *
 * This allows passing an iterator from an instantiated generator to be
 * passed to a `for-in` loop.
 *
 * Examples:
 *
 *     > for const x in range(2) { print(x) }
 *     0
 *     1
 */
generator.prototype.iterator = () => this

/* @item base generator.prototype.next()
 *
 *     generator.prototype.next([value])
 *
 * Returns the next item from an instantiated generator (iterator function).
 *
 * This is equivalent to just calling the iterator function itself to obtain
 * the next element.
 *
 * The optional `value` argument is passed to the generator and is returned
 * from the `yield` expression inside the generator - whether the generator
 * will use this value is generator-specific.
 *
 * This function throws an exception if the generator function hasn't been
 * instantiated.
 *
 * Examples:
 *
 *     > const it = range(10)
 *     > it.next()
 *     0
 *     > it.next()
 *     1
 */
generator.prototype.next = fun(args...)
{
    assert this.state != "init"
    return this.apply(void, args)
}

/* @item base generator.prototype.slice()
 *
 *     generator.prototype.slice(begin, end)
 *
 * A generator which produces a range of elements returned from an iterator
 * function.
 *
 * Returns an iterator function, which yields the specified subset of elements
 * yielded by the iterator function on which it is invoked.
 *
 * `begin` and `end` specify the range of elements to generate.
 * `begin` is the index of the first element and `end` is the index
 * of the element trailing the last element to extract.
 * A negative index is an offset from the end of the range generated by the
 * iterator on which this function is invoked, such that `-1` indicates the
 * last element, and so on.  If either `begin` or `end` is negative, the
 * returned value is an array instead of an iterator, which is still iterable.
 * If `begin` is `void`, it is equivalent to `0`.  If `end` is `void`, all
 * elements will be returned until the iterator is finished.
 *
 * Conceptually, all `begin` elements are skipped, then elements from
 * `begin` index and up to, but excluding `end` index are returned.
 *
 * This function is invoked by the slice operator.
 *
 * Examples:
 *
 *     > range(10).slice(3, 6) -> array
 *     [3, 4, 5]
 *     > range(10).slice(7, void) -> array
 *     [7, 8, 9]
 */
generator.prototype.slice = fun(begin, end)
{
    begin = begin == void ? 0   : integer(begin)
    end   = end   == void ? end : integer(end)

    if begin < 0 || (end != void && end < 0) {
        return [this...][begin:end];
    }
    else {
        return fun(that, begin, end) {
            var i = 0

            if i < begin {
                for const skip in that {
                    i += 1
                    if i >= begin {
                        break
                    }
                }
            }

            if end == void {
                for const elem in that {
                    yield elem
                }
            }
            else if i < end {
                for const elem in that {
                    yield elem
                    i += 1
                    if i >= end {
                        break
                    }
                }
            }
        } (this, begin, end)
    }
}

/* @item base array.prototype.insert()
 *
 *     array.prototype.insert(pos, iterable)
 *     array.prototype.insert(begin, end, iterable)
 *
 * Inserts elements into an array, possibly replacing existing elements.
 *
 * The array is modified in-place.
 *
 * Returns the array itself (`this`).
 *
 * `pos` specifies the array index at which elements are to be inserted.
 * If `pos` is negative, it is relative to the array's size.
 * If `pos` is `void`, elements are inserted at the end of the array.
 *
 * `begin` and `end` specify a range of elements to be removed from the
 * array and replaced by the inserted elements.  A negative `begin` or
 * `end` is relative to the array's size.  `begin` is the index of the
 * first element to be removed and `end` is the index of the first element
 * after the removed range which will stay.  If `begin` is equal to `end`,
 * they are both equivalent to `pos`.
 *
 * `iterable` is an iterable object on which `iterator()` function is invoked
 * to obtain elements to be inserted into the array.
 *
 * Examples:
 *
 *     > [1, 2, 3].insert(0, ["foo"])
 *     ["foo", 1, 2, 3]
 *     > [1, 2, 3].insert(-1, ["foo"])
 *     [1, 2, "foo", 3]
 *     > [1, 2, 3, 4].insert(1, 2, "foo")
 *     [1, "f", "o", "o", 3, 4]
 *     > [1, 2, 3, 4].insert(0, 3, [])
 *     [4]
 */
array.prototype.insert = fun(begin, iterable, args...)
{
    var end = begin

    if args.size {
        end      = iterable
        iterable = args[0]
    }
    else {
        if end == void {
            begin = this.size
        }
    }

    if typeof iterable == "array" {
        return this["insert_array"](begin, end, iterable)
    }
    else {
        const size = this.size
        if begin == void {
            begin = 0
        }
        if end == void {
            end = size
        }
        if begin < 0 {
            begin += size
        }
        if end < 0 {
            end += size
        }
        if begin < 0 {
            begin = 0
        }
        if end > size {
            end = size
        }
        if end < begin {
            end = begin
        }

        const iterator = iterable.iterator()

        if begin < end {
            for var value in iterator {
                this[begin] = value
                begin += 1
                if begin >= end {
                    break
                }
            }
        }

        return this["insert_array"](begin, end, [iterator...])
    }
}

/* @item base buffer.prototype.insert()
 *
 *     buffer.prototype.insert(pos, obj)
 *     buffer.prototype.insert(begin, end, obj)
 *
 * Inserts elements into a buffer, possibly replacing existing elements.
 *
 * The buffer is modified in-place.
 *
 * Returns the buffer itself (`this`).
 *
 * `pos` specifies the buffer index at which elements are to be inserted.
 * If `pos` is negative, it is relative to the buffer's size.
 * If `pos` is `void`, elements are inserted at the end of the buffer.
 *
 * `begin` and `end` specify a range of elements to be removed from the
 * buffer and replaced by the inserted elements.  A negative `begin` or
 * `end` is relative to the buffer's size.  `begin` is the index of the
 * first element to be removed and `end` is the index of the first element
 * after the removed range which will stay.  If `begin` is equal to `end`,
 * they are both equivalent to `pos`.
 *
 * `iterable` is an iterable object on which `iterator()` function is invoked
 * to obtain elements to be inserted into the buffer.  The elements to be
 * inserted, which are yielded by the iterator, must be numbers from 0 to 255.
 */
buffer.prototype.insert = fun(begin, iterable, args...)
{
    var   end  = begin
    const size = this.size

    if args.size {
        end      = iterable
        iterable = args[0]
    }
    else {
        if end == void {
            begin = size
        }
    }

    if begin == void {
        begin = 0
    }
    if end == void {
        end = size
    }
    if begin < 0 {
        begin += size
    }
    if end < 0 {
        end += size
    }
    if begin < 0 {
        begin = 0
    }
    if end > size {
        end = size
    }
    if end < begin {
        end = begin
    }

    if typeof iterable != "buffer" {
        iterable = buffer(typeof iterable == "string" ? iterable : iterable.iterator())
    }

    const new_size = this.size + iterable.size + begin - end
    if new_size > size {
        this.resize(new_size)
    }
    if end < size {
        this.copy_buffer(begin + iterable.size, this, end)
    }
    if new_size < size {
        this.resize(new_size)
    }

    if iterable.size {
        return this.copy_buffer(begin, iterable)
    }
    else {
        return this
    }
}

fun get_value_from_array(index, default_value = void)
{
    const size = this.size
    if index < 0 {
        index = size + index
        if index < 0 {
            index = size
        }
    }
    return index < size ? this[index] : default_value
}

/* @item base array.prototype.get()
 *
 *     array.prototype.get(index, default_value = void)
 *
 * Retrieves array element without ever failing.
 *
 * If the element at the specified `index` exists, returns that element,
 * otherwise returns `default_value`.
 *
 * If another thread resizes the array while this function is
 * executing, an exception could be thrown or incorrect element may
 * be returned if `index` was negative.
 *
 * Examples:
 *
 *     > ["a", "b", "c", "d"].get(2, "-")
 *     "c"
 *     > ["a", "b", "c", "d"].get(20, "-")
 *     "-"
 *     > ["a", "b", "c", "d"].get(-1, "-")
 *     "d"
 */
array.prototype.get = get_value_from_array

/* @item base buffer.prototype.get()
 *
 *     buffer.prototype.get(index, default_value = void)
 *
 * Retrieves buffer element without ever failing.
 *
 * If the element at the specified `index` exists, returns that element,
 * otherwise returns `default_value`.
 *
 * If another thread resizes the array while this function is
 * executing, an exception could be thrown or incorrect element may
 * be returned if `index` was negative.
 *
 * Examples:
 *
 *     > buffer([10, 11, 12, 13]).get(2, "-")
 *     12
 *     > buffer([10, 11, 12, 13]).get(20, "-")
 *     "-"
 *     > buffer([10, 11, 12, 13]).get(-1, "-")
 *     13
 */
buffer.prototype.get = get_value_from_array

/* @item base string.prototype.get()
 *
 *     string.prototype.get(index, default_value = void)
 *
 * Retrieves string element without ever failing.
 *
 * If the element at the specified `index` exists, returns that element,
 * otherwise returns `default_value`.
 *
 * Examples:
 *
 *     > "abcd".get(2, "-")
 *     "c"
 *     > "abcd".get(20, "-")
 *     "-"
 *     > "abcd".get(-1, "-")
 *     "d"
 */
string.prototype.get = get_value_from_array

/* @item base object.prototype.get()
 *
 *     object.prototype.get(key, default_value = void)
 *
 * Retrieves object element without ever failing.  The object is addressed
 * in a shallow manner, without following prototype chain.
 *
 * If the element at the specified `key` exists, returns that element,
 * otherwise returns `default_value`.
 *
 * If another thread deletes the element while this function is
 * executing, an exception could be thrown or an element from the
 * prototype could be returned.
 *
 * Examples:
 *
 *     > {a:1, b:2, c:3}.get("a", "-")
 *     1
 *     > {a:1, b:2, c:3}.get("x", 0)
 *     0
 *     > {a:1, b:2, c:3}.get("y")
 *     void
 */
object.prototype.get = fun(key, default_value = void)
{
    if key in this {
        return this[key]
    }

    return default_value
}

/* @item base string.prototype.ljust()
 *
 *     string.prototype.ljust(size, fill = " ")
 *
 * Left-justifies a string.
 *
 * Returns a new, left-justified string of the requested size.
 *
 * `size` is the length of the returned string.  If `size` is less than
 * the length of the current string, the current string is returned
 * unmodified.
 *
 * `fill` is a string of length 1 containing the character to add on the right
 * side of the string to justify it.  The function throws an exception if
 * `fill` is not a string or has a different length than 1.  `fill` defaults
 * to a space character.
 *
 * Examples:
 *
 *     > "abc".ljust(5)
 *     "abc  "
 *     > "abc".ljust(7, ".")
 *     "abc...."
 *     > "abc".ljust(1)
 *     "abc"
 */
string.prototype.ljust = fun(size, fill = " ")
{
    assert typeof fill == "string"
    assert fill.size   == 1

    if this.size >= size {
        return this
    }

    return this + fill.repeats(size - this.size)
}

/* @item base string.prototype.rjust()
 *
 *     string.prototype.rjust(size, fill = " ")
 *
 * Right-justifies a string.
 *
 * Returns a new, right-justified string of the requested size.
 *
 * `size` is the length of the returned string.  If `size` is less than
 * the length of the current string, the current string is returned
 * unmodified.
 *
 * `fill` is a string of length 1 containing the character to add on the left
 * side of the string to justify it.  The function throws an exception if
 * `fill` is not a string or has a different length than 1.  `fill` defaults
 * to a space character.
 *
 * Examples:
 *
 *     > "abc".rjust(5)
 *     "  abc"
 *     > "abc".rjust(7, ".")
 *     "....abc"
 *     > "abc".rjust(1)
 *     "abc"
 */
string.prototype.rjust = fun(size, fill = " ")
{
    assert typeof fill == "string"
    assert fill.size   == 1

    if this.size >= size {
        return this
    }

    return fill.repeats(size - this.size) + this
}

/* @item base string.prototype.zfill()
 *
 *     string.prototype.zfill(size, fill = "0")
 *
 * Zero-fills a string, assuming it contains a number.
 *
 * Returns a new string of the requested size.  If the original string starts
 * with a `+` or `-` character, this character remains at the beginning of
 * the returned string.
 *
 * `size` is the length of the returned string.  If `size` is less than
 * the length of the current string, the current string is returned
 * unmodified.
 *
 * `fill` is a string of length 1 containing the character to add on the left
 * side of the string (after the `+` or `-` sign) to achieve the requested
 * length.  The function throws an exception if `fill` is not a string or has
 * a different length than 1.  `fill` defaults to `"0"`.
 *
 * Examples:
 *
 *     > "123".zfill(5)
 *     "00123"
 *     > "+123".zfill(7)
 *     "+000123"
 *     > "+abc".zfill(6, "-")
 *     "+--abc"
 */
string.prototype.zfill = fun(size, fill = "0")
{
    assert typeof fill == "string"
    assert fill.size   == 1

    if this.size >= size {
        return this
    }

    const fill = fill.repeats(size - this.size)

    const sign = this.size ? this[0] : ""

    if sign == "+" || sign == "-" {
        return stringify(sign, fill, this[1:])
    }
    else {
        return fill + this
    }
}

/* @item base whitespace
 *
 *     whitespace
 *
 * A string containing all characters considered as whitespace by some
 * functions.
 */
public const whitespace = " \r\n\t\f\v\xA0\x{2028}\x{2029}\x{FEFF}"

/* @item base eol
 *
 *     eol
 *
 * A string containing all characters considered as end of line markers by
 * some functions.
 */
public const eol = "\n\r\v\f\x1C\x1D\x1E\x85\x{2028}\x{2029}"

/* @item base string.prototype.lstrip()
 *
 *     string.prototype.lstrip(chars = whitespace)
 *
 * Removes all leading whitespace characters from a string.
 *
 * Returns a new string with all whitespace characters removed from
 * its beginning.
 *
 * `chars` is a string, which specifies the list of characters treated
 * as whitespace.  It defaults to `base.whitespace`.
 *
 * Example:
 *
 *     > "  foo  ".lstrip()
 *     "foo  "
 */
string.prototype.lstrip = fun(chars = whitespace)
{
    const pos = this.scan(chars, 0, false)
    if pos != -1 {
        return this[pos :]
    }
    return ""
}

/* @item base string.prototype.rstrip()
 *
 *     string.prototype.rstrip(chars = whitespace)
 *
 * Removes all trailing whitespace characters from a string.
 *
 * Returns a new string with all whitespace characters removed from
 * its end.
 *
 * `chars` is a string, which specifies the list of characters treated
 * as whitespace.  It defaults to `base.whitespace`.
 *
 * Example:
 *
 *     > "  foo  ".rstrip()
 *     "  foo"
 */
string.prototype.rstrip = fun(chars = whitespace)
{
    const pos = this.rscan(chars, void, false)
    return this[: pos + 1]
}

/* @item base string.prototype.strip()
 *
 *     string.prototype.strip(chars = whitespace)
 *
 * Removes all leading and trailing whitespace characters from a string.
 *
 * Returns a new string with all whitespace characters removed from
 * its beginning and end.
 *
 * `chars` is a string, which specifies the list of characters treated
 * as whitespace.  It defaults to `base.whitespace`.
 *
 * Example:
 *
 *     > "  foo  ".strip()
 *     "foo"
 */
string.prototype.strip = fun(chars = whitespace)
{
    const lpos = this.scan(chars, 0, false)
    if lpos != -1 {
        const rpos = this.rscan(chars, void, false)
        return this[lpos : rpos + 1]
    }
    return ""
}

/* @item base string.prototype.split()
 *
 *     string.prototype.split(sep = void, max_split = -1)
 *
 * A generator which splits a string and produces subsequent parts.
 *
 * Returns an iterator function, which yields subsequent parts of
 * the string.  The parts result from splitting the string using
 * the `sep` separator.
 *
 * `sep` is a string which is used as a separator.  It must be non-empty.
 * The source string is split into parts by finding any occurences of
 * the separator.  The separator is not part of the resulting strings.
 *
 * `sep` defaults to `void`, which indicates that a sequence of whitespaces
 * of any length should be used to split the string.
 *
 * `max_split` indicates the maximum number of parts into which the string
 * is going to be split.  By default it is -1, in which case the number
 * of resulting parts is unlimited.
 *
 * Examples:
 *
 *     > "a  b    c     d".split() -> array
 *     ["a", "b", "c", "d"]
 *     > "a--b--c--d--e--f".split("--", 3) -> array
 *     ["a", "b", "c--d--e--f"]
 */
string.prototype.split = fun(sep = void, max_split = -1)
{
    assert sep != ""

    if max_split == 0 {
        return
    }
    if max_split < 0 {
        max_split = 0x10000
    }

    if sep == void {
        const chars = whitespace

        var pos = this.scan(chars, 0, false)
        if pos == -1 {
            return
        }

        for const i in range(max_split - 1) {
            const end = this.scan(chars, pos)
            if end == -1 {
                yield this[pos:]
                return
            }
            yield this[pos:end]

            pos = this.scan(chars, end, false)
            if pos == -1 {
                return
            }
        }

        yield this[pos:]
    }
    else {
        var pos = 0

        for const i in range(max_split - 1) {
            const end = this.find(sep, pos)
            if end == -1 {
                yield this[pos:]
                return
            }
            yield this[pos:end]

            pos = end + sep.size
        }

        yield this[pos:]
    }
}

/* @item base string.prototype.split_lines()
 *
 *     string.prototype.split_lines(keep_ends = false)
 *
 * A generator which produces subsequent lines extracted from a string.
 *
 * Returns an iterator function, which yields strings, which are subsequent
 * lines, resulting from splitting the string using EOL characters from
 * `base.eol`.
 *
 * Two subsequent EOL characters will yield an empty line, except if a CR
 * characters is followed by an LF character, in which case they are kept
 * together as one line separator.
 *
 * `keep_ends` is a boolean, which indicates whether the EOL characters
 * should be kept at the ends of the lines.  It defaults to `false`.
 *
 * Examples:
 *
 *     > "line1\nline2\nline3".split_lines() -> array
 *     ["line1", "line2", "line3"]
 */
string.prototype.split_lines = fun(keep_ends = false)
{
    var   pos   = 0
    const len   = this.size
    const chars = eol

    loop {
        if pos == len {
            return
        }

        const end = this.scan(chars, pos)
        if end == -1 {
            yield this[pos:]
            return
        }

        const endp1 = end + 1
        if this[end] == "\r" && endp1 < len && this[endp1] == "\n" {
            const endp2 = end + 2
            yield this[pos : keep_ends ? endp2 : end]
            pos = endp2
            continue
        }
        else {
            yield this[pos : keep_ends ? endp1 : end]
            pos = endp1
        }
    }
}

/* @item base first()
 *
 *     first(iterable)
 *
 * Returns the first element from an iterable object.
 *
 * If `iterable` is an object, it can return any key-value pair.
 *
 * Throws an exception if there is no first element.
 *
 * Examples:
 *
 *     > first("ABC")
 *     "A"
 *     > first(range(5, 10))
 *     5
 *     > { A: 1, B: 2, C: 3} -> map(first) -> array
 *     ["A", "C", "B"]
 */

public fun first(iterable)
{
    switch typeof iterable {

        case "array", "string", "buffer" {
            if iterable.size {
                return iterable[0]
            }
        }

        case "void" {
            break
        }

        default {
            for const elem in iterable {
                return elem
            }
        }
    }

    throw "no first element"
}

/* @item base last()
 *
 *     last(iterable)
 *
 * Returns the last element from an iterable object.
 *
 * If `iterable` is an object, it can return any key-value pair.
 *
 * Throws an exception if there are no element in the iterable object.
 *
 * Examples:
 *
 *     > last("ABC")
 *     "C"
 *     > last(range(5, 10))
 *     9
 */

public fun last(iterable)
{
    switch typeof iterable {

        case "array", "string", "buffer" {
            const size = iterable.size
            if size {
                return iterable[size - 1]
            }
        }

        case "void" {
            break
        }

        case "object" {
            for const elem in iterable {
                return elem
            }
        }

        default {
            var prev = void
            var has_elems = false
            for const elem in iterable {
                has_elems = true
                prev = elem
            }
            if has_elems {
                return prev
            }
        }
    }

    throw "no last element"
}

/* @item base map()
 *
 *     map(op)
 *     map(op, iterable)
 *
 * A generator which applies a function to each element of an iterable object.
 *
 * The first variant with one argument returns another function, which can
 * then be applied on any iterable object to map it.
 *
 * The second variant applies the provided function to the elements of
 * the specified iterable object.  It returns an iterator function, which
 * yields subsequent elements mapped through the `op` function.
 *
 * `op` is the function to invoke on each element of the iterable object.
 *
 * `iterable` is an object on which `iterator()` is invoked to obtain subsequent
 * elements of it, which are then mapped.
 *
 * Examples:
 *
 *     > map(x => x*10, [1, 2, 3, 4]) -> array
 *     [10, 20, 30, 40]
 *     > const plus2 = map(x => x + 2)
 *     > plus2([10, 11, 12, 13]) -> array
 *     [12, 13, 14, 15]
 */
public fun map(op, args...)
{
    assert op instanceof function

    fun map_f(source)
    {
        const transform = op
        for var elem in source {
            yield transform(elem)
        }
    }

    if args.size {
        return map_f(args[0])
    }
    else {
        return map_f
    }
}

/* @item base filter()
 *
 *     filter(op)
 *     filter(op, iterable)
 *
 * A generator which filters elements of an iterable object using the provided
 * function.
 *
 * The first variant with one argument returns another function, which can
 * then be applied on any iterable object to filter it.
 *
 * The second variant uses the provided function on the elements of
 * the specified iterable object.  It returns an iterator function, which
 * yields subsequent elements for which the function returns a truthy value.
 *
 * `op` is the function to invoke on each element of the iterable object.
 *
 * `iterable` is an object on which `iterator()` is invoked to obtain subsequent
 * elements of it, which are then filtered.
 *
 * Examples:
 *
 *     > filter(x => x < 0, [1, -2, 3, 4, -5, -6]) -> array
 *     [-2, -5, -6]
 *     > const odd = filter(x => x & 1)
 *     > odd([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) -> array
 *     [9, 7, 5, 3, 1]
 */
public fun filter(op, args...)
{
    assert op instanceof function

    fun filter_f(source)
    {
        const condition = op
        for var elem in source {
            if condition(elem) {
                yield elem
            }
        }
    }

    if args.size {
        return filter_f(args[0])
    }
    else {
        return filter_f
    }
}

/* @item base reduce()
 *
 *     reduce(op, init)
 *     reduce(op, init, iterable)
 *
 * Performs left fold operation on subsequent elements of an iterable object.
 *
 * The first variant returns a function which can then be directly applied
 * to any iterable object.
 *
 * The second variant performs the application immediately.
 *
 * `op` is the function which is the reduction operator.  It has two arguments,
 * the first argument is the accumulator value and the second argument is the
 * subsequent value from the iterable object.
 *
 * The `op` function is invoked as many times as there are elements in
 * the iterable object, once for every subsequent element, in the order from
 * first to last.  On the first invocation, the accumulator value (first
 * argument) is set to `init`.  On subsequent invocations of the `op` function,
 * the accumulator has the value returned by the previous invocation of
 * the `op` function.
 *
 * `init` is the initial element to use for the fold.
 *
 * `iterable` is an object on which `iterator()` is invoked to obtain subsequent
 * elements of it, on which the reduction is performed.
 *
 * The reduce (left fold) operation can also be written as follows:
 *
 *     const a = [e1, e2, e3, ...]
 *     const reduce = op(op(op(op(init, e1), e2), e3), ...)
 *
 * Examples:
 *
 *     > reduce((acc, val) => acc * val, 1, [1, 2, 1, 3, 5])
 *     30
 *     > const count_non_zero = reduce((acc, x) => acc + (x ? 1 : 0), 0)
 *     > count_non_zero([0, 0, 4, 0, 0, 5, 6, 0])
 *     3
 *     > const fruit = [ { name: "apple",  number: 5 },
 *     _                 { name: "orange", number: 3 },
 *     _                 { name: "pear",   number: 7 } ]
 *     > fruit -> reduce((acc, obj) => acc + obj.number, 0)
 *     15
 */
public fun reduce(op, init, args...)
{
    assert op instanceof function

    fun reduce_f(source)
    {
        const fold  = op
        var   accum = init
        for var elem in source {
            accum = fold(accum, elem)
        }
        return accum
    }

    if args.size {
        return reduce_f(args[0])
    }
    else {
        return reduce_f
    }
}

/* @item base sum()
 *
 *     sum(iterable, init = 0)
 *
 * Sums all elements of an iterable.
 *
 * Performs an addition of all elements of the `iterable` object using the `+=`
 * operator.  Elements are retrieved through the `iterator()` function.
 *
 * `init` is an optional initial value to which all subsequent elements are
 * added and defaults to `0`.
 *
 * The function can also be used with strings, in which case `init` must be
 * provided as a string.
 *
 * Examples:
 *
 *     > sum([10, 20, 11, 15])
 *     56
 *     > sum(["Hello", ", ", "World!"], "")
 *     "Hello, World!"
 */
public fun sum(iterable, total = 0)
{
    for const elem in iterable {
        total += elem
    }
    return total
}

/* @item base count()
 *
 *     count(op)
 *     count(op, iterable)
 *
 * Counts elements of an iterable object with a predicate.
 *
 * The first variant returns a function which can then be used with various
 * iterable objects to count their elements.
 *
 * The second variant counts all elements of an iterable object, retrieved
 * through the `iterator()` function, using `op` to test elements.
 *
 * If `op` is a function, applies it to every element and then counts for
 * how many elements the `op` function returns `true`.
 *
 * If `op` is not a function, counts how many elements equal to `op` by
 * comparing each element to `op` using `==` operator.
 *
 * Examples:
 *
 *     > count(x => x > 0, [-1, 1, 2, -3, 4])
 *     3
 *     > const count_numbers = count(x => x instanceof number)
 *     > count_numbers([10, 2, "foo", 30, "bar", 4])
 *     4
 *     > count("o", "monologue")
 *     3
 */
public fun count(op, args...)
{
    var count_f = op instanceof function ?
        fun(source)
        {
            const test  = op
            var   count = 0
            for var elem in source {
                if test(elem) {
                    count += 1
                }
            }
            return count
        }
        :
        fun(source)
        {
            const val   = op
            var   count = 0
            for var elem in source {
                if elem == val {
                    count += 1
                }
            }
            return count
        }

    if args.size {
        return count_f(args[0])
    }
    else {
        return count_f
    }
}

/* @item base all()
 *
 *     all(op)
 *     all(op, iterable)
 *
 * Determines if all elements of an iterable object fulfill a condition.
 *
 * The first variant returns a function which can then be used with various
 * iterable objects to test their elements.
 *
 * The second variant returns `true` if all elements of an iterable object,
 * retrieved through the `iterator()` function, test positively against
 * the `op` predicate and the test evaluates to a truthy value.
 * Otherwise returns `false`.
 *
 * The function stops iterating over elements as soon as the `op` predicate
 * evaluates to a falsy value.
 *
 * If the `op` predicate is a function, it is invoked for each element
 * passed as an argument and then its return value is used as the result
 * of the test.
 *
 * If `op` is not a function, the test is performed by comparing `op`
 * against each element using the `==` operator.
 *
 * Examples:
 *
 *     > all(x => x > 0, [1, 2, 3, 4])
 *     true
 *     > all(x => x > 0, [0, 1, 2, 3])
 *     false
 *     > const all_numbers = all(x => typeof x == "number")
 *     > all_numbers([1, 2, 3, 4])
 *     true
 *     > all_numbers([1, 2, "foo", 3])
 *     false
 */
public fun all(op, args...)
{
    var all_f = op instanceof function ?
        fun(source)
        {
            const test = op
            for var elem in source {
                if ! test(elem) {
                    return false
                }
            }
            return true
        }
        :
        fun(source)
        {
            const val = op
            for var elem in source {
                if elem != val {
                    return false
                }
            }
            return true
        }

    if args.size {
        return all_f(args[0])
    }
    else {
        return all_f
    }
}

/* @item base any()
 *
 *     any(op)
 *     any(op, iterable)
 *
 * Determines if any elements of an iterable object fulfill a condition.
 *
 * The first variant returns a function which can then be used with various
 * iterable objects to test their elements.
 *
 * The second variant returns `true` if one or more elements of an iterable object,
 * retrieved through the `iterator()` function, test positively against
 * the `op` predicate and the test evaluates to a truthy value.
 * Otherwise returns `false`.
 *
 * The function stops iterating over elements as soon as the `op` predicate
 * evaluates to a truthy value.
 *
 * If the `op` predicate is a function, it is invoked for each element
 * passed as an argument and then its return value is used as the result
 * of the test.
 *
 * If `op` is not a function, the test is performed by comparing `op`
 * against each element using the `==` operator.
 *
 * Examples:
 *
 *     > any(x => x > 0, [0, 20, -1, -20])
 *     true
 *     > any(x => x < 0, [0, 1, 2, 3])
 *     false
 *     > const any_numbers = any(x => typeof x == "number")
 *     > any_numbers(["a", "b", 1])
 *     true
 *     > any_numbers(["a", "b", "c"])
 *     false
 */
public fun any(op, args...)
{
    var any_f = op instanceof function ?
        fun(source)
        {
            const test = op
            for var elem in source {
                if test(elem) {
                    return true
                }
            }
            return false
        }
        :
        fun(source)
        {
            const val = op
            for var elem in source {
                if elem == val {
                    return true
                }
            }
            return false
        }

    if args.size {
        return any_f(args[0])
    }
    else {
        return any_f
    }
}

/* @item base object.prototype.map()
 *
 *     object.prototype.map(op)
 *
 * A generator which applies a function to each element of the object.
 *
 * Returns an iterator function, which yields values returned from the `op`
 * function called on each subsequent element of the object.  Elements
 * are obtained through the `iterator()` function.
 *
 * Example:
 *
 *     > [1, 3, 5, 7].map(x => x * 2) -> array
 *     [2, 6, 10, 14]
 */
object.prototype.map = fun(transform)
{
    return map(transform, this)
}

/* @item base object.prototype.filter()
 *
 *     object.prototype.filter(op)
 *
 * A generator which filters object elements.
 *
 * Returns an iterator function, which yields elements of the object,
 * for which the `op` function return a truthy value.  The elements are
 * obtained through the `iterator()` function.
 *
 * Example:
 *
 *     > [1, 2, 3, 4, 5, 6].filter(x => x & 1) -> array
 *     [1, 3, 5]
 */
object.prototype.filter = fun(op)
{
    return filter(op, this)
}

/* @item base object.prototype.reduce()
 *
 *     object.prototype.reduce(op, init)
 *
 * Performs left fold operation on subsequent elements of the object,
 * which are obtained through the `iterator()` function.
 *
 * The left fold operation is applied as follows (pseudo-code):
 *
 *     const a = [e1, e2, e3, ...]
 *     const reduce = op(op(op(op(init, e1), e2), e3), ...)
 *
 * `op` is the function which is the reduction operator.
 *
 * `init` is the initial element to use for the fold.
 *
 * Example:
 *
 *     > [1, 3, 7, 4, 6].reduce((x, y) => x + y, 0)
 *     21
 */
object.prototype.reduce = fun(op, init)
{
    return reduce(op, init, this)
}

/* @item base object.prototype.count()
 *
 *     object.prototype.count()
 *     object.prototype.count(op)
 *
 * Counts elements of the object with a predicate.
 *
 * Counts all elements of the object, retrieved through the `iterator()`
 * function, using `op` to test elements.
 *
 * If `op` is not specified, counts all elements retrieved through the
 * `iterator()` function.
 *
 * If `op` is a function, applies it to every element and then counts for
 * how many elements the `op` function returns `true`.
 *
 * If `op` is not a function, counts how many elements equal to `op` by
 * comparing each element to `op` using `==` operator.
 *
 * Examples:
 *
 *     > "monologue".count("o")
 *     3
 *     > range(3, 43, 5).count()
 *     8
 */
object.prototype.count = fun(args...)
{
    if args.size {
        return count(args[0], this)
    }
    else {
        var num = 0
        for const elem in this {
            num += 1
        }
        return num
    }
}

/* @item base object.prototype.all()
 *
 *     object.prototype.all(op)
 *
 * Determines if all elements of the object fulfill a condition.
 *
 * Returns `true` if all elements of the object,
 * retrieved through the `iterator()` function, test positively against
 * the `op` predicate and the test evaluates to a truthy value.
 * Otherwise returns `false`.
 *
 * The function stops iterating over elements as soon as the `op` predicate
 * evaluates to a falsy value.
 *
 * If the `op` predicate is a function, it is invoked for each element
 * passed as an argument and then its return value is used as the result
 * of the test.
 *
 * If `op` is not a function, the test is performed by comparing `op`
 * against each element using the `==` operator.
 *
 * Example:
 *
 *     > [0, 1, 2, 3].all(x => x > 0)
 *     false
 */
object.prototype.all = fun(op)
{
    return all(op, this)
}

/* @item base object.prototype.any()
 *
 *     object.prototype.any(op)
 *
 * Determines if any elements of the object fulfill a condition.
 *
 * Returns `true` if one or more elements of the object,
 * retrieved through the `iterator()` function, test positively against
 * the `op` predicate and the test evaluates to a truthy value.
 * Otherwise returns `false`.
 *
 * The function stops iterating over elements as soon as the `op` predicate
 * evaluates to a truthy value.
 *
 * If the `op` predicate is a function, it is invoked for each element
 * passed as an argument and then its return value is used as the result
 * of the test.
 *
 * If `op` is not a function, the test is performed by comparing `op`
 * against each element using the `==` operator.
 *
 * Example:
 *
 *     > [1, 2, -1, 3, 4].any(x => x < 0)
 *     true
 */
object.prototype.any = fun(op)
{
    return any(op, this)
}

/* @item base method()
 *
 *     method(obj, func)
 *
 * Memorizes an object and a function to be called on that object.
 *
 * Returns a new function, which when called, will call the specified
 * function `func` with the specified object `obj` passed as `this`.
 *
 * `obj` is the object on which the function will be invoked.
 * `func` is a function which is to be applied to the object.
 *
 * Example:
 *
 *     > const my_array = []
 *     > const append = method(my_array, my_array.push)
 *     > append(10)
 *     0
 *     > append(20)
 *     1
 *     > my_array
 *     [10, 20]
 */
public fun method(obj, func)
{
    if typeof func == "string" {
        func = obj[func]
    }
    assert func instanceof function
    return (args...) => func.apply(obj, args)
}

const hex_digits = [ 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
                     0x38, 0x39, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66 ]

/* @item base hex()
 *
 *     hex(number, min_digits = 0)
 *
 * Converts an integer to a string containing hexadecimal representation of it.
 *
 * `min_digits` specifies the minimum number of hexadecimal digits to print.
 *
 * Examples:
 *
 *     > hex(123)
 *     "0x7b"
 *     > hex(123, 4)
 *     "0x007b"
 */
public fun hex(value, min_digits = 0)
{
    assert typeof value == "integer"
    assert typeof min_digits == "integer"
    assert min_digits >= 0 && min_digits <= 16

    const codes  = buffer(18)
    const digits = hex_digits
    var   i      = 17
    const _15    = 15
    const _4     = 4
    const _1     = 1

    repeat {
        codes[i] = digits[value & _15]
        value >>>= _4
        i       -= _1
    } while value

    const target_i = 17 - min_digits

    while i > target_i {
        codes[i] = 0x30
        i -= _1
    }

    codes[i] = 0x78
    i       -= _1
    codes[i] = 0x30

    return string(codes[i:])
}

/* @item base integer.prototype.hex()
 *
 *     integer.prototype.hex(min_digits = 0)
 *
 * Converts the integer to a string containing hexadecimal representation of it.
 *
 * `min_digits` specifies the minimum number of hexadecimal digits to print.
 *
 * Examples:
 *
 *     > 123 .hex()
 *     "0x7b"
 *     > 123 .hex(4)
 *     "0x007b"
 */
integer.prototype.hex = fun(min_digits = 0)
{
    return hex(this, min_digits)
}

/* @item base sort()
 *
 *     sort(key = void, reverse = false)
 *     sort(key, reverse, iterable)
 *     sort(key, iterable)
 *     sort(reverse, iterable)
 *     sort(iterable)
 *
 * Sorts elements from an iterable object.
 *
 * Returns an array with elements extracted from the iterable object and sorted.
 *
 * Uses a stable sorting algorithm, which preserves order of elements for
 * which sorting keys compare as equal.
 *
 * The first variant returns a sort function, which can then be used
 * to sort any iterable object.  The usage of the returned function is
 * the same as the usage of the remaining variants.
 *
 * The remaining variants return an array containing elements extracted
 * from an iterable object and sorted according to the `key` function and
 * `reverse` flag.  Elements are retrieved from the iterable object through
 * its `iterator()` function.
 *
 * `key` is a single-argument function which produces a sorting key for each
 * element of the array.  The array elements are then sorted by the keys using
 * the `<` operator.  By default `key` is `void` and the elements themselves
 * are used as sorting keys.
 *
 * `reverse` defaults to `false`.  If `reverse` is specified as `true`,
 * the elements are sorted in reverse order, i.e. in a descending key
 * order.
 *
 * Examples:
 *
 *     > sort("kos language")
 *     [" ", "a", "a", "e", "g", "g", "k", "l", "n", "o", "s", "u"]
 *     > sort(x => x[0], { foo: 1, bar: 2, baz: 3 })
 *     [["bar", 2], ["baz", 3], ["foo", 1]]
 */
public fun sort(key = void, args...)
{
    var reverse  = false
    var iterable = void

    fun sort(iterable)
    {
        const a = [iterable.iterator()...]
        if a.size {
            a.sort(key, reverse)
        }
        return a
    }

    switch typeof key {

        case "void", "function", "class" {
            if args.size {
                if args.size > 1 {
                    reverse  = args[0]
                    iterable = args[1]
                }
                else {
                    iterable = args[0]
                    if typeof iterable == "boolean" {
                        reverse = iterable
                        return sort
                    }
                }
            }
            else {
                return sort
            }
        }
        case "boolean" {
            reverse = key
            key     = void
            if ! args.size {
                return sort
            }
            iterable = args[0]
        }
        default {
            iterable = key
            key      = void
        }
    }

    return sort(iterable)
}

/* @item base indices()
 *
 *     indices(iterable)
 *
 * A generator which produces subsequent indices of an iterable object.
 *
 * Returns an iterator function, which yields subsequent indices of
 * the iterable object's elements in ascending order.  For array, buffer
 * or string that is integers from `0` to `size - 1`.  For other types,
 * these are indices produced as the generator iterates through them.
 *
 * If another generator is provided as `iterable`, subsequent values are
 * extracted from it and turned into indices, in which case this operation
 * is destructive.
 *
 * For array, buffer or string, `indices(a)` is equivalent to `range(a.size)`,
 * where `a` is that array, buffer or string.
 *
 * Example:
 *
 *     > indices([ "a", "b", "c" ]) -> array
 *     [0, 1, 2]
 *
 *     > indices("foobar") -> array
 *     [0, 1, 2, 3, 4, 5]
 */
public fun indices(iterable)
{
    switch typeof iterable {
        case "array", "buffer", "string" {
            return range(iterable.size)
        }
    }

    fun indices(iterable)
    {
        var   i  = 0
        const _1 = 1
        for const _ in iterable {
            yield i
            i += _1
        }
    }

    return indices(iterable)
}

/* @item base enumerate()
 *
 *     enumerate(iterable)
 *
 * A generator which produces indexed elements of an iterable object.
 *
 * Returns an iterator function, which yields pairs (2-element arrays) containing
 * consecutive indices and elements from the iterable object.
 *
 * Examples:
 *
 *     > enumerate(["kos", "lang", "uage"]) -> array
 *     [[0, "kos"], [1, "lang"], [2, "uage"]]
 *     > enumerate("lang") -> array
 *     [[0, "l"], [1, "a"], [2, "n"], [3, "g"]]
 */
public fun enumerate(iterable)
{
    var   i  = 0
    const _1 = 1
    for var elem in iterable {
        yield [i, elem]
        i += _1
    }
}

/* @item base zip()
 *
 *     zip(iterable0, iterable1...)
 *
 * A generator which produces arrays with elements from each iterable object.
 *
 * Returns an iterator function, which yields arrays.  Each array yielded has
 * one element from each input iterable object.
 *
 * Example:
 *
 *     > zip(range(4), "abcd") -> array
 *     [[0, "a"], [1, "b"], [2, "c"], [3, "d"]]
 */
public fun zip(a, b...)
{
    if b.size == 0 {
        return a
    }

    return fun(a, b) {
        const _1     = 1
        const b_size = b.size
        const size   = _1 + b_size

        const iter = []
        iter.resize(size)
        iter[0] = a.iterator()
        for const i in range(b_size) {
            iter[i + _1] = b[i].iterator()
        }

        loop {
            const out = []
            out.resize(size)

            for const i in range(size) {
                out[i] = iter[i]()
            }

            yield out
        }
    } (a, b)
}

/* @item base print_lines()
 *
 *     print_lines(iterable)
 *
 * Prints all elements from an iterable object on stdout on separate lines.
 *
 * Elements are extracted from `iterable` object through its `iterator()`
 * function, then printed using `base.print()` function.
 *
 * If there are no elements, nothing is printed.
 *
 * Examples:
 *
 *     > print_lines("kos")
 *     k
 *     o
 *     s
 *     > range(3) -> print_lines
 *     0
 *     1
 *     2
 */
public fun print_lines(iterable)
{
    for const elem in iterable {
        print(elem)
    }
}

/* @item base count_elements()
 *
 *     count_elements(iterable)
 *
 * Counts elements of an iterable object.
 *
 * Returns the number of elements retrieved from the iterable object.
 *
 * Elements are extracted from `iterable` object through its `iterator()`
 * function and counted.
 *
 * Examples:
 *
 *     > count_elements([1, 10, 100, 1000])
 *     4
 *     > range(2, 10, 2) -> count_elements
 *     4
 */
public fun count_elements(iterable)
{
    var num_elems = 0
    const _1 = 1
    for const elem in iterable {
        num_elems += _1
    }
    return num_elems
}

/* @item base each()
 *
 *     each(op, iterable)
 *     each(op)
 *     each()
 *
 * Applies a function to every element of an iterable object.
 *
 * The first variant invokes function `op` on every element from the `iterable`
 * object and returns the number of elements encountered.
 *
 * The second and third variant return a function which can be applied to any
 * iterable object.
 *
 * With the third variant, the returned function will simply extract all
 * elements from an iterable object.  This can be useful to cycle through
 * all elements of an iterator.
 *
 * The function returned by the second variant invokes function `op` on every
 * element from the `iterable` object and returns the number of elements
 * encountered.
 *
 * The function returned by the third variant simply iterates over the
 * `iterable` object, but doesn't do anything with the elements.  It also
 * returns the number of elements encountered.
 *
 * Elements are extracted from `iterable` object through its `iterator()`
 * function.
 *
 * A typical use of the `each()` function is at the end of a chain of stream
 * operators `->`.
 *
 * Examples:
 *
 *     > range(0, 21, 10) -> each(print)
 *     0
 *     10
 *     20
 *     3
 *     > "abc" -> map(x => print(x + "_")) -> each()
 *     a_
 *     b_
 *     c_
 *     3
 */
public fun each(args...)
{
    const num_args = args.size
    if num_args > 1 {
        return each(args[0])(args[1])
    }
    else if args.size {
        const op = args[0]
        return fun(iterable) {
            var count = 0
            for const elem in iterable {
                op(elem)
                count += 1
            }
            return count
        }
    }
    else {
        return fun(iterable) {
            var count = 0
            for const elem in iterable {
                count += 1
            }
            return count
        }
    }
}

/* @item base join()
 *
 *     join(sep, iterable)
 *     join(sep)
 *
 * Connects strings together using a separator.
 *
 * The first variant returns a string, which is a concatenation of all elements
 * from the `iterable` object with the `sep` separator inserted in-between the
 * elements.
 *
 * The second variant returns a function, which takes one argument `iterable`
 * and will return a concatenation of all elements with `sep` in-between.
 *
 * `sep` must be a string.
 *
 * `iterable` can return objects of any type accepted by the `string` constructor.
 *
 * Elements are extracted from `iterable` object through its `iterator()`
 * function.
 *
 * Examples:
 *
 *     > join("-", ["kos", "programming", "language"])
 *     "kos-programming-language"
 *     > join(" ", "lang")
 *     "l a n g"
 *     > ["apple", "banana", "orange"] -> join(", ")
 *     "apple, banana, orange"
 *     > range(4) -> join(" ")
 *     "0 1 2 3"
 */
public fun join(sep, args...)
{
    assert typeof sep == "string"
    fun join(to_join)
    {
        if typeof to_join != "array" {
            to_join = [ to_join ... ]
        }

        const num_in = to_join.size
        const num_pieces = num_in * 2 - 1
        const pieces = array(num_pieces > 0 ? num_pieces : 0, sep)
        var dest_i = 0
        for const src_i in range(num_in) {
            pieces[dest_i] = to_join[src_i]
            dest_i += 2
        }

        return string.apply(void, pieces)
    }

    if args.size {
        return join(args[0])
    }
    else {
        return join
    }
}
