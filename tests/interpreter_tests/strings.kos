#
# Copyright (c) 2014-2017 Chris Dragan
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.
#
fun expect_fail(function)
{
    var failed = false
    try {
        function()
    }
    catch const e {
        failed = true
    }
    assert failed
}

do {
    const str = "\0a\x0a\x{0}\x{80}\x{ffFFff}"
}

do {
    const str = "\xff"
    assert λ->("\X{0FF}")() == str
}

do {
    const str = "abc\(123)def"
    assert str == "abc123def"
}

do {
    const a = 10
    const b = 200
    const c = 3000
    const t = true
    const v = void
    const str = "e1:\(a*b+c) e2:\(a+b+c) t:\(t) v:\(v)"
    assert str == "e1:5000 e2:3210 t:true v:void"
}

do {
    const str = "'\(
        1 + 2
        )' '\(
        3 + 4
        )'"
    assert str == "'3' '7'"
}

do {
    const str = "\( "\( "\( "\( 123 )" )" )" )"
    assert str == "123"
}

do {
    const s = ""
    assert s.size == 0
}

do {
    const s = "abcdefgh"
    assert s[0]  == "a"
    assert s[1]  == "b"
    assert s[7]  == "h"
    assert s[-1] == "h"
    assert s[-2] == "g"
    assert s[-8] == "a"
    expect_fail(λ->(s[8]))
    expect_fail(λ->(s[-9]))

    assert s.size == 8

    const b = s.slice(1, 4)
    assert b == "bcd"
    assert b.size == 3

    const e = s.slice(-4, -2)
    assert e == "ef"
    assert e.size == 2

    const a = s.slice(void, 3)
    assert a == "abc"
    assert a.size == 3

    const f = s.slice(-3, void)
    assert f == "fgh"
    assert f.size == 3

    const all = s.slice(-20, 20)
    assert all == s
    assert all.size == 8

    const none = s.slice(20, -20)
    assert none == ""
    assert none.size == 0
}

do {
    const s  = "ABCDEF"
    const _0 = 0
    const _3 = 3

    const a = s[_0:_3]
    assert a  == "ABC"
    assert _0 == 0
    assert _3 == 3

    const b = s[-4:-1]
    assert b == "CDE"

    const c = s[:]
    assert c == "ABCDEF"

    const d = s[:-2.5]
    assert d == "ABC"

    const e = s[4.9:]
    assert e == "EF"

    fun value(idx)
    {
        const v = ["ijklmn", 2, -1]
        return v[idx]
    }

    const f = value(0)[value(1):value(2)]
    assert f == "klm"

    const g = s[-1000000.1:999999.8]
    assert g == "ABCDEF"

    const h = s[77777777.9:-9999999]
    assert h == ""

    assert s[10:20].size == 0
}

do {
    const a = ["m", "n", "o", "p", "q"]
    var   i = 0
    for var c in "mnopq" {
        assert i        <  a.size
        assert typeof c == "string"
        assert c.size   == 1
        assert c        == a[i]
        i += 1
    }
}

do {
    var a = 1
    a = "\(a)"
    assert a == "1"
}

do {
    const a = λ->("ab")()
    const b = "abc\x{100}"
    assert a < b
}

# These look like escape sequences, but they are not.  Used e.g. in regexes.
do {
    const s = "\\(\w\)\'"
    assert s.size == 8
    assert s[0]   == "\\"
    assert s[1]   == "("
    assert s[2]   == "\\"
    assert s[3]   == "w"
    assert s[4]   == "\\"
    assert s[5]   == ")"
    assert s[6]   == "\\"
    assert s[7]   == "'"
}

do {
    const s = "a B"
    assert s.get_char_code(0)     == 0x61
    assert s.get_char_code(1)     == 0x20
    assert s.get_char_code(2)     == 0x42
    assert s.get_char_code(-1)    == 0x42
    expect_fail(λ->(s.get_char_code(3)))
    expect_fail(λ->(s.get_char_code(-4)))
    expect_fail(λ->(s.get_char_code(0x100000000)))
}

do {
    assert "".starts_with("")
    assert "a".starts_with("")
    assert "ab".starts_with("ab")
    assert "ab".starts_with("a")
    assert ! "XAAAAAAAA".starts_with("A")
    assert "XYZ\x{100}".starts_with("XY")
    assert ! "XYZ\x{100}".starts_with("YZ")
    assert "X\x{100}YZ".starts_with("X\x{100}")
    assert ! "Y\x{100}XZ".starts_with("X\x{100}")
    assert "XYZ\x{10000}".starts_with("XY")
    assert ! "XYZ\x{10000}".starts_with("YZ")
    assert "X\x{200}Z\x{10000}".starts_with("X\x{200}")
    assert ! "X\x{200}Z\x{10000}".starts_with("\x{200}Z")
    assert "X\x{10000}YZ".starts_with("X\x{10000}")
    assert ! "Y\x{10000}XZ".starts_with("X\x{10000}")

    expect_fail(λ->("".starts_with.apply(void, [""])))
    expect_fail(λ->("".starts_with(void)))
    expect_fail(λ->("".starts_with()))
}

do {
    assert "".ends_with("")
    assert "a".ends_with("")
    assert "ab".ends_with("ab")
    assert "ab".ends_with("b")
    assert ! "ab".ends_with("a")
    assert ! "ab".ends_with("ba")

    expect_fail(λ->("".ends_with.apply(void, [""])))
    expect_fail(λ->("".ends_with(void)))
    expect_fail(λ->("".ends_with()))
}

do {
    assert "".find("")         == 0
    assert "ab".find("")       == 0
    assert "cd".find("", 1)    == 1
    assert "efg".find("e")     == 0
    assert "efg".find("f")     == 1
    assert "efg".find("h")     == -1
    assert "ABB".find("B", -2) == 1
    assert "ABB".find("B", -1) == 2
    assert "ABB".find("B", 2)  == 2
    assert "h".find("", 10)    == 1
    assert "h".find("", -10)   == 0
    assert "h".find("j", 10)   == -1
    assert "h".find("j", -10)  == -1

    assert "abXYcdXXYefXYYgh".find("XY")      == 2
    assert "abXYcdXXYefXYYgh".find("XY", -99) == 2
    assert "abXYcdXXYefXYYgh".find("XY", 2)   == 2
    assert "abXYcdXXYefXYYgh".find("XY", 3)   == 7
    assert "abXYcdXXYefXYYgh".find("XY", 7)   == 7
    assert "abXYcdXXYefXYYgh".find("XY", 8)   == 11
    assert "abXYcdXXYefXYYgh".find("XY", 11)  == 11
    assert "abXYcdXXYefXYYgh".find("XY", 12)  == -1

    assert "alamalamamalalamakotaipsa".find("alamakota") == 12
    assert "alamalamamalalamakota".find("alamakota")     == 12
    assert "alamalamamalalamakot".find("alamakota")      == -1

    expect_fail(λ->("".find.apply(void, [""])))
    expect_fail(λ->("".find()))
    expect_fail(λ->("".find(void)))
}

do {
    # LE: 01 02 03 00 00 00 00 00 02 03 00 00
    const haystack = "\x{30201}\0\x{302}"
    # LE: 02 03 00 00
    const needle   = "\x{302}\x{10000}"[0] # force 32-bit elem_size
    assert haystack.size             == 3
    assert haystack.get_char_code(0) == 0x30201
    assert haystack.get_char_code(1) == 0
    assert haystack.get_char_code(2) == 0x302
    assert needle.size               == 1
    assert needle.get_char_code(0)   == 0x302
    assert haystack.find(needle)     == 2
    assert haystack.find(needle, 0)  == 2
    assert haystack.find(needle, 1)  == 2
}

do {
    assert "".rfind("")         == 0
    assert "ab".rfind("")       == 2
    assert "ab".rfind("", 1)    == 1
    assert "ab".rfind("", 10)   == 2
    assert "ab".rfind("", -10)  == -1
    assert "ab".rfind("x", 10)  == -1
    assert "ab".rfind("x", -10) == -1
    assert "ab".rfind("a", -10) == -1

    assert "abXYcdXXYefXYYgh".rfind("XY")      == 11
    assert "abXYcdXXYefXYYgh".rfind("XY", 99)  == 11
    assert "abXYcdXXYefXYYgh".rfind("XY", 11)  == 11
    assert "abXYcdXXYefXYYgh".rfind("XY", 10)  == 7
    assert "abXYcdXXYefXYYgh".rfind("XY", 7)   == 7
    assert "abXYcdXXYefXYYgh".rfind("XY", 6)   == 2
    assert "abXYcdXXYefXYYgh".rfind("XY", 2)   == 2
    assert "abXYcdXXYefXYYgh".rfind("XY", 1)   == -1
    assert "abXYcdXXYefXYYgh".rfind("XY", -1)  == 11
    assert "abXYcdXXYefXYYgh".rfind("XY", -10) == 2
    assert "abXYcdXXYefXYYgh".rfind("XY", -20) == -1

    expect_fail(λ->("".rfind.apply(void, [""])))
    expect_fail(λ->("".rfind()))
    expect_fail(λ->("".rfind(void)))
}

do {
    assert "alamakota".scan("a") == 0
    const scans = [ [-99,  0],
                    [-10,  0],
                    [-9,   0],
                    [-8,   2],
                    [-7,   2],
                    [-6,   4],
                    [-2,   8],
                    [-1,   8],
                    [0,    0],
                    [1,    2],
                    [2,    2],
                    [3,    4],
                    [7,    8],
                    [8,    8],
                    [9,   -1],
                    [100, -1] ]
    for var idx, result in scans {
        const actual = "alamakota".scan("a", idx)
        if actual != result {
            throw "scan failed at index \(idx), expected result \(result), actual \(actual)"
        }
    }
}

do {
    assert "alamakota".rscan("a")  == 8
    assert "abc".rscan("efghijkb") == 1
    assert "\x00a\x00"[1].scan("a") == 0
    assert "\x00a\x00"[1].scan("\x00") == -1
    assert "\x00a\x00"[1].rscan("\x00") == -1
    const scans = [ [-99, -1],
                    [-10, -1],
                    [-9,   0],
                    [-8,   0],
                    [-7,   2],
                    [-6,   2],
                    [-2,   4],
                    [-1,   8],
                    [0,    0],
                    [1,    0],
                    [2,    2],
                    [3,    2],
                    [7,    4],
                    [8,    8],
                    [9,    8],
                    [100,  8] ]
    for var idx, result in scans {
        const actual = "alamakota".rscan("a", idx)
        if actual != result {
            throw "rscan failed at index \(idx), expected result \(result), actual \(actual)"
        }
    }
}

do {
    const scans = [ [-7, 0],
                    [-6, 0],
                    [-4, 2],
                    [-1, 5],
                    [0,  0],
                    [1,  2],
                    [2,  2],
                    [3,  5],
                    [4,  5],
                    [5,  5],
                    [6, -1] ]
    for var idx, result in scans {
        const actual = "a#bXCc".scan("abcdefg", idx)
        if actual != result {
            throw "scan failed at index \(idx), expected result \(result), actual \(actual)"
        }
    }
}

do {
    const scans = [ [-7, -1],
                    [-6,  0],
                    [-5,  0],
                    [-4,  2],
                    [-1,  5],
                    [0,   0],
                    [1,   0],
                    [2,   2],
                    [3,   2],
                    [4,   2],
                    [5,   5],
                    [6,   5] ]
    for var idx, result in scans {
        const actual = "a#bXCc".rscan("abcdefg", idx)
        if actual != result {
            throw "rscan failed at index \(idx), expected result \(result), actual \(actual)"
        }
    }
}

do {
    assert "\x01\x01\x01\x01\x{100}\x01".scan("\x{100}\x{100}\x{100}") == 4
    assert "\x01\x01\x01\x01\x{100}\x01".rscan("\x{100}\x{100}\x{100}") == 4
    assert "\x{100}\x{100}\x{100}\x01\x{100}".scan("\x01\x01\x01") == 3
    assert "\x{100}\x{100}\x{100}\x01\x{100}".rscan("\x01\x01\x01") == 3
    assert "\x{101}\x{101}\x{101}\x01\x{101}".scan("\x01\x01\x01") == 3
    assert "\x{101}\x{101}\x{101}\x01\x{101}".rscan("\x01\x01\x01") == 3
}

do {
    assert "".reverse() == ""
    assert "1".reverse() == "1"
    assert "12".reverse() == "21"
    assert "ABC".reverse() == "CBA"
    assert "0123456789".reverse() == "9876543210"
    assert "\x{FFFF}\0".reverse() == "\0\x{FFFF}"
    assert "\x{10000}a\0".reverse() == "\0a\x{10000}"
}
