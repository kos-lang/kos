#
# Copyright (c) 2014-2017 Chris Dragan
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.
#

import lang
import lang.void # For lang.void test, see way below

fun expect_fail(function)
{
    var failed = false
    try {
        function()
    }
    catch const e {
        failed = true
    }
    assert failed
}

##############################################################################
# lang.number

do {
    assert typeof lang.number           == "function"
    assert typeof lang.number.prototype == "object"
}

do {
    const number = lang.number()
    assert typeof number == "integer"
    assert number        == 0
}

do {
    const number = lang.number(101)
    assert typeof number == "integer"
    assert number        == 101
}

do {
    const number = lang.number(10.1)
    assert typeof number == "float"
    assert number        == 10.1
}

do {
    expect_fail(λ->((1).times_three()))
    expect_fail(λ->((1.5).times_three()))

    lang.number.prototype.times_three = λ->(this*3)

    const i = (5).times_three()
    assert typeof i == "integer"
    assert i        == 15

    const f = (5.0).times_three()
    assert typeof f == "float"
    assert f        == 15
}

do {
    expect_fail(λ->(lang.number("")))
    expect_fail(λ->(lang.number("a")))
    expect_fail(λ->(lang.number("e")))
    expect_fail(λ->(lang.number("123x")))
    expect_fail(λ->(lang.number("-")))
    expect_fail(λ->(lang.number("--")))
    expect_fail(λ->(lang.number("-E")))
    expect_fail(λ->(lang.number({})))
    expect_fail(λ->(lang.number([])))
    expect_fail(λ->(lang.number(λ->(void))))
    expect_fail(λ->(lang.number(false)))
    expect_fail(λ->(lang.number(void)))

    const _1 = lang.number("1")
    assert typeof _1 == "integer"
    assert _1        == 1

    const _2 = lang.number("0x002")
    assert typeof _2 == "integer"
    assert _2        == 2

    const _3 = lang.number("3.")
    assert typeof _3 == "float"
    assert _3        == 3

    const _0 = lang.number(".")
    assert typeof _0 == "float"
    assert _0        == 0

    const _m0 = lang.number("-.")
    assert typeof _m0 == "float"
    assert _m0        == 0

    const _0_5 = lang.number(".5")
    assert typeof _0_5 == "float"
    assert _0_5        == 0.5
}

do {
    const number = "number"
    const value  = lang[number](5)
    assert value        == 5
    assert typeof value == "integer"
}

##############################################################################
# lang.integer

do {
    assert typeof lang.integer           == "function"
    assert typeof lang.integer.prototype == "object"
}

do {
    const number = lang.integer()
    assert typeof number == "integer"
    assert number        == 0
}

do {
    const number = lang.integer(10)
    assert typeof number == "integer"
    assert number        == 10
}

do {
    const number = lang.integer(2.9)
    assert typeof number == "integer"
    assert number        == 2
}

do {
    assert lang.integer(2.1)  == 2
    assert lang.integer(1.9)  == 1
    assert lang.integer(-0.9) == -1
    assert lang.integer(-1.1) == -2
    assert lang.integer(-1.9) == -2
}

do {
    expect_fail(λ->((3).square()))

    lang.integer.prototype.square = λ->(this * this)

    assert (3).square() == 9

    expect_fail(λ->((3.0).square()))
}

do {
    assert lang.integer()     == 0
    assert lang.integer(-5)   == -5
    assert lang.integer(8.25) == 8
}

do {
    assert 0 instanceof lang.integer
    assert 1 instanceof lang.integer
    assert 0x7FFFFFFFFFFFFFFF instanceof lang.integer
    assert ! (0.0 instanceof lang.integer)
    assert ! (0 instanceof 0)
}

do {
    const value = λ->(42)()
    assert value instanceof lang.integer
    assert value instanceof lang.number
    assert value instanceof lang.object
    assert ! (value instanceof lang.float)
    assert ! (value instanceof lang.string)
    assert ! (value instanceof lang.boolean)
    assert ! (value instanceof lang.void)
}

do {
    expect_fail(λ->(lang.integer("")))
    expect_fail(λ->(lang.integer("a")))
    expect_fail(λ->(lang.integer("e")))
    expect_fail(λ->(lang.integer("123x")))
    expect_fail(λ->(lang.integer("-")))
    expect_fail(λ->(lang.integer("--")))
    expect_fail(λ->(lang.integer("-E")))
    expect_fail(λ->(lang.integer("3.")))
    expect_fail(λ->(lang.integer(".")))
    expect_fail(λ->(lang.integer("-.")))
    expect_fail(λ->(lang.integer(".5")))
    expect_fail(λ->(lang.integer({})))
    expect_fail(λ->(lang.integer([])))
    expect_fail(λ->(lang.integer(λ->(void))))
    expect_fail(λ->(lang.integer(false)))
    expect_fail(λ->(lang.integer(void)))

    const _1 = lang.integer("1")
    assert typeof _1 == "integer"
    assert _1        == 1

    const _2 = lang.integer("0x002")
    assert typeof _2 == "integer"
    assert _2        == 2
}

##############################################################################
# lang.integer.prototype.hex

do {
    assert 0 .hex()   == "0x0"
    assert 1 .hex()   == "0x1"
    assert 18 .hex()  == "0x12"
    assert (-1).hex() == "0xffffffffffffffff"
    assert 0x7fffffffffffffff .hex() == "0x7fffffffffffffff"

    expect_fail(λ->(1.2.hex()))
}

##############################################################################
# lang.float

do {
    assert typeof lang.float           == "function"
    assert typeof lang.float.prototype == "object"
}

do {
    const number = lang.float()
    assert typeof number == "float"
    assert number        == 0
}

do {
    const number = lang.float(10)
    assert typeof number == "float"
    assert number        == 10
}

do {
    const number = lang.float(2.9)
    assert typeof number == "float"
    assert number        == 2.9
}

do {
    const number = lang.float(4611686018427387904)
    assert typeof number == "float"
    assert number        == 4611686018427387904
}

do {
    expect_fail(λ->((3.0).square3()))

    lang.float.prototype.square3 = λ->(this * this * this)

    assert (3.0).square3() == 27

    expect_fail(λ->((3).square3()))
}

do {
    assert lang.float()     == 0
    assert lang.float(3)    == 3
    assert lang.float(-4.5) == -4.5
}

do {
    assert 0.0 instanceof lang.float
    assert 0.5 instanceof lang.float
    assert ! (0 instanceof lang.float)
}

do {
    const value = λ->(42.0)()
    assert value instanceof lang.float
    assert value instanceof lang.number
    assert value instanceof lang.object
    assert ! (value instanceof lang.integer)
    assert ! (value instanceof lang.string)
    assert ! (value instanceof lang.boolean)
    assert ! (value instanceof lang.void)
}

do {
    expect_fail(λ->(lang.float("")))
    expect_fail(λ->(lang.float("a")))
    expect_fail(λ->(lang.float("e")))
    expect_fail(λ->(lang.float("123x")))
    expect_fail(λ->(lang.float("-")))
    expect_fail(λ->(lang.float("--")))
    expect_fail(λ->(lang.float("-E")))
    expect_fail(λ->(lang.float("0x002")))
    expect_fail(λ->(lang.float({})))
    expect_fail(λ->(lang.float([])))
    expect_fail(λ->(lang.float(λ->(void))))
    expect_fail(λ->(lang.float(false)))
    expect_fail(λ->(lang.float(void)))

    const _1 = lang.float("1")
    assert typeof _1 == "float"
    assert _1        == 1

    const _3 = lang.float("3.")
    assert typeof _3 == "float"
    assert _3        == 3

    const _0 = lang.float(".")
    assert typeof _0 == "float"
    assert _0        == 0

    const _m0 = lang.float("-.")
    assert typeof _m0 == "float"
    assert _m0        == 0

    const _0_5 = lang.float(".5")
    assert typeof _0_5 == "float"
    assert _0_5        == 0.5
}

##############################################################################
# lang.void

do {
    assert typeof lang.void           == "function"
    assert typeof lang.void.prototype == "object"
}

do {
    const v = lang.void()
    assert v == void
}

do {
    expect_fail(λ->(void.bool()))
    lang.void.prototype.bool = λ->(false)
    assert void.bool() == false
}

do {
    assert void instanceof lang.void
    assert ! (true  instanceof lang.void)
    assert ! (false instanceof lang.void)
}

do {
    const value = λ->(void)()
    assert value instanceof lang.void
    assert value instanceof lang.object
    assert ! (value instanceof lang.integer)
    assert ! (value instanceof lang.float)
    assert ! (value instanceof lang.number)
    assert ! (value instanceof lang.string)
    assert ! (value instanceof lang.boolean)
}

# Even though lang.void was imported directly (at the top), it's not accessible
do {
    expect_fail(λ->(void()))
    assert typeof void == "void"
}

##############################################################################
# lang.boolean

do {
    assert typeof lang.boolean           == "function"
    assert typeof lang.boolean.prototype == "object"
}

do {
    assert lang.boolean(true)
    assert ! lang.boolean(false)
    assert lang.boolean(3 + 4)
    assert ! lang.boolean(5 - 5)
}

do {
    expect_fail(λ->(false.negative()))
    lang.boolean.prototype.negative = λ->(!this)
    assert false.negative()
    assert ! true.negative()
}

do {
    assert true  instanceof lang.boolean
    assert false instanceof lang.boolean
    assert ! (void instanceof lang.boolean)

    const a = 10
    const b = 2 * 5
    assert (a == b) instanceof lang.boolean
}

do {
    const value = λ->(false)()
    assert value instanceof lang.boolean
    assert value instanceof lang.object
    assert ! (value instanceof lang.integer)
    assert ! (value instanceof lang.float)
    assert ! (value instanceof lang.number)
    assert ! (value instanceof lang.string)
    assert ! (value instanceof lang.void)
}

##############################################################################
# lang.string

do {
    assert typeof lang.string           == "function"
    assert typeof lang.string.prototype == "object"
}

do {
    assert lang.string()             == ""
    assert lang.string(123)          == "123"
    assert lang.string("x", 5, "z")  == "x5z"
    assert lang.string()             == ""
    assert lang.string(8)            == "8"
    assert lang.string([], [])       == ""
    assert lang.string([0x30, 0x41]) == "0A"
    assert lang.string([0x100, 2])   == "\x{100}\x02"

    expect_fail(λ->(lang.string([void])))
    expect_fail(λ->(lang.string({})))
    expect_fail(λ->(lang.string(void)))
    expect_fail(λ->(lang.string(false)))
    expect_fail(λ->(lang.string(λ->(void))))
    expect_fail(λ->(lang.string([0x200000])))
    expect_fail(λ->(lang.string([-1])))
}

do {
    const elements = [0x1FFFFF, 1, 2, 3, 4, 5]
    const s        = lang.string(elements)
    assert typeof s == "string"
    assert s.size   == elements.size
    for var i in lang.range(s.size) {
        assert s.ord(i) == elements[i]
    }
}

do {
    const elements = [0x1FFFFF, 1, 2, 3, 4, 5, 6]
    const s        = lang.string(elements)
    assert typeof s == "string"
    assert s.size   == elements.size
    for var i in lang.range(s.size) {
        assert s.ord(i) == elements[i]
    }
}

do {
    expect_fail(λ->("x".add_2("y")))
    lang.string.prototype.add_2 = λ(x)->(this + x)
    assert "x".add_2("y") == "xy"
}

do {
    const str = "123"
    assert str instanceof lang.string
    assert str == "123"

    assert "x\(1)y" instanceof lang.string
}

do {
    const value = λ->("abc")()
    assert value instanceof lang.string
    assert value instanceof lang.object
    assert ! (value instanceof lang.integer)
    assert ! (value instanceof lang.float)
    assert ! (value instanceof lang.number)
    assert ! (value instanceof lang.boolean)
    assert ! (value instanceof lang.void)
}

do {
    constructor ctor
    {
    }

    ctor.set_prototype(lang.string.prototype)

    const o = ctor()

    expect_fail(λ->(o.size))
}

##############################################################################
# lang.object

do {
    assert typeof lang.object           == "function"
    assert typeof lang.object.prototype == "object"
}

do {
    const o = lang.object()
    assert typeof o == "object"

    o.prop1 = "xyz"
    assert o.prop1 == "xyz"
}

do {
    const o = lang.object()
    assert typeof o == "object"

    o.prop2 = "xyz"
    assert o.prop2 == "xyz"
}

do {
    assert {} instanceof lang.object
    assert ! ({} instanceof lang.array)
    assert ! ({} instanceof lang.function)
    assert ! ({} instanceof lang.string)

    const o = lang.object()
    assert o instanceof lang.object
}

do {
    const value = λ->({})()
    assert value instanceof lang.object
    assert ! (value instanceof lang.integer)
    assert ! (value instanceof lang.float)
    assert ! (value instanceof lang.number)
    assert ! (value instanceof lang.boolean)
    assert ! (value instanceof lang.void)
    assert ! (value instanceof lang.string)
    assert ! (value instanceof lang.array)
}

do {
    constructor constr
    {
        this.c = 2
        this.d = 3
        this.e = 4
    }

    constr.prototype.a = 0
    constr.prototype.b = 1

    const obj = constr()

    var values = ["a", "b", "c", "d", "e"]

    for const key, value in lang.deep(obj) {
        assert value == obj[key]
        if typeof value == "integer" && value >= 0 && value < values.size {
            assert values[value] == key
            values[value] = void
        }
    }

    for var i = 0; i < values.size; i += 1 {
        assert values[i] == void
    }

    values = ["a", "b", "c", "d", "e"]

    for const key, value in lang.shallow(obj) {
        assert typeof value == "integer"
        assert value == obj[key]
        assert value >= 0 && value < values.size
        assert values[value] == key
        values[value] = void
    }
}

do {
    const it = lang.shallow.apply({aaa:0}, [void])
    assert typeof it == "function"
    for const x, v in it {
        assert x == "aaa"
    }

    for const x, v in lang.shallow.apply(void, [void]) {
        throw "unexpected property"
    }
}

##############################################################################
# lang.array

do {
    assert typeof lang.array           == "function"
    assert typeof lang.array.prototype == "object"
}

do {
    const a = lang.array()
    assert typeof a == "array"
    assert a.size   == 0
}

do {
    const a = lang.array(1)
    assert a.size == 1
    assert a[0]   == void
}

do {
    expect_fail(λ->(lang.array(-1)))
}

do {
    const a = lang.array([8])
    assert typeof a == "array"
    assert a.size   == 1
    assert a[0]     == 8
    expect_fail(λ->(a[1]))
}

do {
    const a = lang.array("xy", [true])
    assert typeof a == "array"
    assert a.size   == 3
    assert a[0]     == "x"
    assert a[1]     == "y"
    assert a[2]     == true
    expect_fail(λ->(a[3]))
}

do {
    const a = lang.array(2.1)
    assert a.size == 2
    assert a[0]   == void
    assert a[1]   == void
}

do {
    expect_fail(λ->(lang.array(1, [])))
    expect_fail(λ->(lang.array([], 1.0)))
    expect_fail(λ->(lang.array(λ->(void))))
}

do {
    const a = lang.array(lang.range(4))
    assert typeof a == "array"
    assert a.size   == 4
    for var i = 0; i < 4; i += 1 {
        assert a[i] == i
    }
}

do {
    const a = lang.array(lang.shallow({a: void, b: void, c: void}))
    assert typeof a == "array"
    assert a.size   == 3
    const had = { "a": false, "b": false, "c": false }
    for var i = 0; i < a.size; i += 1 {
        const key, value = a[i]
        assert key == "a" || key == "b" || key == "c"
        assert ! had[key]
        had[key] = true
    }
}

do {
    expect_fail(fun {
        lang.array.set_prototype({})
    })
}

do {
    const a = [ "a", "b", "c", "d", "e" ]

    expect_fail(λ->(a.ret_elem_3()))

    lang.array.prototype.ret_elem_3 = fun {
        return this[3]
    }

    assert a.ret_elem_3() == "d"
}

do {
    const a = lang.array([10, 20], [30])
    assert a.size == 3
    assert a[0]     == 10
    assert a[1]     == 20
    assert a[2]     == 30
    expect_fail(λ->(a[3]))
}

do {
    assert [] instanceof lang.array
    assert [] instanceof lang.object
}

do {
    const value = λ->([])()
    assert value instanceof lang.array
    assert value instanceof lang.object
    assert ! (value instanceof lang.integer)
    assert ! (value instanceof lang.float)
    assert ! (value instanceof lang.number)
    assert ! (value instanceof lang.boolean)
    assert ! (value instanceof lang.void)
    assert ! (value instanceof lang.string)
}

do {
    const a = [1, 2, 100]
    const b = lang.array(a)
    assert typeof b == "array"
    assert b        != a
    assert b.size   == a.size
    for var i = 0; i < b.size; i += 1 {
        assert b[i] == a[i]
    }
}

do {
    constructor fake_array
    {
    }

    fake_array.set_prototype(lang.array.prototype)

    const o = fake_array()

    assert typeof o == "object"
    assert o instanceof lang.array
    expect_fail(λ->(o.size))
    assert typeof o.resize == "function"
    expect_fail(λ->(o.resize(10)))
    expect_fail(λ->(o[0]))
}

do {
    const buf = lang.buffer(10)
    for var i in lang.range(buf.size) {
        buf[i] = i + 20
    }

    const a = lang.array(buf)

    assert a.size == 10

    var count = 0
    for var elem in a {
        assert elem == count + 20
        count += 1
    }
    assert count == 10
}

do {
    const a = lang.array(lang.buffer())

    assert typeof a == "array"
    assert a.size   == 0
}

do {
    expect_fail(fun { [].reserve(-1) })
    expect_fail(fun { lang.array.prototype.reserve(void, [0]) })

    const a = []
    a.reserve(100)
    assert a.size == 0
}

do {
    expect_fail(fun { lang.array.prototype.push(0) })
    expect_fail(fun { lang.array.prototype.pop() })
    expect_fail(fun { [].push.apply("", ["a"]) })
    expect_fail(fun { [].pop.apply("a", []) })

    const a = []
    assert a.push(1)       == 0
    assert a.push(2, 3, 4) == 1
    assert a.push(5)       == 4
    assert a.push(6)       == 5
    expect_fail(λ->(a.push()))

    assert a.size == 6
    assert a[0]   == 1
    assert a[1]   == 2
    assert a[2]   == 3
    assert a[3]   == 4
    assert a[4]   == 5
    assert a[5]   == 6

    assert a.pop() == 6
    assert a.size  == 5
    assert a[0]    == 1
    assert a[4]    == 5

    const b = a.pop(3)
    assert typeof b == "array"
    assert b.size   == 3
    assert b[0]     == 3
    assert b[1]     == 4
    assert b[2]     == 5
    assert a.size   == 2
    assert a[0]     == 1
    assert a[1]     == 2

    const c = a.pop(0)
    assert typeof c == "array"
    assert c.size   == 0
    assert a.size   == 2

    expect_fail(λ->(a.pop(3)))
    assert a.size == 0

    assert [1, 2].pop() == 2

    expect_fail(λ->([].pop()))
    expect_fail(λ->([1].pop(2)))
    expect_fail(λ->([1].pop(-1)))
}

##############################################################################
# lang.array.prototype.slice

do {
    const a = []
    const b = a.slice(10, -20)

    assert typeof b == "array"
    assert b.size == 0
}

do {
    const a = [1, 2, 3, 4]
    const b = a.slice(1, -1)

    assert typeof b == "array"
    assert b.size == 2
    assert b[0] == 2
    assert b[1] == 3
}

do {
    const a = ["a", "b", "c", "d", "e"]

    do {
        const b = a.slice(void, void)
        assert b.size == 5
        assert b[0] == "a"
        assert b[-1] == "e"
    }

    do {
        const b = a.slice(2, void)
        assert b.size == 3
        assert b[0] == "c"
        assert b[-1] == "e"
    }

    do {
        const b = a.slice(void, -3)
        assert b.size == 2
        assert b[0] == "a"
        assert b[1] == "b"
    }

    do {
        expect_fail(λ->([].slice(0, false)))
        expect_fail(λ->([].slice(false, 0)))
    }
}

##############################################################################
# lang.array.prototype.insert_array

do {
    const a = [1, 2, 3, 4]
    const b = ["x", "y"]
    const c = a.insert_array(2, b)

    assert a == c
    assert a.size == 6
    assert a[0] == 1
    assert a[1] == 2
    assert a[2] == "x"
    assert a[3] == "y"
    assert a[4] == 3
    assert a[5] == 4
}

do {
    const a = [1, 2]
    const c = a.insert_array(0, a)

    assert a == c
    assert a.size == 4
    assert a[0] == 1
    assert a[1] == 2
    assert a[2] == 1
    assert a[3] == 2
}

do {
    const a = [1, 2]
    const c = a.insert_array(void, a)

    assert a == c
    assert a.size == 4
    assert a[0] == 1
    assert a[1] == 2
    assert a[2] == 1
    assert a[3] == 2
}

do {
    fun test_case(test)
    {
        test.args[-1] = test.args[-1] || test.array
        const out = [].insert_array.apply(test.array, test.args)
        assert out      == test.array
        assert out.size == test.result.size
        for var i in lang.range(out.size) {
            assert out[i] == test.result[i]
        }
    }

    test_case({ array: [ 1, 2, 3 ], args: [   -4,       []           ], result: [ 1, 2, 3 ]           })
    test_case({ array: [ 1, 2, 3 ], args: [   -3,       []           ], result: [ 1, 2, 3 ]           })
    test_case({ array: [ 1, 2, 3 ], args: [    0,       []           ], result: [ 1, 2, 3 ]           })
    test_case({ array: [ 1, 2, 3 ], args: [    1,       []           ], result: [ 1, 2, 3 ]           })
    test_case({ array: [ 1, 2, 3 ], args: [   -2,       []           ], result: [ 1, 2, 3 ]           })
    test_case({ array: [ 1, 2, 3 ], args: [ void,       []           ], result: [ 1, 2, 3 ]           })
    test_case({ array: [ 1, 2, 3 ], args: [    4,       []           ], result: [ 1, 2, 3 ]           })
    test_case({ array: [ 1, 2, 3 ], args: [ void,    1, []           ], result: [ 2, 3 ]              })
    test_case({ array: [ 1, 2, 3 ], args: [    1,    2, []           ], result: [ 1, 3 ]              })
    test_case({ array: [ 1, 2, 3 ], args: [   -1, void, []           ], result: [ 1, 2 ]              })
    test_case({ array: [ 1, 2, 3 ], args: [ void, void, []           ], result: [ ]                   })
    test_case({ array: [ 1, 2, 3 ], args: [   -4,       [ "x" ]      ], result: [ "x", 1, 2, 3 ]      })
    test_case({ array: [ 1, 2, 3 ], args: [   -3,       [ "x" ]      ], result: [ "x", 1, 2, 3 ]      })
    test_case({ array: [ 1, 2, 3 ], args: [    0,       [ "x" ]      ], result: [ "x", 1, 2, 3 ]      })
    test_case({ array: [ 1, 2, 3 ], args: [    1,       [ "x" ]      ], result: [ 1, "x", 2, 3 ]      })
    test_case({ array: [ 1, 2, 3 ], args: [   -1,       [ "x" ]      ], result: [ 1, 2, "x", 3 ]      })
    test_case({ array: [ 1, 2, 3 ], args: [ void,       [ "x" ]      ], result: [ 1, 2, 3, "x" ]      })
    test_case({ array: [ 1, 2, 3 ], args: [    4,       [ "x" ]      ], result: [ 1, 2, 3, "x" ]      })
    test_case({ array: [ 1, 2, 3 ], args: [   -4,    1, [ "x" ]      ], result: [ "x", 2, 3 ]         })
    test_case({ array: [ 1, 2, 3 ], args: [ void,    1, [ "x" ]      ], result: [ "x", 2, 3 ]         })
    test_case({ array: [ 1, 2, 3 ], args: [   -2,    2, [ "x" ]      ], result: [ 1, "x", 3 ]         })
    test_case({ array: [ 1, 2, 3 ], args: [   -1, void, [ "x" ]      ], result: [ 1, 2, "x" ]         })
    test_case({ array: [ 1, 2, 3 ], args: [ void,    2, [ "x" ]      ], result: [ "x", 3 ]            })
    test_case({ array: [ 1, 2, 3 ], args: [    1, void, [ "x" ]      ], result: [ 1, "x" ]            })
    test_case({ array: [ 1, 2, 3 ], args: [ void, void, [ "x" ]      ], result: [ "x" ]               })
    test_case({ array: [ 1, 2, 3 ], args: [ void,    0, [ "x", "y" ] ], result: [ "x", "y", 1, 2, 3 ] })
    test_case({ array: [ 1, 2, 3 ], args: [ void,    1, [ "x", "y" ] ], result: [ "x", "y", 2, 3 ]    })
    test_case({ array: [ 1, 2, 3 ], args: [   -2,    2, [ "x", "y" ] ], result: [ 1, "x", "y", 3 ]    })
    test_case({ array: [ 1, 2, 3 ], args: [   -1, void, [ "x", "y" ] ], result: [ 1, 2, "x", "y" ]    })
    test_case({ array: [ 1, 2, 3 ], args: [   -1, void, [ "x", "y" ] ], result: [ 1, 2, "x", "y" ]    })
    test_case({ array: [ 1, 2, 3 ], args: [ void,    2, [ "x", "y" ] ], result: [ "x", "y", 3 ]       })
    test_case({ array: [ 1, 2, 3 ], args: [   -2, void, [ "x", "y" ] ], result: [ 1, "x", "y" ]       })
    test_case({ array: [ 1, 2, 3 ], args: [ void, void, [ "x", "y" ] ], result: [ "x", "y" ]          })
    test_case({ array: [ 1, 2, 3 ], args: [    0,       void         ], result: [ 1, 2, 3, 1, 2, 3 ]  })
    test_case({ array: [ 1, 2, 3 ], args: [    1,       void         ], result: [ 1, 1, 2, 3, 2, 3 ]  })
    test_case({ array: [ 1, 2, 3 ], args: [    2,       void         ], result: [ 1, 2, 1, 2, 3, 3 ]  })
    test_case({ array: [ 1, 2, 3 ], args: [ void,       void         ], result: [ 1, 2, 3, 1, 2, 3 ]  })
    test_case({ array: [ 1, 2, 3 ], args: [ void,    1, void         ], result: [ 1, 2, 3, 2, 3 ]     })
    test_case({ array: [ 1, 2, 3 ], args: [    1,    2, void         ], result: [ 1, 1, 2, 3, 3 ]     })
    test_case({ array: [ 1, 2, 3 ], args: [    2, void, void         ], result: [ 1, 2, 1, 2, 3 ]     })
    test_case({ array: [ 1, 2, 3 ], args: [ void,    2, void         ], result: [ 1, 2, 3, 3 ]        })
    test_case({ array: [ 1, 2, 3 ], args: [    1, void, void         ], result: [ 1, 1, 2, 3 ]        })
    test_case({ array: [ 1, 2, 3 ], args: [ void, void, void         ], result: [ 1, 2, 3 ]           })
}

do {
    expect_fail(λ->([].insert_array(0, 1, {})))
    expect_fail(λ->([].insert_array("", 0, [])))
    expect_fail(λ->([].insert_array(0, "", [])))
}

##############################################################################
# lang.array.prototype.insert

do {
    const a = []

    a.insert(0, "abc")
    assert a.size == 3
    assert a[0]   == "a"
    assert a[2]   == "c"

    a.insert(void, lang.buffer())
    assert a.size == 3
    assert a[0]   == "a"
    assert a[2]   == "c"

    const buf = lang.buffer(4)
    for var i in lang.range(buf.size) {
        buf[i] = buf.size - i
    }

    a.insert(void, buf)
    assert a.size == 7
    assert a[2]   == "c"
    assert a[3]   == 4
    assert a[6]   == 1

    for var i in lang.range(buf.size) {
        buf[i] = 10 + i
    }

    a[1:-1] = buf
    assert a.size == 6
    assert a[0]   == "a"
    assert a[1]   == 10
    assert a[2]   == 11
    assert a[3]   == 12
    assert a[4]   == 13
    assert a[5]   == 1
}

##############################################################################
# lang.array.prototype.indices

do {
    const it = [ true, void, -2 ].indices()
    assert it() == 0
    assert it() == 1
    assert it() == 2
    expect_fail(λ->(it()))
}

##############################################################################
# lang.array.prototype.fill

do {
    const a = lang.array(10)

    assert a.size == 10

    for var e in a {
        assert e == void
    }

    a.fill("abc")

    for var e in a {
        assert e == "abc"
    }

    a.fill(-3, 42)

    for var i = 0; i < a.size; i += 1 {
        if i < 7 {
            assert a[i] == "abc"
        }
        else {
            assert a[i] == 42
        }
    }

    const obj = { x : 1, y : 2 }
    a.fill(2, 8, obj)

    for var i = 0; i < a.size; i += 1 {
        if i < 2 {
            assert a[i] == "abc"
        }
        else if i < 8 {
            const e = a[i]
            assert typeof e == "object"
            assert e == obj
        }
        else {
            assert a[i] == 42
        }
    }

    expect_fail(λ->(lang.array.prototype.fill.apply(void, [1])))
    expect_fail(λ->(a.fill()))
}

##############################################################################
# lang.string.prototype.indices

do {
    const it = "".indices()
    expect_fail(λ->(it()))
}
do {
    const it = "abcd".indices()
    assert it() == 0
    assert it() == 1
    assert it() == 2
    assert it() == 3
    expect_fail(λ->(it()))
}

##############################################################################
# lang.string.prototype.ljust

do {
    assert "abcd".ljust(3)      == "abcd"
    assert "abcd".ljust(4)      == "abcd"
    assert "abcd".ljust(5)      == "abcd "
    assert "abcd".ljust(6, "x") == "abcdxx"

    expect_fail(λ->("abcd".ljust()))
    expect_fail(λ->("abcd".ljust(1, "")))
    expect_fail(λ->("abcd".ljust(1, "oo")))
}

##############################################################################
# lang.string.prototype.rjust

do {
    assert "abcd".rjust(3)      == "abcd"
    assert "abcd".rjust(4)      == "abcd"
    assert "abcd".rjust(5)      == " abcd"
    assert "abcd".rjust(6, "x") == "xxabcd"

    expect_fail(λ->("abcd".rjust()))
    expect_fail(λ->("abcd".rjust(1, "")))
    expect_fail(λ->("abcd".rjust(1, "oo")))
}

##############################################################################
# lang.string.prototype.zfill

do {
    assert "abcd".zfill(3)      == "abcd"
    assert "abcd".zfill(4)      == "abcd"
    assert "abcd".zfill(5)      == "0abcd"
    assert "abcd".zfill(6, "x") == "xxabcd"
    assert "--a".zfill(4, "*")  == "-*-a"
    assert "++b".zfill(5, "#")  == "+##+b"

    expect_fail(λ->("abcd".zfill()))
    expect_fail(λ->("abcd".zfill(1, "")))
    expect_fail(λ->("abcd".zfill(1, "oo")))
}

##############################################################################
# lang.function

do {
    const f = λ->(void)
    assert f instanceof lang.function
    assert f instanceof lang.object
    assert ! (f instanceof lang.integer)
    assert ! (f instanceof lang.string)
    assert ! (f instanceof lang.array)
}

do {
    const value = λ->(void)
    assert value instanceof lang.function
    assert value instanceof lang.object
    assert ! (value instanceof lang.integer)
    assert ! (value instanceof lang.float)
    assert ! (value instanceof lang.number)
    assert ! (value instanceof lang.boolean)
    assert ! (value instanceof lang.void)
    assert ! (value instanceof lang.string)
    assert ! (value instanceof lang.array)
}

##############################################################################
# lang.function.prototype.set_prototype

do {
    expect_fail(λ->(lang.function.set_prototype.apply(void, [void])))
}

##############################################################################
# lang.function.prototype.prototype

do {
    constructor ctor
    {
    }

    ctor.set_prototype(lang.function.prototype)

    const o = ctor()

    expect_fail(λ->(o.prototype))
}

##############################################################################
# lang.function.prototype.*statistics*

do {
    assert "name"         in lang.function.prototype
    assert "registers"    in lang.function.prototype
    assert "instructions" in lang.function.prototype
    assert "size"         in lang.function.prototype

    expect_fail(λ->(lang.function.prototype.name))
    expect_fail(λ->(lang.function.prototype.registers))
    expect_fail(λ->(lang.function.prototype.instructions))
    expect_fail(λ->(lang.function.prototype.size))

    fun f { }

    assert f.name         == "f"
    assert f.registers    == 2
    assert f.instructions == 2 # LOAD.VOID, RETURN
    assert f.size         == 5

    assert lang.function.name         == "<builtin>"
    assert lang.function.registers    == 0
    assert lang.function.instructions == 0
    assert lang.function.size         == 0
}

##############################################################################
# lang.function.prototype.apply

do {
    fun method(arg)
    {
        return this + arg
    }

    assert method.apply(500, [70]) == 570

    expect_fail(λ->(method.apply(void, [])))
    expect_fail(λ->(method.apply(void, void)))
    expect_fail(λ->(method.apply(void)))
    expect_fail(λ->(method.apply()))
}

do {
    fun method
    {
        throw ""
    }

    expect_fail(λ->(method.apply(void, [])))
}

do {
    fun method(args...)
    {
        args.resize(1)
        args[0] = 123
    }

    const args = [1, 2, 3]
    method.apply(void, args)

    assert args.size == 3
    assert args[0]   == 1
    assert args[1]   == 2
    assert args[2]   == 3
}

do {
    constructor ctor
    {
        this.a = 42
    }
    ctor.prototype.x = -1

    assert typeof ctor == "function"

    const co = ctor()
    assert typeof co == "object"
    assert "a" in co
    assert "x" in co
    assert co.a == 42
    assert co.x == -1
    assert co instanceof ctor

    const o = { b: 39 }
    assert typeof o == "object"
    assert ! ("a" in o)
    assert o.b == 39
    assert ! (o instanceof ctor)

    const ret = ctor.apply(o, [])
    assert ret == o
    assert "a" in o
    assert "b" in o
    assert ! ("x" in o)
    assert o.a == 42
    assert o.b == 39
    assert ret.a == 42
    assert ret.b == 39
    assert ! (o instanceof ctor)
    assert ! (ret instanceof ctor)
    expect_fail(λ->(o.x))
    expect_fail(λ->(ret.x))
}

do {
    expect_fail(fun {
        λ->(void) . apply . apply(void, [])
    })
}

##############################################################################
# function constuctors

do {
    fun f
    {
    }

    constructor c
    {
    }

    fun g
    {
        yield void
    }

    assert f instanceof lang.function
    assert ! (f instanceof lang.constructor)
    assert ! (f instanceof lang.generator)

    assert c instanceof lang.function
    assert c instanceof lang.constructor
    assert ! (c instanceof lang.generator)

    assert g instanceof lang.function
    assert ! (g instanceof lang.constructor)
    assert g instanceof lang.generator
}

##############################################################################
# lang.exception

do {
    assert typeof lang.exception == "function"
}

do {
    var line      = void
    var exception = void
    assert ! exception
    try {
        line = __line__ ; lang.exception()
        assert false
    }
    catch const e {
        exception = e
    }
    assert exception
    assert exception instanceof lang.exception
    assert exception.backtrace.size    == 2
    assert exception.backtrace[1].line == line
}

do {
    var exception = void
    assert ! (exception instanceof lang.exception)
    try {
        throw void
    }
    catch const e {
        exception = e
    }
    assert exception instanceof lang.exception
}

do {
    var ex = void
    try {
        lang.exception(42.0)
    }
    catch const e {
        ex = e.value
    }
    assert typeof ex == "float"
    assert ex == 42
}

##############################################################################
# instanceof buffer

do {
    const value = lang.buffer()
    assert value instanceof lang.buffer
    assert value instanceof lang.object
    assert ! (value instanceof lang.integer)
    assert ! (value instanceof lang.float)
    assert ! (value instanceof lang.number)
    assert ! (value instanceof lang.boolean)
    assert ! (value instanceof lang.void)
    assert ! (value instanceof lang.string)
    assert ! (value instanceof lang.array)
}

##############################################################################
# resize

do {
    expect_fail(λ->([].resize(-1)))
    expect_fail(λ->((lang.buffer()).resize(-1)))
}

##############################################################################
# constructor selection

do {
    fun new_type(type, args...)
    {
        return lang[type].apply(void, args)
    }

    const a = new_type("array", "xy", [2])
    assert typeof a == "array"
    assert a.size   == 3
    assert a[0]     == "x"
    assert a[1]     == "y"
    assert a[2]     == 2

    const i = new_type("integer")
    assert typeof i == "integer"
    assert i        == 0

    const n = new_type("number", "1.5")
    assert typeof n == "float"
    assert n        == 1.5

    const o = new_type("object")
    assert typeof o == "object"

    const s = new_type("string", 1, "x", 2)
    assert typeof s == "string"
    assert s        == "1x2"

    for const type in ["integer", "float", "string", "boolean", "void", "object", "array"] {
        assert typeof new_type(type) == type
    }
}

##############################################################################
# lang.shallow

do {
    const obj  = { a: 42, b: 43, c: 44 }
    const iter = lang.shallow(obj)

    var key, value = iter()
    assert key == "a" || key == "b" || key == "c"
    assert value == 42 || value == 43 || value == 44

    key, value = iter()
    assert key == "a" || key == "b" || key == "c"
    assert value == 42 || value == 43 || value == 44

    key, value = iter()
    assert key == "a" || key == "b" || key == "c"
    assert value == 42 || value == 43 || value == 44

    expect_fail(λ->(iter()))
}

do {
    expect_fail(λ->(lang.shallow({})()))
    expect_fail(λ->(lang.shallow([1])()))
    expect_fail(λ->(lang.shallow(1)()))
    expect_fail(λ->(lang.shallow("1")()))
    expect_fail(λ->(lang.shallow(true)()))
    expect_fail(λ->(lang.shallow(void)()))

    var count = 0
    for const n in lang.shallow(λ->(void)) {
        count += 1
    }
    assert count == 0

    count = 0
    for const n, v in lang.shallow({xyz:void}) {
        assert n == "xyz"
        count += 1
    }
    assert count == 1
}

##############################################################################
# lang.range

do {
    expect_fail(lang.range)
}

do {
    const iter = lang.range(5)
    assert iter() == 0
    assert iter() == 1
    assert iter() == 2
    assert iter() == 3
    assert iter() == 4
    expect_fail(iter)
}

do {
    const iter = lang.range(6, 9)
    assert iter() == 6
    assert iter() == 7
    assert iter() == 8
    expect_fail(iter)
}

do {
    const iter = lang.range(-10, -5)
    assert iter() == -10
    assert iter() == -9
    assert iter() == -8
    assert iter() == -7
    assert iter() == -6
    expect_fail(iter)
}

do {
    const iter = lang.range(10, 5)
    expect_fail(iter)
}

do {
    const iter = lang.range(-2, 5, 2)
    assert iter() == -2
    assert iter() == 0
    assert iter() == 2
    assert iter() == 4
    expect_fail(iter)
}

do {
    const iter = lang.range(10, 0, -3)
    assert iter() == 10
    assert iter() == 7
    assert iter() == 4
    assert iter() == 1
    expect_fail(iter)
}

##############################################################################
# lang.map

do {
    const iter = lang.map(λ->(void), [])
    assert typeof iter == "function"
    expect_fail(iter)
}

do {
    const f = lang.map(λ(x)->(x))
    assert typeof f == "function"
    const iter = f(["a", "b"])
    assert typeof f == "function"
    assert iter() == "a"
    assert iter() == "b"
    expect_fail(iter)
}

do {
    const iter = lang.map(λ(x)->(x*10), [2, 3, 4])
    assert typeof iter == "function"
    assert iter()      == 20
    assert iter()      == 30
    assert iter()      == 40
    expect_fail(iter)
}

do {
    const iter = lang.map(λ(x)->(x+5))(lang.range(1, 3))
    assert typeof iter == "function"
    assert iter()      == 6
    assert iter()      == 7
    expect_fail(iter)
}

do {
    const iter = [1, 2, 3].map(λ(x)->(-x))
    assert typeof iter == "function"
    assert iter()      == -1
    assert iter()      == -2
    assert iter()      == -3
    expect_fail(iter)
}

do {
    const iter = "mno".map(λ(x)->(x+"_"))
    assert typeof iter == "function"
    assert iter()      == "m_"
    assert iter()      == "n_"
    assert iter()      == "o_"
    expect_fail(iter)
}

do {
    const iter = false.map(λ(x)->(!x))
    assert typeof iter == "function"
    assert iter()      == true
    expect_fail(iter)
}

##############################################################################
# lang.filter

do {
    const iter = lang.filter(λ->(true), [])
    expect_fail(iter)
}

do {
    const iter = lang.filter(λ->(false), [1, 2, 3])
    expect_fail(iter)
}

do {
    const iter = lang.filter(λ(x)->(x&1), lang.range(10))
    assert typeof iter == "function"
    assert iter()      == 1
    assert iter()      == 3
    assert iter()      == 5
    assert iter()      == 7
    assert iter()      == 9
    expect_fail(iter)
}

do {
    const iter = [5, 6, 7].filter(λ(x)->(x != 6))
    assert typeof iter == "function"
    assert iter()      == 5
    assert iter()      == 7
    expect_fail(iter)
}

do {
    const result = []
    for var elem in lang.range(5) ->
                    lang.map(λ(x)->((x-2) * 10)) ->
                    lang.filter(λ(x)->(x>0)) {
        result.insert(result.size, elem)
    }
    assert result.size == 2
    assert result[0]   == 10
    assert result[1]   == 20
}

##############################################################################
# lang.reduce

do {
    const result = lang.reduce(λ(x, y)->(x + y), 42, [])
    assert result == 42
}

do {
    const result = lang.reduce(λ(x, y)->(x + y), 0, [10])
    assert result == 10
}

do {
    const result = lang.reduce(λ(x, y)->(x + y), 1, [2000, 300, 70, 5])
    assert result == 2376
}

do {
    fun fib_elem(elem)
    {
        var prev = 0
        return lang.range(1, elem).reduce(fun(accum) {
            const y = prev
            prev    = accum
            return accum + y
        }, 1)
    }

    # 11th element of Fibonacci series
    assert fib_elem(11) == 89
}

do {
    fun fib_on_range
    {
        var prev = 0
        return lang.reduce(fun(accum) {
            const y = prev
            prev    = accum
            return accum + y
        }, 1)
    }

    # 12th elem of Fibonacci series
    assert fib_on_range()(lang.range(1, 12)) == 144
}

do {
    const result = [1, 2, 3, 4].reduce(λ(x, y)->(x+y), 0)
    assert result == 10
}

do {
    const count = [1, 2, 3, 1, 4, 5, 1, 6, 1, 7].reduce(λ(x, y)->(x + (y == 1 ? 1 : 0)), 0)
    assert count == 4
}

##############################################################################
# lang.sum

do {
    assert lang.sum([]) == 0
    assert lang.sum([], "") == ""
    assert lang.sum(void) == 0
    assert lang.sum([10, 200, 3, 4000]) == 4213
    assert lang.sum([4.0, 2.0, 8.0]) == 14.0
    assert lang.sum(["ab", "c", "def", "gh"], "") == "abcdefgh"

    expect_fail(lang.sum)
    expect_fail(λ->(lang.sum([1], "")))
}

##############################################################################
# lang.count

do {
    assert lang.count(void, []            ) == 0
    assert lang.count("",   [1, 2]        ) == 0
    assert lang.count(4,    lang.range(10)) == 1
    assert lang.count("a",  "abcadefagh"  ) == 3

    assert "Hello, World!".count("l") == 3

    assert lang.first_elements({x: 8, _test_value: 8, y: 8}).count("_test_value") == 1

    assert lang.range(100).map(λ(x)->(x/4)).count(11) == 4

    assert lang.count(λ(x)->(x > 5), [ 1, 7, 2, 6, 5 ]) == 2

    # Count lowercase letters
    assert "ThIs Is A MiXeD StRiNg".filter(λ(x)->(x.ord() >= 97)).count() == 8
}

##############################################################################
# lang.all

do {
    assert lang.all(1, [1, 1.0, 1]) == true
    assert lang.all(1, [0, 1, 2])   == false
    assert lang.all(λ(x)->(x > 2), [ 4, 3, 5 ]) == true
    assert lang.all(λ(x)->(x > 2), [ 4, 2, 5 ]) == false
}

##############################################################################
# lang.any

do {
    assert lang.any(1, [ 0, 2, 3, 4 ]) == false
    assert lang.any(2, [ 0, 2, 3, 4 ]) == true
    assert lang.any(2, [ 0, 2, 3, 2 ]) == true
    assert lang.any(λ(x)->(x == void), [ 1, 2, 3, 4 ]) == false
    assert lang.any(λ(x)->(x == 3),    [ 1, 2, 3, 4 ]) == true
}

##############################################################################
# lang.method

do {
    const o = {
        _i : 0,
        add : fun(x) { const v = this._i ; this._i = v + x ; return v },
        sub : fun(x) { const v = this._i ; this._i = v - x ; return v }
    }

    assert o.add(1) == 0
    assert o._i     == 1

    const m = lang.method(o, o.add)
    assert typeof m == "function"

    assert m(2) == 1
    assert o._i == 3
    assert m(1) == 3
    assert o._i == 4

    delete o.add

    expect_fail(λ->(o.add(1)))

    assert m(3) == 4
    assert o._i == 7

    const ms = lang.method(o, "sub")
    assert typeof ms == "function"

    assert ms(1) == 7
    assert o._i  == 6

    assert ms(3) == 6
    assert o._i  == 3

    expect_fail(λ->(lang.method(o, "_i")))
    expect_fail(λ->(lang.method(o, "non existent")))
    expect_fail(λ->(lang.method(o, o._i)))
}

##############################################################################
# lang.first_elements

do {
    fun gen
    {
        yield [40, -40]
        yield [-40, 50]
        yield [700, 8]
    }

    const it0 = gen()
    assert it0()[0] == 40
    assert it0()[0] == -40
    assert it0()[0] == 700
    expect_fail(it0)

    const it = lang.first_elements(gen())
    assert it() == 40
    assert it() == -40
    assert it() == 700
    expect_fail(it)
}

do {
    const obj = { "0" : 10, "1" : 200, "2" : 3000, "3" : 4000 }
    const a = [ false, false, false, false ]
    for const key in lang.first_elements(obj) {
        assert typeof key == "string"
        const value = lang.integer(key)
        assert value >= 0 && value <= 3
        assert ! a[value]
        a[value] = true
    }
    for const value in a {
        assert typeof value == "boolean"
        assert value
    }
}

do {
    fun gen
    {
        const it = lang.range(4)
        loop { yield it }
    }

    const it = lang.first_elements(gen())
    assert it() == 0
    assert it() == 1
    assert it() == 2
    assert it() == 3
    expect_fail(it)
}

do {
    const a  = [ lang.range(10, 20),
                 lang.range(5, 6),
                 lang.range(-100, -200, -1) ]
    const it = lang.first_elements(a)
    assert it() == 10
    assert it() == 5
    assert it() == -100
    expect_fail(it)
}

do {
    const a = [ [1, 2], [3], [4, 5], [], [6] ]
    const it = lang.first_elements(a)
    assert it() == 1
    assert it() == 3
    assert it() == 4
    expect_fail(it)
    expect_fail(it)
}

##############################################################################
# lang.stringify

do {
    assert lang.stringify()              == ""
    assert lang.stringify("a")           == "a"
    assert lang.stringify(false)         == "false"
    assert lang.stringify(true)          == "true"
    assert lang.stringify(void)          == "void"
    assert lang.stringify(1)             == "1"
    assert lang.stringify(1.5)           == "1.5"
    assert lang.stringify([])            == "[]"
    assert lang.stringify([1])           == "[1]"
    assert lang.stringify([2, 33, 444])  == "[2, 33, 444]"
    assert lang.stringify(["true",true]) == "[true, true]"

    assert lang.stringify(false, 2, "o") == "false2o"
}

##############################################################################
# lang.hex

do {
    assert lang.hex(42) == "0x2a"

    expect_fail(λ->(lang.hex(3.5)))
}

##############################################################################
# lang.array.prototype.sort

do {
    const a = [].sort()
    assert typeof a == "array"
    assert a.size == 0
}

do {
    const a = [8].sort()
    assert typeof a == "array"
    assert a.size == 1
    assert a[0] == 8
}

do {
    const a = [0, 1]
    const b = a.sort()
    assert typeof b == "array"
    assert a == b
    assert b.size == 2
    assert b[0] == 0
    assert b[1] == 1
}

do {
    const a = [1, 0]
    const b = a.sort()
    assert typeof b == "array"
    assert a == b
    assert b.size == 2
    assert b[0] == 0
    assert b[1] == 1
}

do {
    const a = [1, 1]
    const b = a.sort()
    assert typeof b == "array"
    assert a == b
    assert b.size == 2
    assert b[0] == 1
    assert b[1] == 1
}

do {
    const a = [1, 2, 3]
    const b = a.sort()
    assert typeof b == "array"
    assert a == b
    assert b.size == 3
    assert b[0] == 1
    assert b[1] == 2
    assert b[2] == 3
}

do {
    const a = [3, 2, 1]
    const b = a.sort()
    assert typeof b == "array"
    assert a == b
    assert b.size == 3
    assert b[0] == 1
    assert b[1] == 2
    assert b[2] == 3
}

do {
    const a = [1, 3, 2]
    const b = a.sort()
    assert typeof b == "array"
    assert a == b
    assert b.size == 3
    assert b[0] == 1
    assert b[1] == 2
    assert b[2] == 3
}

do {
    const a = [3, 3, 2]
    const b = a.sort()
    assert typeof b == "array"
    assert a == b
    assert b.size == 3
    assert b[0] == 2
    assert b[1] == 3
    assert b[2] == 3
}

do {
    const a = [2, 2, 2]
    const b = a.sort()
    assert typeof b == "array"
    assert a == b
    assert b.size == 3
    assert b[0] == 2
    assert b[1] == 2
    assert b[2] == 2
}

do {
    constructor sortable(key)
    {
        this.key = key
    }

    const a = [ sortable(40), sortable(20), sortable(30), sortable(10), sortable(25) ]
    a.sort(λ(x, y) -> (x.key < y.key))
    assert a[0].key == 10
    assert a[1].key == 20
    assert a[2].key == 25
    assert a[3].key == 30
    assert a[4].key == 40
}

##############################################################################
# lang.sort

do {
    const a = [ 5, 4, 2, 3, 1 ]
    const s = lang.sort(a)
    assert typeof s == "function"
    assert s() == 1
    assert s() == 2
    assert s() == 3
    assert s() == 4
    assert s() == 5
    expect_fail(s)
    assert a.size == 5
    assert a[0] == 5
    assert a[1] == 4
    assert a[2] == 2
    assert a[3] == 3
    assert a[4] == 1
}

do {
    const s = lang.sort("foobar")
    assert typeof s == "function"
    assert s() == "a"
    assert s() == "b"
    assert s() == "f"
    assert s() == "o"
    assert s() == "o"
    assert s() == "r"
    expect_fail(s)
}

do {
    const s = lang.sort("fooba", λ(x, y)->(x > y))
    assert typeof s == "function"
    assert s() == "o"
    assert s() == "o"
    assert s() == "f"
    assert s() == "b"
    assert s() == "a"
    expect_fail(s)
}

##############################################################################
# lang.args

do {
    assert typeof lang.args == "array"
    assert lang.args.size   == 1
    assert lang.args[0].ends_with("module_lang.kos")
}

##############################################################################
# lang.thread

do {
    const o = { t1: 0, t2: 0, done: false }

    fun thread1
    {
        while ! o.t2 { }
        o.t1 += 1
    }

    fun thread2
    {
        while ! o.done { }
        o.t2 += 1
        while ! o.t1 { }
    }

    const t1 = thread1.async()
    const t2 = thread2.async()

    assert t1 instanceof lang.thread
    assert t1 instanceof lang.object
    assert t2 instanceof lang.thread
    assert t2 instanceof lang.object

    o.done = true
    t1.wait()
    t2.wait()

    assert o.t1 == 1
    assert o.t2 == 1
}

do {
    fun sum(a, b)
    {
        return a + b
    }

    const t = sum.async(10, 24);

    assert t instanceof lang.thread

    const result = t.wait()

    assert result   == 34
    assert t.result == 34
    assert t.function    == sum
    assert typeof t.args == "array"
    assert t.args.size   == 2
    assert t.args[0]     == 10
    assert t.args[1]     == 24

    expect_fail(λ->(t.wait()))
}

do {
    fun thread(a)
    {
        return a * 10
    }

    assert thread(-42) == -420

    do {
        const t = thread.async(2)
        assert t.wait() == 20
    }

    do {
        const t = thread.async(123)
        assert t.wait() == 1230
    }
}

do {
    fun thread
    {
        throw "something"
    }

    const t = thread.async()
    var   e = void
    try {
        t.wait()
    }
    catch const exc {
        e = exc
    }
    assert typeof e == "object"
    assert e.value == "something"
}

do {
    var t       = void
    var done    = false
    var success = false

    fun thread(wait)
    {
        defer { done = true }
        while ! t { }
        if wait {
            t.wait()
        }
        success = true
    }

    # Normal invocation
    t = thread.async(false)
    assert t instanceof lang.thread
    while ! done { }
    t.wait()
    assert success
    t       = void
    success = false
    done    = false

    # Exception inside thread
    t = thread.async(true)
    assert t instanceof lang.thread
    while ! done { }
    var e = void
    try { t.wait() } catch const exc { e = exc }
    assert ! success
    assert e != void
    t       = void
    success = false
    done    = false

    # Incorrect number of args (not even called)
    e = void
    t = thread.async()
    assert t instanceof lang.thread
    try { t.wait() } catch const exc { e = exc }
    assert ! done
    assert ! success
    assert e != void
}

##############################################################################
# lang.backtrace

do {
    var line = __line__; var b = lang.backtrace()

    assert b.size        == 1
    assert b[0].line     == line
    assert b[0].function == "<global>"

    fun fff
    {
        line = __line__; b = lang.backtrace()
    }

    var line2 = __line__; fff()

    assert b.size        == 2
    assert b[0].line     == line
    assert b[0].function == "fff"
    assert b[1].line     == line2
    assert b[1].function == "<global>"
}
