#
# Copyright (c) 2014-2016 Chris Dragan
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.
#
import lang.print

fun check(function, registers, instructions, size)
{
    fun check(function, value, prop)
    {
        const actual = function[prop]
        if actual != value {
            print("\(function.name).\(prop) is \(actual), but expected \(value)\n")
            assert actual <= value
        }
    }

    check(function, registers,    "registers")
    check(function, instructions, "instructions")
    check(function, size,         "size")
}

#============================================================================#

{
    fun empty
    {
    }
    assert empty() == void

    check(empty, 2, 2, 5)
}

#============================================================================#

{
    fun sum(a, b, c, d, e)
    {
        return a + b + c + d + e
    }

    assert sum(1, 2, 3, 4, 5) == 15

    check(sum, 3, 10, 54)
}

#============================================================================#

{
    fun return_this
    {
        return this
    }

    assert return_this.apply(123, []) == 123

    check(return_this, 2, 1, 3)
}

#============================================================================#

{
    fun args_to_array(args...)
    {
        return args
    }

    {
        const a = args_to_array(8, void, -1.5)
        assert typeof a == "array"
        assert a.size   == 3
        assert a[0]     == 8
        assert a[1]     == void
        assert a[2]     == -1.5
    }

    check(args_to_array, 2, 1, 3)
}

#============================================================================#

{
    fun return_string
    {
        return "string"
    }

    assert return_string() == "string"

    check(return_string, 2, 2, 9)
}

#============================================================================#

{
    fun times_plus(a, b, c)
    {
        return a * b + c
    }

    assert times_plus(2, 3, 4) == 10

    check(times_plus, 3, 6, 32)
}

#============================================================================#

{
    fun plus_times(a, b, c)
    {
        return a + b * c
    }

    assert plus_times(2, 3, 4) == 14

    check(plus_times, 4, 6, 32)
}

#============================================================================#

{
    fun find_lowest(array)
    {
        var lowest = 0x7FFFFFFFFFFFFFFF
        for var i in array {
            if i < lowest {
                lowest = i
            }
        }
        return lowest
    }

    assert find_lowest([9, 10, -5, 245, -1000, 9000, -1]) == -1000

    check(find_lowest, 5, 12, 63)
}

#============================================================================#

{
    fun find_greatest(array)
    {
        var   greatest = -0x8000000000000000
        const size     = array.size
        for var i = 0; i < size; i += 1 {
            const value = array[i]
            if value > greatest {
                greatest = value
            }
        }
        return greatest
    }

    assert find_greatest([-100, 90, -5, 400, 10, 15]) == 400

    check(find_greatest, 8, 15, 76)
}

#============================================================================#

{
    fun throw_exception(a)
    {
        try {
            throw a
        }
        catch const e {
            return e.value
        }
    }

    assert throw_exception(5) == 5

    check(throw_exception, 3, 8, 32)
}

#============================================================================#

{
    fun map_invoke(array, transform)
    {
        return array.map(transform)
    }

    {
        const iter = map_invoke([1, 7, -5], λ(x)->(x+5))
        assert iter() == 6
        assert iter() == 12
        assert iter() == 0
    }

    check(map_invoke, 5, 7, 39)
}

#============================================================================#

{
    fun map(array, transform)
    {
        for var elem in array {
            yield transform(elem)
        }
    }

    {
        const iter = map([9, -0.5], λ(x)->(x+1))
        assert iter() == 10
        assert iter() == 0.5
    }

    check(map, 6, 15, 68)
}

#============================================================================#

{
    fun multi_const(x)
    {
        const multiply = 2 * 3 + 1
        const add      = 2 << 2
        return x * multiply + add + add
    }

    {
        assert multi_const(4) == 44
    }

    check(multi_const, 4, 7, 28)
}

#============================================================================#

{
    fun unreachable_if(cond)
    {
        if cond {
            throw 1
        }
        else {
            return 2
        }
        # unreachable
        const a = cond + 10
        return cond ? a : 0
    }
    assert unreachable_if(false) == 2
    {
        var caught = void
        try {
            caught = unreachable_if(true)
        }
        catch const e {
            caught = e.value
        }
        assert caught == 1
    }
    check(unreachable_if, 2, 7, 29)
}

#============================================================================#

{
    fun unreachable_do(a)
    {
        do {
            return 10
            # unreachable
            const b = a + 1
            return b
        }
        while false
        # unreachable
        return 20
    }
    assert unreachable_do(1) == 10

    check(unreachable_do, 2, 2, 6)
}

#============================================================================#

{
    fun unreachable_while(a)
    {
        while true {
            return 10
            # unreachable
            return 20
        }
        # unreachable
        return a + 1
    }
    assert unreachable_while(1) == 10

    check(unreachable_while, 2, 3, 11)
}

#============================================================================#

{
    fun break_inside_while(a)
    {
        var b = a
        while true {
            b += 1
            break
            b += 10
        }
        b += 100
        return b
    }
    assert break_inside_while(1) == 102

    check(break_inside_while, 3, 8, 34)
}

#============================================================================#

{
    fun falsy_while(a)
    {
        while false {
            a += 100
            return 0
        }
        return a
    }
    assert falsy_while(8) == 8

    check(falsy_while, 2, 2, 10)
}

#============================================================================#

{
    fun falsy_for(a)
    {
        for ; false; a += 1 {
            return a
        }
        return a + 10
    }
    assert falsy_for(2) == 12

    check(falsy_for, 3, 7, 30)
}

#============================================================================#

{
    fun unreachable_try()
    {
        try {
            defer {
                throw "cancel return"
            }
            return 1
            # unreachable
            return 2
        }
        catch const e {
        }
        return 3
    }
    assert unreachable_try() == 3

    check(unreachable_try, 3, 21, 85)
}

#============================================================================#

{
    fun unreachable_if_from_const
    {
        const truthy = "abc"
        if truthy {
            return 10
        }
        else {
            return 20
        }
    }
    assert unreachable_if_from_const() == 10

    check(unreachable_if_from_const, 2, 3, 12)
}

#============================================================================#

{
    fun var_to_const_while_true(a)
    {
        var b = a
        var x = 10
        while x {
            if true {
                b += 1
                break
            }
            else {
                x = 0
            }
        }
        return b + x
    }
    assert var_to_const_while_true(2) == 13

    check(var_to_const_while_true, 4, 8, 34)
}

#============================================================================#

{
    fun var_to_const_while_false(a)
    {
        var x = 0e0
        while x {
            if true {
                a += 1
            }
            else {
                x = 1
            }
        }
        return a + x
    }
    assert var_to_const_while_false(2) == 2

    check(var_to_const_while_false, 3, 4, 24)
}

#============================================================================#

{
    fun collapse_logical_or_true(a)
    {
        return "xyz" || a
    }
    assert collapse_logical_or_true(100) == "xyz"

    check(collapse_logical_or_true, 2, 2, 9)
}

#============================================================================#

{
    fun collapse_logical_or_false(a)
    {
        return ! "xyz" || a
    }
    assert collapse_logical_or_false(100) == 100

    check(collapse_logical_or_false, 2, 2, 10)
}

#============================================================================#

{
    fun collapse_logical_and_true(a)
    {
        return "xyz" && a
    }
    assert collapse_logical_and_true(100) == 100

    check(collapse_logical_and_true, 2, 2, 10)
}

#============================================================================#

{
    fun collapse_logical_and_false(a)
    {
        return 0e0 && a
    }
    const ret = collapse_logical_and_false("z")
    assert typeof ret == "float"
    assert ret == 0

    check(collapse_logical_and_false, 2, 2, 13)
}

#============================================================================#

{
    fun collapse_logical_tri_true(a)
    {
        return [] ? a : a + 1
    }
    assert collapse_logical_tri_true(10) == 10

    check(collapse_logical_tri_true, 2, 2, 10)
}

#============================================================================#

{
    fun collapse_logical_tri_false(a)
    {
        return void ? a + 2 : a
    }
    assert collapse_logical_tri_false(20) == 20

    check(collapse_logical_tri_false, 2, 2, 10)
}

#============================================================================#

{
    fun collapse_add
    {
        return 2 + 3
    }
    assert collapse_add() == 5

    check(collapse_add, 2, 2, 6)
}

#============================================================================#

{
    fun collapse_interpolated_strings_1
    {
        return "this\( " is " )test"
    }
    assert collapse_interpolated_strings_1() == "this is test"

    check(collapse_interpolated_strings_1, 2, 2, 9)
}

#============================================================================#

{
    fun collapse_interpolated_strings_2(a...)
    {
        return "\( typeof { x: a } ) \( void ) \( false ) \( 0.000E+0 ) \( 0x10 + (16) )"
    }
    assert collapse_interpolated_strings_2() == "object void false 0.000000 32"

    check(collapse_interpolated_strings_2, 2, 2, 9)
}

#============================================================================#

{
    fun collapse_if_numeric(a, b)
    {
        if (1 + 2) {
            return a
        }
        else {
            return b
        }
    }
    assert collapse_if_numeric(10, 20) == 10

    check(collapse_if_numeric, 2, 2, 10)
}
