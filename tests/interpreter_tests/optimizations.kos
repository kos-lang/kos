#
# Copyright (c) 2014-2017 Chris Dragan
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.
#
import lang.print

fun check(function, expected)
{
    fun check(function, value, prop)
    {
        const actual = function[prop]
        if actual != value {
            print("\(function.name).\(prop) is \(actual), but expected \(value)")
            assert actual <= value
        }
    }

    check(function, expected.registers,    "registers")
    check(function, expected.instructions, "instructions")
    check(function, expected.size,         "size")
}

#============================================================================#

do {
    fun empty
    {
    }
    assert empty() == void

    check(empty, { registers: 2, instructions: 2, size: 5 })
}

#============================================================================#

do {
    fun sum(a, b, c, d, e)
    {
        return a + b + c + d + e
    }

    assert sum(1, 2, 3, 4, 5) == 15

    check(sum, { registers: 3, instructions: 10, size: 54 })
}

#============================================================================#

do {
    fun return_this
    {
        return this
    }

    assert return_this.apply(123, []) == 123

    check(return_this, { registers: 2, instructions: 1, size: 3 })
}

#============================================================================#

do {
    fun args_to_array(args...)
    {
        return args
    }

    do {
        const a = args_to_array(8, void, -1.5)
        assert typeof a == "array"
        assert a.size   == 3
        assert a[0]     == 8
        assert a[1]     == void
        assert a[2]     == -1.5
    }

    check(args_to_array, { registers: 2, instructions: 1, size: 3 })
}

#============================================================================#

do {
    fun return_string
    {
        return "string"
    }

    assert return_string() == "string"

    check(return_string, { registers: 2, instructions: 2, size: 9 })
}

#============================================================================#

do {
    fun times_plus(a, b, c)
    {
        return a * b + c
    }

    assert times_plus(2, 3, 4) == 10

    check(times_plus, { registers: 3, instructions: 6, size: 32 })
}

#============================================================================#

do {
    fun plus_times(a, b, c)
    {
        return a + b * c
    }

    assert plus_times(2, 3, 4) == 14

    check(plus_times, { registers: 4, instructions: 6, size: 32 })
}

#============================================================================#

do {
    fun find_lowest(array)
    {
        var lowest = 0x7FFFFFFFFFFFFFFF
        for var i in array {
            if i < lowest {
                lowest = i
            }
        }
        return lowest
    }

    assert find_lowest([9, 10, -5, 245, -1000, 9000, -1]) == -1000

    check(find_lowest, { registers: 5, instructions: 12, size: 63 })
}

#============================================================================#

do {
    fun find_greatest(array)
    {
        var   greatest = -0x8000000000000000
        const size     = array.size
        for var i = 0; i < size; i += 1 {
            const value = array[i]
            if value > greatest {
                greatest = value
            }
        }
        return greatest
    }

    assert find_greatest([-100, 90, -5, 400, 10, 15]) == 400

    check(find_greatest, { registers: 8, instructions: 15, size: 76 })
}

#============================================================================#

do {
    fun throw_exception(a)
    {
        try {
            throw a
        }
        catch const e {
            return e.value
        }
    }

    assert throw_exception(5) == 5

    check(throw_exception, { registers: 3, instructions: 8, size: 32 })
}

#============================================================================#

do {
    fun map_invoke(array, transform)
    {
        return array.map(transform)
    }

    do {
        const iter = map_invoke([1, 7, -5], x => (x + 5))
        assert iter() == 6
        assert iter() == 12
        assert iter() == 0
    }

    check(map_invoke, { registers: 5, instructions: 6, size: 36 })
}

#============================================================================#

do {
    fun map(array, transform)
    {
        for var elem in array {
            yield transform(elem)
        }
    }

    do {
        const iter = map([9, -0.5], x => (x + 1))
        assert iter() == 10
        assert iter() == 0.5
    }

    check(map, { registers: 6, instructions: 15, size: 68 })
}

#============================================================================#

do {
    fun multi_const(x)
    {
        const multiply = 2 * 3 + 1
        const add      = 2 << 2
        return x * multiply + add + add
    }

    do {
        assert multi_const(4) == 44
    }

    check(multi_const, { registers: 4, instructions: 7, size: 28 })
}

#============================================================================#

do {
    fun unreachable_if(cond)
    {
        if cond {
            throw 1
        }
        else {
            return 2
        }
        # unreachable
        const a = cond + 10
        return cond ? a : 0
    }
    assert unreachable_if(false) == 2
    do {
        var caught = void
        try {
            caught = unreachable_if(true)
        }
        catch const e {
            caught = e.value
        }
        assert caught == 1
    }
    check(unreachable_if, { registers: 2, instructions: 7, size: 29 })
}

#============================================================================#

do {
    fun unreachable_repeat(a)
    {
        repeat {
            return 10
            # unreachable
            const b = a + 1
            return b
        } while false
        # unreachable
        return 20
    }
    assert unreachable_repeat(1) == 10

    check(unreachable_repeat, { registers: 2, instructions: 2, size: 6 })
}

#============================================================================#

do {
    fun early_return_from_repeat
    {
        repeat {
            return 8
        } while true
        return 1
    }

    assert early_return_from_repeat() == 8

    check(early_return_from_repeat, { registers: 2, instructions: 2, size: 6 })
}

#============================================================================#

do {
    fun early_break_from_repeat
    {
        repeat {
            break
            return 1
        } while true
        return 8
    }

    assert early_break_from_repeat() == 8

    check(early_break_from_repeat, { registers: 2, instructions: 3, size: 11 })
}

#============================================================================#

do {
    fun unreachable_while(a)
    {
        while true {
            return 10
            # unreachable
            return 20
        }
        # unreachable
        return a + 1
    }
    assert unreachable_while(1) == 10

    check(unreachable_while, { registers: 2, instructions: 3, size: 11 })
}

#============================================================================#

do {
    fun break_inside_while(a)
    {
        var b = a
        while true {
            b += 1
            break
            b += 10
        }
        b += 100
        return b
    }
    assert break_inside_while(1) == 102

    check(break_inside_while, { registers: 3, instructions: 8, size: 34 })
}

#============================================================================#

do {
    fun falsy_while(a)
    {
        while false {
            a += 100
            return 0
        }
        return a
    }
    assert falsy_while(8) == 8

    check(falsy_while, { registers: 2, instructions: 2, size: 10 })
}

#============================================================================#

do {
    fun falsy_for(a)
    {
        for ; false; a += 1 {
            return a
        }
        return a + 10
    }
    assert falsy_for(2) == 12

    check(falsy_for, { registers: 3, instructions: 7, size: 30 })
}

#============================================================================#

do {
    fun unreachable_try()
    {
        try {
            defer {
                throw "cancel return"
            }
            return 1
            # unreachable
            return 2
        }
        catch const e {
        }
        return 3
    }
    assert unreachable_try() == 3

    check(unreachable_try, { registers: 3, instructions: 21, size: 85 })
}

#============================================================================#

do {
    fun unreachable_if_from_const
    {
        const truthy = "abc"
        if truthy {
            return 10
        }
        else {
            return 20
        }
    }
    assert unreachable_if_from_const() == 10

    check(unreachable_if_from_const, { registers: 2, instructions: 3, size: 12 })
}

#============================================================================#

do {
    fun var_to_const_while_true(a)
    {
        var b = a
        var x = 10
        while x {
            if true {
                b += 1
                break
            }
            else {
                x = 0
            }
        }
        return b + x
    }
    assert var_to_const_while_true(2) == 13

    check(var_to_const_while_true, { registers: 4, instructions: 8, size: 34 })
}

#============================================================================#

do {
    fun truthy_while
    {
        loop {
            return 88
            # TODO optimize-out the jump at the end
        }
    }
    assert truthy_while() == 88

    check(truthy_while, { registers: 2, instructions: 3, size: 11 })
}

#============================================================================#

do {
    fun stuck_forever
    {
        loop {
        }
        # TODO optimize-out the trailing return
    }

    check(stuck_forever, { registers: 2, instructions: 3, size: 10 })
}

#============================================================================#

do {
    fun var_to_const_while_false(a)
    {
        var x = 0e0
        while x {
            if true {
                a += 1
            }
            else {
                x = 1
            }
        }
        return a + x
    }
    assert var_to_const_while_false(2) == 2

    check(var_to_const_while_false, { registers: 3, instructions: 4, size: 24 })
}

#============================================================================#

do {
    fun collapse_logical_or_true(a)
    {
        return "xyz" || a
    }
    assert collapse_logical_or_true(100) == "xyz"

    check(collapse_logical_or_true, { registers: 2, instructions: 2, size: 9 })
}

#============================================================================#

do {
    fun collapse_logical_or_false(a)
    {
        return ! "xyz" || a
    }
    assert collapse_logical_or_false(100) == 100

    check(collapse_logical_or_false, { registers: 2, instructions: 2, size: 10 })
}

#============================================================================#

do {
    fun collapse_logical_and_true(a)
    {
        return "xyz" && a
    }
    assert collapse_logical_and_true(100) == 100

    check(collapse_logical_and_true, { registers: 2, instructions: 2, size: 10 })
}

#============================================================================#

do {
    fun collapse_logical_and_false(a)
    {
        return 0e0 && a
    }
    const ret = collapse_logical_and_false("z")
    assert typeof ret == "float"
    assert ret == 0

    check(collapse_logical_and_false, { registers: 2, instructions: 2, size: 13 })
}

#============================================================================#

do {
    fun collapse_logical_tri_true(a)
    {
        return [] ? a : a + 1
    }
    assert collapse_logical_tri_true(10) == 10

    check(collapse_logical_tri_true, { registers: 2, instructions: 2, size: 10 })
}

#============================================================================#

do {
    fun collapse_logical_tri_false(a)
    {
        return void ? a + 2 : a
    }
    assert collapse_logical_tri_false(20) == 20

    check(collapse_logical_tri_false, { registers: 2, instructions: 2, size: 10 })
}

#============================================================================#

do {
    fun collapse_add
    {
        return 2 + 3
    }
    assert collapse_add() == 5

    check(collapse_add, { registers: 2, instructions: 2, size: 6 })
}

#============================================================================#

do {
    fun collapse_interpolated_strings_1
    {
        return "this\( " is " )test"
    }
    assert collapse_interpolated_strings_1() == "this is test"

    check(collapse_interpolated_strings_1, { registers: 2, instructions: 2, size: 9 })
}

#============================================================================#

do {
    fun collapse_interpolated_strings_2(a...)
    {
        return "\( typeof (1 * 3) ) \( void ) \( false ) \( 0.000E+0 ) \( 0x10 + (16) )"
    }
    assert collapse_interpolated_strings_2() == "integer void false 0.0 32"

    check(collapse_interpolated_strings_2, { registers: 2, instructions: 2, size: 9 })
}

#============================================================================#

do {
    fun collapse_if_numeric(a, b)
    {
        if (1 + 2) {
            return a
        }
        else {
            return b
        }
    }
    assert collapse_if_numeric(10, 20) == 10

    check(collapse_if_numeric, { registers: 2, instructions: 2, size: 10 })
}

#============================================================================#

do {
    fun unused_variable(func)
    {
        var x = func()
    }

    var value = void
    unused_variable(fun { value = 100 })
    assert(value == 100)

    check(unused_variable, { registers: 5, instructions: 6, size: 22 })
}

#============================================================================#

do {
    fun demote_indep_vars(a)
    {
        var v = a + 1
        return fun {
            if false {
                return a + v
            }
            else {
                return 42
            }
        }
    }

    assert demote_indep_vars(1)() == 42

    check(demote_indep_vars, { registers: 4, instructions: 5, size: 26 })
}

#============================================================================#

do {
    fun optimize_default_args
    {
        fun ret_first_arg(c, b=2+3*4, a="x")
        {
            return c
        }
        return ret_first_arg
    }

    const f = optimize_default_args()
    assert f(52)  == 52
    assert f(-10) == -10

    check(optimize_default_args, { registers: 2, instructions: 2, size: 12 })
    check(f,                     { registers: 2, instructions: 2, size: 10 })
}
