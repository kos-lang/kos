#
# Copyright (c) 2014-2018 Chris Dragan
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.
#

import base.exception

# passing assertions
do {
    assert 1
    assert true
    assert "abc"

    const a = 2
    assert false || a == 2
}

# failing assertions
do {
    var caught = false
    try {
        assert false
    }
    catch const e {
        caught = true
    }
    if ! caught {
        throw "Missing assertion"
    }
}
do {
    var caught = false
    try {
        assert void == 1 || {} == []
    }
    catch const e {
        caught = true
    }
    if ! caught {
        throw "Missing assertion"
    }
}

# try..catch
do {
    var fail = false
    try {
    }
    catch const e {
        fail = true
    }

    assert ! fail
}

# try..catch
do {
    var fail = true
    try {
        fail = false
    }
    catch const e {
        fail = true
    }

    assert ! fail
}

# throw..catch
do {
    var fail = true
    try {
        throw "exception"
    }
    catch const e {
        fail = e.value != "exception"
    }

    assert ! fail
}

# throw..defer
do {
    var fail = 2
    try {
        defer {
            if fail == 2 {
                fail = 1
            }
        }
        throw "exception"
    }
    catch const e {
        if fail == 1 {
            fail = 0
        }
    }

    assert ! fail
}

# throw..catch and defer
do {
    var fail = 3
    do {
        defer {
            if fail == 1 {
                fail = 0
            }
        }
        try {
            if fail == 3 {
                fail = 2
            }
            throw "exception"
        }
        catch const e {
            if fail == 2 && e.value == "exception" {
                fail = 1
            }
        }
    }

    assert ! fail
}

# throw through many defer statements
do {
    var fail = 7
    do {
        defer {
            if fail == 1 {
                fail = 0
            }
        }
        try {
            defer {
                if fail == 3 {
                    fail = 2
                }
            }
            defer {
                if fail == 4 {
                    fail = 3
                }
            }
            defer {
                if fail == 5 {
                    fail = 4
                }
            }
            defer {
                if fail == 6 {
                    fail = 5
                }
            }
            defer {
                if fail == 7 {
                    fail = 6
                }
            }
            throw "exception"
        }
        catch const e {
            if fail == 2 && e.value == "exception" {
                fail = 1
            }
        }
    }

    assert ! fail
}

# throw through many catch statements
do {
    var fail = 7
    do {
        defer {
            if fail == 1 {
                fail = 0
            }
        }
        try {
            try {
                try {
                    try {
                        try {
                            try {
                                throw "exception"
                            }
                            catch const e {
                                if fail == 7 && e.value == "exception" {
                                    fail = 6
                                }
                                throw e
                            }
                        }
                        catch const e {
                            if fail == 6 && e.value == "exception" {
                                fail = 5
                            }
                            throw e
                        }
                    }
                    catch const e {
                        if fail == 5 && e.value == "exception" {
                            fail = 4
                        }
                        throw e
                    }
                }
                catch const e {
                    if fail == 4 && e.value == "exception" {
                        fail = 3
                    }
                    throw e
                }
            }
            catch const e {
                if fail == 3 && e.value == "exception" {
                    fail = 2
                }
                throw e
            }
        }
        catch const e {
            if fail == 2 && e.value == "exception" {
                fail = 1
            }
        }
    }

    assert ! fail
}

do {
    var l1 = __line__ + 3
    fun throws
    {
        throw "xyz"
    }

    var l2 = void

    fun indirect
    {
        l2 = __line__; throws()
    }

    var l3   = void
    var fail = true

    try {
        l3 = __line__; indirect()
    }
    catch const e {
        assert e.value                 == "xyz"
        assert e.backtrace.size        == 3
        assert e.backtrace[0].line     == l1
        assert e.backtrace[0].function == "throws"
        assert e.backtrace[1].line     == l2
        assert e.backtrace[1].function == "indirect"
        assert e.backtrace[2].line     == l3
        assert e.backtrace[2].function == "<global>"
        fail = false
    }

    assert ! fail
}

do {
    var l1 = void

    fun native_callee_throws
    {
        l1 = __line__; [].resize.apply(0, [])
    }

    var l2   = void
    var fail = true

    try {
        l2 = __line__; native_callee_throws()
    }
    catch const e {
        assert e.backtrace.size        == 3
        assert e.backtrace[0].line     == 0
        assert e.backtrace[0].function == "<builtin>"
        assert e.backtrace[1].line     == l1
        assert e.backtrace[1].function == "native_callee_throws"
        assert e.backtrace[2].line     == l2
        assert e.backtrace[2].function == "<global>"
        fail = false
    }

    assert ! fail
}

do {
    fun generator_throws
    {
        throw 123
        yield void # Unreachable, so not converted to generator
    }

    var thrown = true
    try {
        generator_throws()
    }
    catch const e {
        if e.value == 123 {
            thrown = true
        }
    }

    assert thrown
}

do {
    fun generator_throws
    {
        if false { yield void }
        throw 123
    }

    generator_throws()
}

do {
    var l1 = void

    fun iterator_throws
    {
        if false { yield void }
        l1 = __line__; throw 123
    }

    var l2   = void
    var fail = true

    try {
        const iter = iterator_throws()
        l2 = __line__; iter()
    }
    catch const e {
        assert e.value                 == 123
        assert e.backtrace.size        == 2
        assert e.backtrace[0].line     == l1
        assert e.backtrace[0].function == "iterator_throws"
        assert e.backtrace[1].line     == l2
        assert e.backtrace[1].function == "<global>"
        fail = false
    }

    assert ! fail
}

do {
    var fail = true

    fun only_defer
    {
        defer {
            fail = false
        }
    }

    only_defer()

    assert ! fail
}

do {
    fun early_return(early)
    {
        do {
            defer {
            }
            if early {
                return 10
            }
        }
        return 20
    }

    assert early_return(true)  == 10
    assert early_return(false) == 20
}

do {
    fun return_paths(x)
    {
        do {
            defer {
                if x == 2 {
                    return x + 40
                }
                if x == 3 {
                    return x + 30
                }
            }
            if x == 1 {
                return x + 10
            }
            if x == 2 {
                return x + 20
            }
        }
        return 100
    }

    assert return_paths(1) == 11
    assert return_paths(2) == 42
    assert return_paths(3) == 33
    assert return_paths(4) == 100
}

do {
    fun cancel_return(cancel)
    {
        try {
            defer {
                if cancel {
                    throw void
                }
            }
            return 1
        }
        catch const e {
        }
        return 3
    }

    assert cancel_return(false) == 1
    assert cancel_return(true)  == 3
}

do {
    fun change_return(change)
    {
        defer {
            if change {
                return 4
            }
        }
        return 2
    }
    assert change_return(false) == 2
    assert change_return(true)  == 4
}

do {
    var depth = 0

    fun deep_return_paths(x)
    {
        do {
            defer {
                depth -= 1
                if x == 4 {
                    return x + 43
                }
            }
            try {
                depth += 1
                if x == 1 {
                    return x + 10
                }
                defer {
                    depth -= 1
                    if x == 4 {
                        return x + 42
                    }
                    if x == 5 {
                        throw x + 51
                    }
                }
                try {
                    depth += 1
                    do {
                        defer {
                            depth -= 1
                            if x == 4 {
                                return x + 41
                            }
                        }
                        depth += 1
                        if x == 2 {
                            return x + 20
                        }
                        if x == 3 {
                            throw x + 30
                        }
                        if x == 4 {
                            return x + 40
                        }
                        if x == 5 {
                            return x + 50
                        }
                    }
                }
                catch const e {
                    return e.value + 300
                }
            }
            catch const e {
                if e.value == 56 {
                    return e.value + 2
                }
            }
        }
        return x * 100
    }

    assert deep_return_paths(1) == 11
    assert depth == 0
    assert deep_return_paths(2) == 22
    assert depth == 0
    assert deep_return_paths(3) == 333
    assert depth == 0
    assert deep_return_paths(4) == 47
    assert depth == 0
    assert deep_return_paths(5) == 58
    assert depth == 0
    assert deep_return_paths(6) == 600
    assert depth == 0
}

do {
    var a = 1
    do {
        defer { a *= 3 }
        a += 1
    }
    assert a == 6
}

do {
    var a = 0
    try {
        defer { a = a * 10 + 1 }
        throw 2
        a = 9000
    }
    catch const e {
        a = a * 10 + e.value
    }
    assert a == 12
}

do {
    var a = 0
    try {
        defer { a = a * 10 + 1 }
        defer { throw 2 }
        defer { a = a * 10 + 3 }
        a = a * 10 + 4
    }
    catch const e {
        a = a * 10 + e.value
    }
    assert a == 4312
}

# fiddle with guts of an exception
do {
    var pos   = 0
    var final = void
    try {
        try {
            pos = (pos * 10) + 1
            throw -5
            pos = 0
        }
        catch const e {
            pos = (pos * 10) + 2
            assert e instanceof exception
            assert e.value == -5
            delete e.value
            e.hello = "world"
            pos = (pos * 10) + 3
            throw e
            pos = 0
        }
        pos = 0
    }
    catch const e2 {
        pos = (pos * 10) + 4
        final = e2
    }
    assert pos          == 1234
    assert typeof final == "object"
    assert final instanceof exception
    assert ! ("value" in final)
    assert "hello" in final
    assert final.hello == "world"
}

# function inside defer statement should not crash the interpreter
# test case from fuzzer
loop {
    defer {
        o => (o => (o))
    }
    break
}
