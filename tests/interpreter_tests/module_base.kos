#
# Copyright (c) 2014-2019 Chris Dragan
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.
#

import base
import test_tools.expect_fail

##############################################################################
# base.number

do {
    assert typeof base.number           == "class"
    assert typeof base.number.prototype == "object"
    assert base.number instanceof base.function
    assert base.number instanceof base.class
}

do {
    const number = base.number()
    assert typeof number == "integer"
    assert number        == 0
}

do {
    const number = base.number(101)
    assert typeof number == "integer"
    assert number        == 101
}

do {
    const number = base.number(10.1)
    assert typeof number == "float"
    assert number        == 10.1
}

do {
    expect_fail(()=>(1).times_three())
    expect_fail(()=>(1.5).times_three())

    base.number.prototype.times_three = () => this*3

    const i = (5).times_three()
    assert typeof i == "integer"
    assert i        == 15

    const f = (5.0).times_three()
    assert typeof f == "float"
    assert f        == 15
}

do {
    expect_fail(()=>base.number(""))
    expect_fail(()=>base.number("a"))
    expect_fail(()=>base.number("e"))
    expect_fail(()=>base.number("123x"))
    expect_fail(()=>base.number("-"))
    expect_fail(()=>base.number("--"))
    expect_fail(()=>base.number("-E"))
    expect_fail(()=>base.number({}))
    expect_fail(()=>base.number([]))
    expect_fail(()=>base.number(()=>void))
    expect_fail(()=>base.number(false))
    expect_fail(()=>base.number(void))

    const _1 = base.number("1")
    assert typeof _1 == "integer"
    assert _1        == 1

    const _2 = base.number("0x002")
    assert typeof _2 == "integer"
    assert _2        == 2

    const _3 = base.number("3.")
    assert typeof _3 == "float"
    assert _3        == 3

    const _0 = base.number(".")
    assert typeof _0 == "float"
    assert _0        == 0

    const _m0 = base.number("-.")
    assert typeof _m0 == "float"
    assert _m0        == 0

    const _0_5 = base.number(".5")
    assert typeof _0_5 == "float"
    assert _0_5        == 0.5
}

do {
    const number = "number"
    const value  = base[number](5)
    assert value        == 5
    assert typeof value == "integer"
}

##############################################################################
# base.integer

do {
    assert typeof base.integer           == "class"
    assert typeof base.integer.prototype == "object"
    assert base.integer instanceof base.function
    assert base.integer instanceof base.class
}

do {
    const number = base.integer()
    assert typeof number == "integer"
    assert number        == 0
}

do {
    const number = base.integer(10)
    assert typeof number == "integer"
    assert number        == 10
}

do {
    const number = base.integer(2.9)
    assert typeof number == "integer"
    assert number        == 2
}

do {
    assert base.integer(2.1)  == 2
    assert base.integer(1.9)  == 1
    assert base.integer(-0.9) == -1
    assert base.integer(-1.1) == -2
    assert base.integer(-1.9) == -2
}

do {
    expect_fail(()=>(3).square())

    base.integer.prototype.square = () => this * this

    assert (3).square() == 9

    expect_fail(()=>(3.0).square())
}

do {
    assert base.integer()     == 0
    assert base.integer(-5)   == -5
    assert base.integer(8.25) == 8
}

do {
    assert 0 instanceof base.integer
    assert 1 instanceof base.integer
    assert 0x7FFFFFFFFFFFFFFF instanceof base.integer
    assert ! (0.0 instanceof base.integer)
    assert ! (0 instanceof 0)
}

do {
    const value = (()=>42)()
    assert value instanceof base.integer
    assert value instanceof base.number
    assert value instanceof base.object
    assert ! (value instanceof base.float)
    assert ! (value instanceof base.string)
    assert ! (value instanceof base.boolean)
}

do {
    expect_fail(()=>base.integer(""))
    expect_fail(()=>base.integer("a"))
    expect_fail(()=>base.integer("e"))
    expect_fail(()=>base.integer("123x"))
    expect_fail(()=>base.integer("-"))
    expect_fail(()=>base.integer("--"))
    expect_fail(()=>base.integer("-E"))
    expect_fail(()=>base.integer("3."))
    expect_fail(()=>base.integer("."))
    expect_fail(()=>base.integer("-."))
    expect_fail(()=>base.integer(".5"))
    expect_fail(()=>base.integer({}))
    expect_fail(()=>base.integer([]))
    expect_fail(()=>base.integer(()=>void))
    expect_fail(()=>base.integer(false))
    expect_fail(()=>base.integer(void))

    const _1 = base.integer("1")
    assert typeof _1 == "integer"
    assert _1        == 1

    const _2 = base.integer("0x002")
    assert typeof _2 == "integer"
    assert _2        == 2
}

##############################################################################
# base.integer.prototype.hex

do {
    assert 0 .hex()   == "0x0"
    assert 1 .hex()   == "0x1"
    assert 18 .hex()  == "0x12"
    assert (-1).hex() == "0xffffffffffffffff"
    assert 0x7fffffffffffffff .hex() == "0x7fffffffffffffff"
    assert 0x781000000 .hex() == "0x781000000"
    assert 0xfedcba .hex() == "0xfedcba"
    assert 0x9876543210 .hex() == "0x9876543210"
    for var i = 0; i <= 16; i += 1 {
        assert 32 .hex(i) == "0x" + "20".zfill(i)
    }

    expect_fail(()=>1.2.hex())
    expect_fail(()=>"1".hex())
    expect_fail(()=>32 .hex(17))
    expect_fail(()=>32 .hex(-1))
}

##############################################################################
# base.float

do {
    assert typeof base.float           == "class"
    assert typeof base.float.prototype == "object"
    assert base.float instanceof base.function
    assert base.float instanceof base.class
}

do {
    const number = base.float()
    assert typeof number == "float"
    assert number        == 0
}

do {
    const number = base.float(10)
    assert typeof number == "float"
    assert number        == 10
}

do {
    const number = base.float(2.9)
    assert typeof number == "float"
    assert number        == 2.9
}

do {
    const number = base.float(4611686018427387904)
    assert typeof number == "float"
    assert number        == 4611686018427387904
}

do {
    assert base.float("+1") == 1
    assert base.float("1e0x10") == 10000000000000000
}

do {
    expect_fail(()=>(3.0).square3())

    base.float.prototype.square3 = () => this * this * this

    assert (3.0).square3() == 27

    expect_fail(()=>(3).square3())
}

do {
    assert base.float()     == 0
    assert base.float(3)    == 3
    assert base.float(-4.5) == -4.5
}

do {
    assert 0.0 instanceof base.float
    assert 0.5 instanceof base.float
    assert ! (0 instanceof base.float)
}

do {
    const value = (()=>42.0)()
    assert value instanceof base.float
    assert value instanceof base.number
    assert value instanceof base.object
    assert ! (value instanceof base.integer)
    assert ! (value instanceof base.string)
    assert ! (value instanceof base.boolean)
}

do {
    expect_fail(()=>base.float(""))
    expect_fail(()=>base.float("a"))
    expect_fail(()=>base.float("e"))
    expect_fail(()=>base.float("123x"))
    expect_fail(()=>base.float("-"))
    expect_fail(()=>base.float("--"))
    expect_fail(()=>base.float("-E"))
    expect_fail(()=>base.float("0x002"))
    expect_fail(()=>base.float({}))
    expect_fail(()=>base.float([]))
    expect_fail(()=>base.float(()=>void))
    expect_fail(()=>base.float(false))
    expect_fail(()=>base.float(void))

    expect_fail(()=>base.float("1.1.1"))

    const _1 = base.float("1")
    assert typeof _1 == "float"
    assert _1        == 1

    const _3 = base.float("3.")
    assert typeof _3 == "float"
    assert _3        == 3

    const _0 = base.float(".")
    assert typeof _0 == "float"
    assert _0        == 0

    const _m0 = base.float("-.")
    assert typeof _m0 == "float"
    assert _m0        == 0

    const _0_5 = base.float(".5")
    assert typeof _0_5 == "float"
    assert _0_5        == 0.5
}

##############################################################################
# void

do {
    assert typeof void == "void"
    expect_fail(fun {
        for const x in void { }
    })

    var count = 0
    for const x in base.deep(void) {
        count += 1
    }
    assert count == 0

    count = 0
    for const x in base.shallow(void) {
        count += 1
    }
    assert count == 0
}

do {
    const value = (()=>void)()
    assert ! (value instanceof base.object)
    assert ! (value instanceof base.integer)
    assert ! (value instanceof base.float)
    assert ! (value instanceof base.number)
    assert ! (value instanceof base.string)
    assert ! (value instanceof base.boolean)
}

##############################################################################
# base.boolean

do {
    assert typeof base.boolean           == "class"
    assert typeof base.boolean.prototype == "object"
    assert base.boolean instanceof base.function
    assert base.boolean instanceof base.class
}

do {
    assert base.boolean(true)
    assert ! base.boolean(false)
    assert base.boolean(3 + 4)
    assert ! base.boolean(5 - 5)
}

do {
    expect_fail(()=>false.negative())
    base.boolean.prototype.negative = ()=>!this
    assert false.negative()
    assert ! true.negative()
}

do {
    assert true  instanceof base.boolean
    assert false instanceof base.boolean
    assert ! (void instanceof base.boolean)

    const a = 10
    const b = 2 * 5
    assert (a == b) instanceof base.boolean
}

do {
    const value = (()=>false)()
    assert value instanceof base.boolean
    assert value instanceof base.object
    assert ! (value instanceof base.integer)
    assert ! (value instanceof base.float)
    assert ! (value instanceof base.number)
    assert ! (value instanceof base.string)
}

##############################################################################
# base.string

do {
    assert typeof base.string           == "class"
    assert typeof base.string.prototype == "object"
    assert base.string instanceof base.function
    assert base.string instanceof base.class
}

do {
    assert base.string()             == ""
    assert base.string(123)          == "123"
    assert base.string("x", 5, "z")  == "x5z"
    assert base.string()             == ""
    assert base.string(8)            == "8"
    assert base.string([], [])       == ""
    assert base.string([0x30, 0x41]) == "0A"
    assert base.string([0x100, 2])   == "\x{100}\x02"

    expect_fail(()=>base.string([void]))
    expect_fail(()=>base.string({}))
    expect_fail(()=>base.string(void))
    expect_fail(()=>base.string(false))
    expect_fail(()=>base.string(()=>void))
    expect_fail(()=>base.string([0x200000]))
    expect_fail(()=>base.string([-1]))
}

do {
    const elements = [0x1FFFFF, 1, 2, 3, 4, 5]
    const s        = base.string(elements)
    const size     = s.size
    assert typeof s == "string"
    assert size     == elements.size
    for var i = 0; i < size; i += 1 {
        assert s.code(i) == elements[i]
    }
}

do {
    const elements = [0x1FFFFF, 1, 2, 3, 4, 5, 6]
    const s        = base.string(elements)
    const size     = s.size
    assert typeof s == "string"
    assert size     == elements.size
    for var i = 0; i < size; i += 1 {
        assert s.code(i) == elements[i]
    }
}

do {
    expect_fail(()=>"x".add_2("y"))
    base.string.prototype.add_2 = x => this + x
    assert "x".add_2("y") == "xy"
}

do {
    const str = "123"
    assert str instanceof base.string
    assert str == "123"

    assert "x\(1)y" instanceof base.string
}

do {
    const value = (()=>"abc")()
    assert value instanceof base.string
    assert value instanceof base.object
    assert ! (value instanceof base.integer)
    assert ! (value instanceof base.float)
    assert ! (value instanceof base.number)
    assert ! (value instanceof base.boolean)
}

do {
    class ctor { }

    ctor.prototype = base.string.prototype

    const o = ctor()

    expect_fail(()=>o.size)
}

##############################################################################
# base.object

do {
    assert typeof base.object           == "class"
    assert typeof base.object.prototype == "object"
    assert base.object instanceof base.function
    assert base.object instanceof base.class
}

do {
    const o = base.object()
    assert typeof o == "object"

    o.prop1 = "xyz"
    assert o.prop1 == "xyz"
}

do {
    const o = base.object()
    assert typeof o == "object"

    o.prop2 = "xyz"
    assert o.prop2 == "xyz"
}

do {
    assert {} instanceof base.object
    assert ! ({} instanceof base.array)
    assert ! ({} instanceof base.function)
    assert ! ({} instanceof base.string)

    const o = base.object()
    assert o instanceof base.object
}

do {
    const value = (()=>{})()
    assert value instanceof base.object
    assert ! (value instanceof base.integer)
    assert ! (value instanceof base.float)
    assert ! (value instanceof base.number)
    assert ! (value instanceof base.boolean)
    assert ! (value instanceof base.string)
    assert ! (value instanceof base.array)
}

do {
    class constr {
        constructor {
            this.c = 2
            this.d = 3
            this.e = 4
        }
    }

    constr.prototype.a = 0
    constr.prototype.b = 1

    const obj = constr()

    var values = ["a", "b", "c", "d", "e"]

    for const key, value in base.deep(obj) {
        assert value == obj[key]
        if typeof value == "integer" && value >= 0 && value < values.size {
            assert values[value] == key
            values[value] = void
        }
    }

    for var i = 0; i < values.size; i += 1 {
        assert values[i] == void
    }

    values = ["a", "b", "c", "d", "e"]

    for const key, value in base.shallow(obj) {
        assert typeof value == "integer"
        assert value == obj[key]
        assert value >= 0 && value < values.size
        assert values[value] == key
        values[value] = void
    }
}

do {
    const it = base.shallow.apply({aaa:0}, [void])
    assert typeof it == "function"
    for const x, v in it {
        assert x == "aaa"
    }

    for const x, v in base.shallow.apply(void, [void]) {
        throw "unexpected property"
    }
}

do {
    class c {
        constructor {
            this.a = () => 1
        }
        b { return 2 }
    }

    const o = c()

    assert o.a() == 1
    assert o.b() == 2
    assert o instanceof c
    assert o instanceof base.object
}

do {
    class b {
        c { return 3 }
    }

    class c extends b {
        constructor {
            this.a = () => 1
        }
        b { return 2 }
    }

    const o = c()

    assert o.a() == 1
    assert o.b() == 2
    assert o.c() == 3
    assert o instanceof c
    assert o instanceof b
    assert o instanceof base.object
}

do {
    class c extends void {
        constructor {
            this.a = () => 1
        }
        b { return 2 }
    }

    const o = c()

    assert o.a() == 1
    assert o.b() == 2
    assert o instanceof c
    assert ! (o instanceof base.object)
}

##############################################################################
# base.array

do {
    assert typeof base.array           == "class"
    assert typeof base.array.prototype == "object"
    assert base.array instanceof base.function
    assert base.array instanceof base.class
}

do {
    const a = base.array()
    assert typeof a == "array"
    assert a.size   == 0
}

do {
    const a = base.array(1)
    assert a.size == 1
    assert a[0]   == 1
}

do {
    const a = base.array(-1)
    assert a.size == 1
    assert a[0] == -1
}

do {
    const a = base.array([8])
    assert typeof a    == "array"
    assert a.size      == 1
    assert typeof a[0] == "array"
    assert a[0].size   == 1
    assert a[0][0]     == 8
    expect_fail(()=>a[1])
}

do {
    const a = base.array("xy", true)
    assert typeof a == "array"
    assert a.size   == 2
    assert a[0]     == "xy"
    assert a[1]     == true
    expect_fail(()=>a[2])
}

do {
    const a = base.array(2.1)
    assert a.size == 1
    assert a[0]   == 2.1
}

do {
    const a = base.array(base.range(4)...)
    assert typeof a == "array"
    assert a.size   == 4
    for var i = 0; i < 4; i += 1 {
        assert a[i] == i
    }
}

do {
    const a = base.array(base.shallow({a: void, b: void, c: void})...)
    assert typeof a == "array"
    assert a.size   == 3
    const had = { "a": false, "b": false, "c": false }
    for var i = 0; i < a.size; i += 1 {
        const key, value = a[i]
        assert key == "a" || key == "b" || key == "c"
        assert ! had[key]
        had[key] = true
    }
}

do {
    expect_fail(fun {
        base.array.prototype = {}
    })
}

do {
    const a = [ "a", "b", "c", "d", "e" ]

    expect_fail(()=>a.ret_elem_3())

    base.array.prototype.ret_elem_3 = fun {
        return this[3]
    }

    assert a.ret_elem_3() == "d"
}

do {
    const a = base.array([10, 20]..., [30]...)
    assert a.size == 3
    assert a[0]     == 10
    assert a[1]     == 20
    assert a[2]     == 30
    expect_fail(()=>a[3])
}

do {
    assert [] instanceof base.array
    assert [] instanceof base.object
}

do {
    const value = (()=>[])()
    assert value instanceof base.array
    assert value instanceof base.object
    assert ! (value instanceof base.integer)
    assert ! (value instanceof base.float)
    assert ! (value instanceof base.number)
    assert ! (value instanceof base.boolean)
    assert ! (value instanceof base.string)
}

do {
    const a = [1, 2, 100]
    const b = base.array.apply(void, a)
    assert typeof b == "array"
    assert b        == a
    assert b.size   == a.size
    for var i = 0; i < b.size; i += 1 {
        assert b[i] == a[i]
    }
    b.push(0)
    assert b.size == a.size + 1
    assert b      != a
}

do {
    class fake_array { }

    fake_array.prototype = base.array.prototype

    const o = fake_array()

    assert typeof o == "object"
    assert o instanceof base.array
    expect_fail(()=>o.size)
    assert typeof o.resize == "function"
    expect_fail(()=>o.resize(10))
    expect_fail(()=>o[0])
}

do {
    const buf = base.buffer(10)
    const size = buf.size
    for var i = 0; i < size; i += 1 {
        buf[i] = i + 20
    }

    const a = base.array(buf...)

    assert a.size == 10

    var count = 0
    for var elem in a {
        assert elem == count + 20
        count += 1
    }
    assert count == 10
}

do {
    const a = base.array(base.buffer())

    assert typeof a    == "array"
    assert a.size      == 1
    assert typeof a[0] == "buffer"
    assert a[0].size   == 0
}

do {
    expect_fail(fun { [].reserve(-1) })
    expect_fail(fun { base.array.prototype.reserve(void, [0]) })

    const a = []
    a.reserve(100)
    assert a.size == 0
}

do {
    expect_fail(fun { base.array.prototype.push(0) })
    expect_fail(fun { base.array.prototype.pop() })
    expect_fail(fun { [].push.apply("", ["a"]) })
    expect_fail(fun { [].pop.apply("a", []) })

    const a = []
    assert a.push(1)       == 0
    assert a.push(2, 3, 4) == 1
    assert a.push(5)       == 4
    assert a.push(6)       == 5
    assert a.push()        == 6
    assert a.size          == 6

    assert a.size == 6
    assert a[0]   == 1
    assert a[1]   == 2
    assert a[2]   == 3
    assert a[3]   == 4
    assert a[4]   == 5
    assert a[5]   == 6

    assert a.pop() == 6
    assert a.size  == 5
    assert a[0]    == 1
    assert a[4]    == 5

    const b = a.pop(3)
    assert typeof b == "array"
    assert b.size   == 3
    assert b[0]     == 3
    assert b[1]     == 4
    assert b[2]     == 5
    assert a.size   == 2
    assert a[0]     == 1
    assert a[1]     == 2

    const c = a.pop(0)
    assert typeof c == "void"
    assert a.size   == 2

    expect_fail(()=>a.pop(3))
    assert a.size == 0

    assert [1, 2].pop() == 2

    expect_fail(()=>[].pop())
    expect_fail(()=>[1].pop(2))
    expect_fail(()=>[1].pop(-1))
}

##############################################################################
# base.array.prototype.slice

do {
    const a = []
    const b = a.slice(10, -20)

    assert typeof b == "array"
    assert b.size == 0
}

do {
    const a = [1, 2, 3, 4]
    const b = a.slice(1, -1)

    assert typeof b == "array"
    assert b.size == 2
    assert b[0] == 2
    assert b[1] == 3
}

do {
    const a = ["a", "b", "c", "d", "e"]

    do {
        const b = a.slice(void, void)
        assert b.size == 5
        assert b[0] == "a"
        assert b[-1] == "e"
    }

    do {
        const b = a.slice(2, void)
        assert b.size == 3
        assert b[0] == "c"
        assert b[-1] == "e"
    }

    do {
        const b = a.slice(void, -3)
        assert b.size == 2
        assert b[0] == "a"
        assert b[1] == "b"
    }

    do {
        expect_fail(()=>[].slice(0, false))
        expect_fail(()=>[].slice(false, 0))
    }
}

##############################################################################
# generic slice function

do {
    const obj = {
        slice: fun {
            return 42
        }
    }

    const x = obj[10:100]

    assert typeof x == "integer"
    assert x == 42
}
do {
    const obj = {
        slice: 10
    }

    # slice is not a function
    expect_fail(()=>obj[10:100])
}

##############################################################################
# base.array.prototype.insert (with array)

do {
    const a = [1, 2, 3, 4]
    const b = ["x", "y"]
    const c = a.insert(2, b)

    assert a == c
    assert a.size == 6
    assert a[0] == 1
    assert a[1] == 2
    assert a[2] == "x"
    assert a[3] == "y"
    assert a[4] == 3
    assert a[5] == 4
}

do {
    const a = [1, 2]
    const c = a.insert(0, a)

    assert a == c
    assert a.size == 4
    assert a[0] == 1
    assert a[1] == 2
    assert a[2] == 1
    assert a[3] == 2
}

do {
    const a = [1, 2]
    const c = a.insert(void, a)

    assert a == c
    assert a.size == 4
    assert a[0] == 1
    assert a[1] == 2
    assert a[2] == 1
    assert a[3] == 2
}

do {
    fun test_case(test)
    {
        test.args[-1] = test.args[-1] || test.array
        const out = [].insert.apply(test.array, test.args)
        const size = out.size
        assert out  == test.array
        assert size == test.result.size
        for var i = 0; i < size; i += 1 {
            assert out[i] == test.result[i]
        }
    }

    test_case({ array: [ 1, 2, 3 ], args: [   -4,       []           ], result: [ 1, 2, 3 ]           })
    test_case({ array: [ 1, 2, 3 ], args: [   -3,       []           ], result: [ 1, 2, 3 ]           })
    test_case({ array: [ 1, 2, 3 ], args: [    0,       []           ], result: [ 1, 2, 3 ]           })
    test_case({ array: [ 1, 2, 3 ], args: [    1,       []           ], result: [ 1, 2, 3 ]           })
    test_case({ array: [ 1, 2, 3 ], args: [   -2,       []           ], result: [ 1, 2, 3 ]           })
    test_case({ array: [ 1, 2, 3 ], args: [ void,       []           ], result: [ 1, 2, 3 ]           })
    test_case({ array: [ 1, 2, 3 ], args: [    4,       []           ], result: [ 1, 2, 3 ]           })
    test_case({ array: [ 1, 2, 3 ], args: [ void,    1, []           ], result: [ 2, 3 ]              })
    test_case({ array: [ 1, 2, 3 ], args: [    1,    2, []           ], result: [ 1, 3 ]              })
    test_case({ array: [ 1, 2, 3 ], args: [   -1, void, []           ], result: [ 1, 2 ]              })
    test_case({ array: [ 1, 2, 3 ], args: [ void, void, []           ], result: [ ]                   })
    test_case({ array: [ 1, 2, 3 ], args: [   -4,       [ "x" ]      ], result: [ "x", 1, 2, 3 ]      })
    test_case({ array: [ 1, 2, 3 ], args: [   -3,       [ "x" ]      ], result: [ "x", 1, 2, 3 ]      })
    test_case({ array: [ 1, 2, 3 ], args: [    0,       [ "x" ]      ], result: [ "x", 1, 2, 3 ]      })
    test_case({ array: [ 1, 2, 3 ], args: [    1,       [ "x" ]      ], result: [ 1, "x", 2, 3 ]      })
    test_case({ array: [ 1, 2, 3 ], args: [   -1,       [ "x" ]      ], result: [ 1, 2, "x", 3 ]      })
    test_case({ array: [ 1, 2, 3 ], args: [ void,       [ "x" ]      ], result: [ 1, 2, 3, "x" ]      })
    test_case({ array: [ 1, 2, 3 ], args: [    4,       [ "x" ]      ], result: [ 1, 2, 3, "x" ]      })
    test_case({ array: [ 1, 2, 3 ], args: [   -4,    1, [ "x" ]      ], result: [ "x", 2, 3 ]         })
    test_case({ array: [ 1, 2, 3 ], args: [ void,    1, [ "x" ]      ], result: [ "x", 2, 3 ]         })
    test_case({ array: [ 1, 2, 3 ], args: [   -2,    2, [ "x" ]      ], result: [ 1, "x", 3 ]         })
    test_case({ array: [ 1, 2, 3 ], args: [   -1, void, [ "x" ]      ], result: [ 1, 2, "x" ]         })
    test_case({ array: [ 1, 2, 3 ], args: [ void,    2, [ "x" ]      ], result: [ "x", 3 ]            })
    test_case({ array: [ 1, 2, 3 ], args: [    1, void, [ "x" ]      ], result: [ 1, "x" ]            })
    test_case({ array: [ 1, 2, 3 ], args: [ void, void, [ "x" ]      ], result: [ "x" ]               })
    test_case({ array: [ 1, 2, 3 ], args: [ void,    0, [ "x", "y" ] ], result: [ "x", "y", 1, 2, 3 ] })
    test_case({ array: [ 1, 2, 3 ], args: [ void,    1, [ "x", "y" ] ], result: [ "x", "y", 2, 3 ]    })
    test_case({ array: [ 1, 2, 3 ], args: [   -2,    2, [ "x", "y" ] ], result: [ 1, "x", "y", 3 ]    })
    test_case({ array: [ 1, 2, 3 ], args: [   -1, void, [ "x", "y" ] ], result: [ 1, 2, "x", "y" ]    })
    test_case({ array: [ 1, 2, 3 ], args: [   -1, void, [ "x", "y" ] ], result: [ 1, 2, "x", "y" ]    })
    test_case({ array: [ 1, 2, 3 ], args: [ void,    2, [ "x", "y" ] ], result: [ "x", "y", 3 ]       })
    test_case({ array: [ 1, 2, 3 ], args: [   -2, void, [ "x", "y" ] ], result: [ 1, "x", "y" ]       })
    test_case({ array: [ 1, 2, 3 ], args: [ void, void, [ "x", "y" ] ], result: [ "x", "y" ]          })
    test_case({ array: [ 1, 2, 3 ], args: [    0,       void         ], result: [ 1, 2, 3, 1, 2, 3 ]  })
    test_case({ array: [ 1, 2, 3 ], args: [    1,       void         ], result: [ 1, 1, 2, 3, 2, 3 ]  })
    test_case({ array: [ 1, 2, 3 ], args: [    2,       void         ], result: [ 1, 2, 1, 2, 3, 3 ]  })
    test_case({ array: [ 1, 2, 3 ], args: [ void,       void         ], result: [ 1, 2, 3, 1, 2, 3 ]  })
    test_case({ array: [ 1, 2, 3 ], args: [ void,    1, void         ], result: [ 1, 2, 3, 2, 3 ]     })
    test_case({ array: [ 1, 2, 3 ], args: [    1,    2, void         ], result: [ 1, 1, 2, 3, 3 ]     })
    test_case({ array: [ 1, 2, 3 ], args: [    2, void, void         ], result: [ 1, 2, 1, 2, 3 ]     })
    test_case({ array: [ 1, 2, 3 ], args: [ void,    2, void         ], result: [ 1, 2, 3, 3 ]        })
    test_case({ array: [ 1, 2, 3 ], args: [    1, void, void         ], result: [ 1, 1, 2, 3 ]        })
    test_case({ array: [ 1, 2, 3 ], args: [ void, void, void         ], result: [ 1, 2, 3 ]           })
}

do {
    expect_fail(()=>[].insert("", 0, []))
    expect_fail(()=>[].insert(0, "", []))
}

##############################################################################
# base.array.prototype.insert

do {
    const a = []

    a.insert(0, "abc")
    assert a.size == 3
    assert a[0]   == "a"
    assert a[2]   == "c"

    a.insert(void, base.buffer())
    assert a.size == 3
    assert a[0]   == "a"
    assert a[2]   == "c"

    const buf   = base.buffer(4)
    const size1 = buf.size
    for var i = 0; i < size1; i += 1 {
        buf[i] = buf.size - i
    }

    a.insert(void, buf)
    assert a.size == 7
    assert a[2]   == "c"
    assert a[3]   == 4
    assert a[6]   == 1

    const size2 = buf.size
    for var i = 0; i < size2; i += 1 {
        buf[i] = 10 + i
    }

    a[1:-1] = buf
    assert a.size == 6
    assert a[0]   == "a"
    assert a[1]   == 10
    assert a[2]   == 11
    assert a[3]   == 12
    assert a[4]   == 13
    assert a[5]   == 1
}

##############################################################################
# base.array.prototype.indices

do {
    const it = [ true, void, -2 ].indices()
    assert it() == 0
    assert it() == 1
    assert it() == 2
    expect_fail(()=>it())
}

##############################################################################
# base.array.prototype.fill

do {
    const a = base.array()
    a.resize(10)

    assert a.size == 10

    for var e in a {
        assert e == void
    }

    a.fill("abc")

    for var e in a {
        assert e == "abc"
    }

    a.fill(-3, 42)

    for var i = 0; i < a.size; i += 1 {
        if i < 7 {
            assert a[i] == "abc"
        }
        else {
            assert a[i] == 42
        }
    }

    const obj = { x : 1, y : 2 }
    a.fill(2, 8, obj)

    for var i = 0; i < a.size; i += 1 {
        if i < 2 {
            assert a[i] == "abc"
        }
        else if i < 8 {
            const e = a[i]
            assert typeof e == "object"
            assert e == obj
        }
        else {
            assert a[i] == 42
        }
    }

    expect_fail(()=>base.array.prototype.fill.apply(void, [1]))
    expect_fail(()=>a.fill())
}

##############################################################################
# base.string.prototype.indices

do {
    const it = "".indices()
    expect_fail(()=>it())
}
do {
    const it = "abcd".indices()
    assert it() == 0
    assert it() == 1
    assert it() == 2
    assert it() == 3
    expect_fail(()=>it())
}

##############################################################################
# base.string.prototype.ljust

do {
    assert "abcd".ljust(3)      == "abcd"
    assert "abcd".ljust(4)      == "abcd"
    assert "abcd".ljust(5)      == "abcd "
    assert "abcd".ljust(6, "x") == "abcdxx"

    expect_fail(()=>"abcd".ljust())
    expect_fail(()=>"abcd".ljust(1, ""))
    expect_fail(()=>"abcd".ljust(1, "oo"))
}

##############################################################################
# base.string.prototype.rjust

do {
    assert "abcd".rjust(3)      == "abcd"
    assert "abcd".rjust(4)      == "abcd"
    assert "abcd".rjust(5)      == " abcd"
    assert "abcd".rjust(6, "x") == "xxabcd"

    expect_fail(()=>"abcd".rjust())
    expect_fail(()=>"abcd".rjust(1, ""))
    expect_fail(()=>"abcd".rjust(1, "oo"))
}

##############################################################################
# base.string.prototype.zfill

do {
    assert "abcd".zfill(3)      == "abcd"
    assert "abcd".zfill(4)      == "abcd"
    assert "abcd".zfill(5)      == "0abcd"
    assert "abcd".zfill(6, "x") == "xxabcd"
    assert "--a".zfill(4, "*")  == "-*-a"
    assert "++b".zfill(5, "#")  == "+##+b"

    expect_fail(()=>"abcd".zfill())
    expect_fail(()=>"abcd".zfill(1, ""))
    expect_fail(()=>"abcd".zfill(1, "oo"))
}

##############################################################################
# base.function

do {
    assert base.function instanceof base.function
    assert base.function instanceof base.class
    assert ! (base.function instanceof base.generator)

    assert base.class instanceof base.function
    assert base.class instanceof base.class
    assert ! (base.class instanceof base.generator)

    assert base.generator instanceof base.function
    assert base.generator instanceof base.class
    assert ! (base.generator instanceof base.generator)

    expect_fail(base.class)
    expect_fail(base.generator)
    expect_fail(base.generator_end)

    fun regular_func
    {
    }

    assert regular_func instanceof base.function
    assert ! (regular_func instanceof base.class)
    assert ! (regular_func instanceof base.generator)

    fun generator_func
    {
        yield void
    }

    assert generator_func instanceof base.function
    assert ! (generator_func instanceof base.class)
    assert generator_func instanceof base.generator

    class constructor_func { }

    assert constructor_func instanceof base.function
    assert constructor_func instanceof base.class
    assert ! (constructor_func instanceof base.generator)

    assert ! ("prototype" in regular_func)
    assert ! ("prototype" in generator_func)
    assert "prototype" in constructor_func

    assert typeof constructor_func.prototype == "object"
    expect_fail(()=>regular_func.prototype)
    expect_fail(()=>generator_func.prototype)

    assert regular_func.name == "regular_func"
    var name_from_iter = void
    for const k, v in base.deep(regular_func) {
        if k == "name" {
            name_from_iter = base.stringify(v)
            break
        }
    }
    assert name_from_iter == "regular_func"
}

do {
    class empty { }
    class ctor { constructor { } }
    class noctor { a { } b { } }

    assert empty  instanceof base.function
    assert empty  instanceof base.class
    assert ctor   instanceof base.function
    assert ctor   instanceof base.class
    assert noctor instanceof base.function
    assert noctor instanceof base.class
}

do {
    const f = ()=>void
    assert f instanceof base.function
    assert f instanceof base.object
    assert ! (f instanceof base.integer)
    assert ! (f instanceof base.string)
    assert ! (f instanceof base.array)
}

do {
    const value = ()=>void
    assert value instanceof base.function
    assert value instanceof base.object
    assert ! (value instanceof base.integer)
    assert ! (value instanceof base.float)
    assert ! (value instanceof base.number)
    assert ! (value instanceof base.boolean)
    assert ! (value instanceof base.string)
    assert ! (value instanceof base.array)
}

do {
    const f1 = x => x + 1
    const f2 = x => x + 1
    const f3 = base.function(f1)
    assert f1 == f3
    assert f1 != f2
    assert f2 != f3
}

do {
    const f1 = fun { yield 0 }
    const f2 = base.function(f1)
    assert f1 == f2
}

do {
    const f1 = class { }
    const f2 = base.class(f1)
    assert f1 == f2
    expect_fail(()=>base.function(f1))
}

do {
    expect_fail(()=>base.function())
    expect_fail(()=>base.function(void))
    expect_fail(()=>base.function(0))
    expect_fail(()=>base.function(""))
    expect_fail(()=>base.function([]))
    expect_fail(()=>base.function({}))
}

##############################################################################
# Iterate over functions
do {
    fun func
    {
        return 42
    }

    class ctor {
        constructor {
            this.xyz = 42
        }
    }

    fun gen
    {
        yield 1
        yield 2
    }

    assert typeof func == "function"
    assert typeof ctor == "class"
    assert typeof gen  == "function"

    assert func instanceof base.function
    assert ctor instanceof base.class
    assert gen  instanceof base.generator

    const a = []
    for const x in func {
        a.push(x)
    }
    assert a.size == 1
    assert a[0] == func

    a.resize(0)
    for const x in func() {
        a.push(x)
    }
    assert a.size == 1
    assert a[0] == 42

    a.resize(0)
    for const x in ctor {
        a.push(x)
    }
    assert a.size == 1
    assert a[0] == ctor

    a.resize(0)
    for const x in ctor() {
        a.push(x)
    }
    assert a.size == 1
    assert typeof a[0] == "array"
    assert a[0][0] == "xyz"
    assert a[0][1] == 42

    a.resize(0)
    var except = void
    try {
        for const x in gen {
            a.push(x)
        }
    }
    catch const e {
        except = e
    }
    assert a.size == 0
    assert except != void

    a.resize(0)
    for const x in gen() {
        a.push(x)
    }
    assert a.size == 2
    assert a[0] == 1
    assert a[1] == 2
}

##############################################################################
# base.function.prototype.prototype

do {
    class ctor { }

    ctor.prototype = base.function.prototype

    const o = ctor()

    expect_fail(()=>o.prototype)
}

##############################################################################
# base.function.prototype.*statistics*

do {
    assert "name"         in base.function.prototype
    assert "registers"    in base.function.prototype
    assert "instructions" in base.function.prototype
    assert "size"         in base.function.prototype

    expect_fail(()=>base.function.prototype.name)
    expect_fail(()=>base.function.prototype.registers)
    expect_fail(()=>base.function.prototype.instructions)
    expect_fail(()=>base.function.prototype.size)

    fun f { }

    assert f.name         == "f"
    assert f.registers    == 1
    assert f.instructions == 2 # LOAD.VOID, RETURN
    assert f.size         == 5

    assert base.function.name         == "<builtin>"
    assert base.function.registers    == 0
    assert base.function.instructions == 0
    assert base.function.size         == 0
}

##############################################################################
# base.function.prototype.apply

do {
    fun method(arg)
    {
        return this + arg
    }

    assert method.apply(500, [70]) == 570

    expect_fail(()=>method.apply(void, []))
    expect_fail(()=>method.apply(void, void))
    expect_fail(()=>method.apply(void))
    expect_fail(()=>method.apply())
}

do {
    fun method
    {
        throw ""
    }

    expect_fail(()=>method.apply(void, []))
}

do {
    fun method(args...)
    {
        args.resize(1)
        args[0] = 123
    }

    const args = [1, 2, 3]
    method.apply(void, args)

    assert args.size == 3
    assert args[0]   == 1
    assert args[1]   == 2
    assert args[2]   == 3
}

do {
    class ctor {
        constructor {
            this.a = 42
        }
    }
    ctor.prototype.x = -1

    assert typeof ctor == "class"

    const co = ctor()
    assert typeof co == "object"
    assert "a" in co
    assert "x" in co
    assert co.a == 42
    assert co.x == -1
    assert co instanceof ctor

    const o = { b: 39 }
    assert typeof o == "object"
    assert ! ("a" in o)
    assert o.b == 39
    assert ! (o instanceof ctor)

    const ret = ctor.apply(o, [])
    assert ret == o
    assert "a" in o
    assert "b" in o
    assert ! ("x" in o)
    assert o.a == 42
    assert o.b == 39
    assert ret.a == 42
    assert ret.b == 39
    assert ! (o instanceof ctor)
    assert ! (ret instanceof ctor)
    expect_fail(()=>o.x)
    expect_fail(()=>ret.x)
}

do {
    expect_fail(fun {
        (()=>void) . apply . apply(void, [])
    })
}

do {
    const arg_list = [ 1, 2, 3 ]
    fun(args...) {
        args[0] = 4
        args[1] = 5
        args[2] = 6
    } . apply(void, arg_list)

    fun resize(args...) { args.resize(1) }

    for var i = 0; i < 3; i += 1 {
        resize(arg_list...)
    }
    for var i = 0; i < 3; i += 1 {
        resize.apply(void, arg_list)
    }
    for var i = 0; i < 3; i += 1 {
        resize(arg_list...)
        resize.apply(void, arg_list)
        resize(arg_list...)
        resize.apply(void, arg_list)
    }

    assert arg_list.size == 3
    assert arg_list[0] == 1
    assert arg_list[1] == 2
    assert arg_list[2] == 3
}

##############################################################################
# function constuctors

do {
    fun f
    {
    }

    class c
    {
    }

    fun g
    {
        yield void
    }

    assert f instanceof base.function
    assert ! (f instanceof base.class)
    assert ! (f instanceof base.generator)

    assert c instanceof base.function
    assert c instanceof base.class
    assert ! (c instanceof base.generator)

    assert g instanceof base.function
    assert ! (g instanceof base.class)
    assert g instanceof base.generator
}

##############################################################################
# base.generator.slice

do {
    fun primes
    {
        for const v in [2, 3, 5, 7, 11, 13, 17, 19] {
            yield v
        }
    }

    const all = [ primes()[:] ... ]
    assert typeof all == "array"
    assert all.size   == 8
    assert all[0]     == 2
    assert all[1]     == 3
    assert all[2]     == 5
    assert all[3]     == 7
    assert all[4]     == 11
    assert all[5]     == 13
    assert all[6]     == 17
    assert all[7]     == 19

    const some4 = [ primes()[3:7] ... ]
    assert typeof some4 == "array"
    assert some4.size   == 4
    assert some4[0]     == 7
    assert some4[1]     == 11
    assert some4[2]     == 13
    assert some4[3]     == 17

    const somend = [ primes()[5:] ... ]
    assert typeof somend == "array"
    assert somend.size   == 3
    assert somend[0]     == 13
    assert somend[1]     == 17
    assert somend[2]     == 19

    const negative1 = primes()[-5:5]
    assert typeof negative1 == "array"
    assert negative1.size   == 2
    assert negative1[0]     == 7
    assert negative1[1]     == 11

    const negative2 = primes()[:-6]
    assert typeof negative2 == "array"
    assert negative2.size   == 2
    assert negative2[0]     == 2
    assert negative2[1]     == 3
}

##############################################################################
# base.exception

do {
    assert typeof base.exception == "class"
    assert base.exception instanceof base.function
    assert base.exception instanceof base.class
}

do {
    var line      = void
    var exception = void
    assert ! exception
    try {
        line = __line__ ; base.exception()
        assert false
    }
    catch const e {
        exception = e
    }
    assert exception
    assert exception instanceof base.exception
    assert exception.backtrace.size    == 2
    assert exception.backtrace[1].line == line
}

do {
    var exception = void
    assert ! (exception instanceof base.exception)
    try {
        throw void
    }
    catch const e {
        exception = e
    }
    assert exception instanceof base.exception
}

do {
    var ex = void
    try {
        base.exception(42.0)
    }
    catch const e {
        ex = e.value
    }
    assert typeof ex == "float"
    assert ex == 42
}

##############################################################################
# instanceof buffer

do {
    const value = base.buffer()
    assert value instanceof base.buffer
    assert value instanceof base.object
    assert ! (value instanceof base.integer)
    assert ! (value instanceof base.float)
    assert ! (value instanceof base.number)
    assert ! (value instanceof base.boolean)
    assert ! (value instanceof base.string)
    assert ! (value instanceof base.array)

    assert base.buffer instanceof base.function
    assert base.buffer instanceof base.class
}

##############################################################################
# resize

do {
    expect_fail(()=>[].resize(-1))
    expect_fail(()=>base.buffer().resize(-1))
}

##############################################################################
# class selection

do {
    fun new_type(type, args...)
    {
        return base[type].apply(void, args)
    }

    const a = new_type("array", "xy"..., 2)
    assert typeof a == "array"
    assert a.size   == 3
    assert a[0]     == "x"
    assert a[1]     == "y"
    assert a[2]     == 2

    const i = new_type("integer")
    assert typeof i == "integer"
    assert i        == 0

    const n = new_type("number", "1.5")
    assert typeof n == "float"
    assert n        == 1.5

    const o = new_type("object")
    assert typeof o == "object"

    const s = new_type("string", 1, "x", 2)
    assert typeof s == "string"
    assert s        == "1x2"

    for const type in ["integer", "float", "string", "boolean", "object", "array"] {
        assert typeof new_type(type) == type
    }
}

##############################################################################
# base.shallow

do {
    const obj  = { a: 42, b: 43, c: 44 }
    const iter = base.shallow(obj)

    var key, value = iter()
    assert key == "a" || key == "b" || key == "c"
    assert value == 42 || value == 43 || value == 44

    key, value = iter()
    assert key == "a" || key == "b" || key == "c"
    assert value == 42 || value == 43 || value == 44

    key, value = iter()
    assert key == "a" || key == "b" || key == "c"
    assert value == 42 || value == 43 || value == 44

    expect_fail(()=>iter())
}

do {
    expect_fail(()=>base.shallow({})())
    expect_fail(()=>base.shallow([1])())
    expect_fail(()=>base.shallow(1)())
    expect_fail(()=>base.shallow("1")())
    expect_fail(()=>base.shallow(true)())
    expect_fail(()=>base.shallow(void)())

    var count = 0
    for const n in base.shallow(()=>void) {
        count += 1
    }
    assert count == 0

    count = 0
    for const n, v in base.shallow({xyz:void}) {
        assert n == "xyz"
        count += 1
    }
    assert count == 1
}

##############################################################################
# base.range

do {
    expect_fail(base.range)
}

do {
    const iter = base.range(5)
    assert iter() == 0
    assert iter() == 1
    assert iter() == 2
    assert iter() == 3
    assert iter() == 4
    expect_fail(iter)
}

do {
    const iter = base.range(6, 9)
    assert iter() == 6
    assert iter() == 7
    assert iter() == 8
    expect_fail(iter)
}

do {
    const iter = base.range(-10, -5)
    assert iter() == -10
    assert iter() == -9
    assert iter() == -8
    assert iter() == -7
    assert iter() == -6
    expect_fail(iter)
}

do {
    const iter = base.range(10, 5)
    expect_fail(iter)
}

do {
    const iter = base.range(-2, 5, 2)
    assert iter() == -2
    assert iter() == 0
    assert iter() == 2
    assert iter() == 4
    expect_fail(iter)
}

do {
    const iter = base.range(10, 0, -3)
    assert iter() == 10
    assert iter() == 7
    assert iter() == 4
    assert iter() == 1
    expect_fail(iter)
}

##############################################################################
# base.map

do {
    const iter = base.map(()=>void, [])
    assert typeof iter == "function"
    expect_fail(iter)
}

do {
    const f = base.map(x => x)
    assert typeof f == "function"
    const iter = f(["a", "b"])
    assert typeof f == "function"
    assert iter() == "a"
    assert iter() == "b"
    expect_fail(iter)
}

do {
    const iter = base.map(x => x * 10, [2, 3, 4])
    assert typeof iter == "function"
    assert iter()      == 20
    assert iter()      == 30
    assert iter()      == 40
    expect_fail(iter)
}

do {
    const iter = base.map(x=>x+5)(base.range(1, 3))
    assert typeof iter == "function"
    assert iter()      == 6
    assert iter()      == 7
    expect_fail(iter)
}

do {
    const iter = [1, 2, 3].map(x=>-x)
    assert typeof iter == "function"
    assert iter()      == -1
    assert iter()      == -2
    assert iter()      == -3
    expect_fail(iter)
}

do {
    const iter = "mno".map(x => x + "_")
    assert typeof iter == "function"
    assert iter()      == "m_"
    assert iter()      == "n_"
    assert iter()      == "o_"
    expect_fail(iter)
}

do {
    const iter = false.map(x => !x)
    assert typeof iter == "function"
    assert iter()      == true
    expect_fail(iter)
}

##############################################################################
# base.filter

do {
    const iter = base.filter(()=>true, [])
    expect_fail(iter)
}

do {
    const iter = base.filter(()=>false, [1, 2, 3])
    expect_fail(iter)
}

do {
    const iter = base.filter(x => x & 1, base.range(10))
    assert typeof iter == "function"
    assert iter()      == 1
    assert iter()      == 3
    assert iter()      == 5
    assert iter()      == 7
    assert iter()      == 9
    expect_fail(iter)
}

do {
    const iter = [5, 6, 7].filter(x => x != 6)
    assert typeof iter == "function"
    assert iter()      == 5
    assert iter()      == 7
    expect_fail(iter)
}

do {
    const result = []
    for var elem in base.range(5) ->
                    base.map(x => (x - 2) * 10) ->
                    base.filter(x => x > 0) {
        result.insert(result.size, elem)
    }
    assert result.size == 2
    assert result[0]   == 10
    assert result[1]   == 20
}

##############################################################################
# base.reduce

do {
    const result = base.reduce((x, y)=>x + y, 42, [])
    assert result == 42
}

do {
    const result = base.reduce((x, y)=>x + y, 0, [10])
    assert result == 10
}

do {
    const result = base.reduce((x, y)=>x + y, 1, [2000, 300, 70, 5])
    assert result == 2376
}

do {
    fun fib_elem(elem)
    {
        var prev = 0
        return base.range(1, elem).reduce(fun(accum) {
            const y = prev
            prev    = accum
            return accum + y
        }, 1)
    }

    # 11th element of Fibonacci series
    assert fib_elem(11) == 89
}

do {
    fun fib_on_range
    {
        var prev = 0
        return base.reduce(fun(accum) {
            const y = prev
            prev    = accum
            return accum + y
        }, 1)
    }

    # 12th elem of Fibonacci series
    assert fib_on_range()(base.range(1, 12)) == 144
}

do {
    const result = [1, 2, 3, 4].reduce((x, y)=>x+y, 0)
    assert result == 10
}

do {
    const count = [1, 2, 3, 1, 4, 5, 1, 6, 1, 7].reduce((x, y) => x + (y == 1 ? 1 : 0), 0)
    assert count == 4
}

##############################################################################
# base.sum

do {
    assert base.sum([]) == 0
    assert base.sum([], "") == ""
    assert base.sum([10, 200, 3, 4000]) == 4213
    assert base.sum([4.0, 2.0, 8.0]) == 14.0
    assert base.sum(["ab", "c", "def", "gh"], "") == "abcdefgh"

    expect_fail(base.sum)
    expect_fail(() => base.sum(void))
    expect_fail(()=>base.sum([1], ""))
}

##############################################################################
# base.count

do {
    assert base.count(void, []            ) == 0
    assert base.count("",   [1, 2]        ) == 0
    assert base.count(4,    base.range(10)) == 1
    assert base.count("a",  "abcadefagh"  ) == 3

    assert "Hello, World!".count("l") == 3

    assert base.keys({x: 8, _test_value: 8, y: 8}).count("_test_value") == 1

    assert fun {
        for var i = 0; i < 100; i += 1 {
            yield i / 4
        }
    } () . count(11) == 4

    assert base.count(x => x > 5, [ 1, 7, 2, 6, 5 ]) == 2

    # Count lowercase letters
    assert "ThIs Is A MiXeD StRiNg".filter(x => x.code() >= 97).count() == 8
}

##############################################################################
# base.all

do {
    assert base.all(1, [1, 1.0, 1]) == true
    assert base.all(1, [0, 1, 2])   == false
    assert base.all(x => x > 2, [ 4, 3, 5 ]) == true
    assert base.all(x => x > 2, [ 4, 2, 5 ]) == false
}

##############################################################################
# base.any

do {
    assert base.any(1, [ 0, 2, 3, 4 ]) == false
    assert base.any(2, [ 0, 2, 3, 4 ]) == true
    assert base.any(2, [ 0, 2, 3, 2 ]) == true
    assert base.any(x => x == void, [ 1, 2, 3, 4 ]) == false
    assert base.any(x => x == 3,    [ 1, 2, 3, 4 ]) == true
}

##############################################################################
# base.method

do {
    const o = {
        _i : 0,
        add : fun(x) { const v = this._i ; this._i = v + x ; return v },
        sub : fun(x) { const v = this._i ; this._i = v - x ; return v }
    }

    assert o.add(1) == 0
    assert o._i     == 1

    const m = base.method(o, o.add)
    assert typeof m == "function"

    assert m(2) == 1
    assert o._i == 3
    assert m(1) == 3
    assert o._i == 4

    delete o.add

    expect_fail(()=>o.add(1))

    assert m(3) == 4
    assert o._i == 7

    const ms = base.method(o, "sub")
    assert typeof ms == "function"

    assert ms(1) == 7
    assert o._i  == 6

    assert ms(3) == 6
    assert o._i  == 3

    expect_fail(()=>base.method(o, "_i"))
    expect_fail(()=>base.method(o, "non existent"))
    expect_fail(()=>base.method(o, o._i))
}

##############################################################################
# base.keys

do {
    fun gen
    {
        yield [40, -40]
        yield [-40, 50]
        yield [700, 8]
    }

    const it0 = gen()
    assert it0()[0] == 40
    assert it0()[0] == -40
    assert it0()[0] == 700
    expect_fail(it0)

    const it = base.keys(gen())
    assert it() == 40
    assert it() == -40
    assert it() == 700
    expect_fail(it)
}

do {
    const obj = { "0" : 10, "1" : 200, "2" : 3000, "3" : 4000 }
    const a = [ false, false, false, false ]
    for const key in base.keys(obj) {
        assert typeof key == "string"
        const value = base.integer(key)
        assert value >= 0 && value <= 3
        assert ! a[value]
        a[value] = true
    }
    for const value in a {
        assert typeof value == "boolean"
        assert value
    }
}

do {
    fun gen
    {
        const it = base.range(4)
        loop { yield it }
    }

    const it = base.keys(gen())
    assert it() == 0
    assert it() == 1
    assert it() == 2
    assert it() == 3
    expect_fail(it)
}

do {
    const a  = [ base.range(10, 20),
                 base.range(5, 6),
                 base.range(-100, -200, -1) ]
    const it = base.keys(a)
    assert it() == 10
    assert it() == 5
    assert it() == -100
    expect_fail(it)
}

do {
    const a = [ [1, 2], [3], [4, 5], [], [6] ]
    const it = base.keys(a)
    assert it() == 1
    assert it() == 3
    assert it() == 4
    expect_fail(it)
    expect_fail(it)
}

##############################################################################
# base.stringify

do {
    assert base.stringify()              == ""
    assert base.stringify("a")           == "a"
    assert base.stringify(false)         == "false"
    assert base.stringify(true)          == "true"
    assert base.stringify(void)          == "void"
    assert base.stringify(1)             == "1"
    assert base.stringify(1.5)           == "1.5"
    assert base.stringify([])            == "[]"
    assert base.stringify([1])           == "[1]"
    assert base.stringify([2, 33, 444])  == "[2, 33, 444]"
    assert base.stringify(["true",true]) == "[\"true\", true]"

    assert base.stringify(false, 2, "o") == "false2o"
}

##############################################################################
# base.hex

do {
    assert base.hex(42) == "0x2a"

    expect_fail(()=>base.hex(3.5))
}

##############################################################################
# base.array.prototype.sort

do {
    const a = []
    const b = a.sort()
    assert typeof b == "array"
    assert b == a
    assert a == []
}

do {
    const a = ["x"]
    const b = a.sort()
    assert typeof b == "array"
    assert b == a
    assert a.size == 1
    assert a[0] == "x"
}

do {
    const a = [3, 10, 5, 1]
    const b = a.sort(true)
    assert a == b
    assert a[0] == 10
    assert a[1] == 5
    assert a[2] == 3
    assert a[3] == 1
    assert b[0] == 10
    assert b[1] == 5
    assert b[2] == 3
    assert b[3] == 1
}

do {
    const a = ["base", 101, "array", 42, 60, "sort", -10, "size"]
    const b = a.sort(x => typeof x, true)
    assert a == b
    assert a[0] == "size"
    assert a[1] == "sort"
    assert a[2] == "array"
    assert a[3] == "base"
    assert a[4] == -10
    assert a[5] == 60
    assert a[6] == 42
    assert a[7] == 101
}

do {
    const a = ["base", 101, "array", 42, 60, "sort", -10, "size"]
    const b = a.sort(x => typeof x)
    assert a == b
    assert a[0] == 101
    assert a[1] == 42
    assert a[2] == 60
    assert a[3] == -10
    assert a[4] == "base"
    assert a[5] == "array"
    assert a[6] == "sort"
    assert a[7] == "size"
}

##############################################################################
# base.sort

do {
    const empty = []
    const a = base.sort(empty)
    assert typeof a == "array"
    assert a.size == 0
    assert a == empty

    empty.push(0)
    assert empty.size == 1
    assert a.size == 0
}

do {
    fun empty
    {
        if false { yield void }
    }

    const a = base.sort(false, empty())
    assert typeof a == "array"
    assert a.size == 0
}

do {
    const a = [8]
    const b = base.sort(a)
    assert a.size == 1
    assert a[0] == 8
    assert a == b
    a.push(0)
    assert a.size == 2
    assert b.size == 1
    assert b[0] == 8
}

do {
    const a = [0, 1]
    const b = base.sort(a)
    assert typeof b == "array"
    assert a == b
    assert b.size == 2
    assert b[0] == 0
    assert b[1] == 1
    b.push(2)
    assert b.size == a.size + 1
}

do {
    const a = [0, 1]
    const b = base.sort(true, a)
    a.push(2)
    assert typeof b == "array"
    assert b.size == 2
    assert b[0] == 1
    assert b[1] == 0
}

do {
    const a = [1, 0]
    const b = base.sort(a)
    assert typeof b == "array"
    assert a != b
    assert b.size == 2
    assert b[0] == 0
    assert b[1] == 1
}

do {
    const a = [1, 1]
    const b = base.sort(a)
    assert typeof b == "array"
    assert a == b
    assert b.size == 2
    assert b[0] == 1
    assert b[1] == 1
    b.push(0)
    assert b.size == a.size + 1
}

do {
    const a = [1, 2, 3]
    const b = base.sort(a)
    assert typeof b == "array"
    assert a == b
    a[1] = 0
    assert b.size == 3
    assert b[0] == 1
    assert b[1] == 2
    assert b[2] == 3
}

do {
    const a = [3, 2, 1]
    const b = base.sort(a)
    assert typeof b == "array"
    assert a != b
    assert b.size == 3
    assert b[0] == 1
    assert b[1] == 2
    assert b[2] == 3
}

do {
    const a = [1, 3, 2]
    const b = base.sort(a)
    assert typeof b == "array"
    assert a != b
    assert b.size == 3
    assert b[0] == 1
    assert b[1] == 2
    assert b[2] == 3
}

do {
    const a = [3, 3, 2]
    const b = base.sort(a)
    assert typeof b == "array"
    assert a != b
    assert b.size == 3
    assert b[0] == 2
    assert b[1] == 3
    assert b[2] == 3
}

do {
    const a = [2, 2, 2]
    const b = base.sort(a)
    assert typeof b == "array"
    assert a == b
    a[0] = 0
    assert b.size == 3
    assert b[0] == 2
    assert b[1] == 2
    assert b[2] == 2
}

do {
    class sortable {
        constructor(key) {
            this.key = key
        }
    }

    const a = [ sortable(40), sortable(20), sortable(30), sortable(10), sortable(25) ]
    const b = base.sort(x => x.key, a)
    assert b[0].key == 10
    assert b[1].key == 20
    assert b[2].key == 25
    assert b[3].key == 30
    assert b[4].key == 40
}

do {
    class sortable {
        constructor(key) {
            this.key = key
        }
    }

    const a = [ sortable(40), sortable(20), sortable(30), sortable(10), sortable(25) ]
    const b = base.sort(x => x.key, true, a)
    assert b[0].key == 40
    assert b[1].key == 30
    assert b[2].key == 25
    assert b[3].key == 20
    assert b[4].key == 10
}

do {
    const a = [ 5, 4, 2, 3, 1 ]
    const s = base.sort(a)
    assert typeof s == "array"
    assert s.size == 5
    assert s[0] == 1
    assert s[1] == 2
    assert s[2] == 3
    assert s[3] == 4
    assert s[4] == 5
    assert a.size == 5
    assert a[0] == 5
    assert a[1] == 4
    assert a[2] == 2
    assert a[3] == 3
    assert a[4] == 1
}

do {
    const s = base.sort("foobar")
    assert typeof s == "array"
    assert s.size == 6
    assert s[0] == "a"
    assert s[1] == "b"
    assert s[2] == "f"
    assert s[3] == "o"
    assert s[4] == "o"
    assert s[5] == "r"
}

do {
    const s = base.sort(true, "fooba")
    assert typeof s == "array"
    assert s.size == 5
    assert s[0] == "o"
    assert s[1] == "o"
    assert s[2] == "f"
    assert s[3] == "b"
    assert s[4] == "a"
}

do {
    const s = [10, 11, 9, 8] -> base.sort
    assert typeof s == "array"
    assert s.size == 4
    assert s[0] == 8
    assert s[1] == 9
    assert s[2] == 10
    assert s[3] == 11
}

do {
    const s = [10, 11, 9, 8] -> base.sort(true)
    assert typeof s == "array"
    assert s.size == 4
    assert s[0] == 11
    assert s[1] == 10
    assert s[2] == 9
    assert s[3] == 8
}

do {
    const it = [30, 1, 20, -2] -> base.sort -> base.map(x => x + 1)
    assert typeof it == "function"
    assert it() == -1
    assert it() == 2
    assert it() == 21
    assert it() == 31
    expect_fail(it)
}

# Order of "equal" elements must be preserved
do {
    const input = ["020", 1, 20, "21", 5, 3, "0020", "8", "5", "05", "0001"]
    const a = base.sort(x => base.integer(x), input)
    assert typeof a == "array"
    assert a.size == 11
    assert a[0]   == 1
    assert a[1]   == "0001"
    assert a[2]   == 3
    assert a[3]   == 5
    assert a[4]   == "5"
    assert a[5]   == "05"
    assert a[6]   == "8"
    assert a[7]   == "020"
    assert a[8]   == 20
    assert a[9]   == "0020"
    assert a[10]  == "21"
}

##############################################################################
# base.args

do {
    assert typeof base.args == "array"
    assert base.args.size   == 1
    assert base.args[0].ends_with("module_base.kos")
}

##############################################################################
# base.thread

do {
    expect_fail(base.thread)

    const o = { t1: 0, t2: 0, done: false }

    fun thread1
    {
        while ! o.t2 { }
        o.t1 += 1
    }

    fun thread2
    {
        while ! o.done { }
        o.t2 += 1
        while ! o.t1 { }
    }

    const t1 = thread1.async(void, [])
    const t2 = thread2.async(void, [])

    assert t1 instanceof base.thread
    assert t1 instanceof base.object
    assert t2 instanceof base.thread
    assert t2 instanceof base.object

    o.done = true
    t1.wait()
    t2.wait()

    assert o.t1 == 1
    assert o.t2 == 1
}

do {
    fun sum(a, b)
    {
        return a + b
    }

    const t = sum.async(void, [10, 24]);

    assert t instanceof base.thread

    const result = t.wait()

    assert result == 34

    expect_fail(()=>t.wait())
}

do {
    fun thread(a)
    {
        return a * 10
    }

    assert thread(-42) == -420

    do {
        const t = thread.async(void, [2])
        assert t.wait() == 20
    }

    do {
        const t = thread.async(void, [123])
        assert t.wait() == 1230
    }
}

do {
    fun thread
    {
        throw "something"
    }

    const t = thread.async(void, [])
    var   e = void
    try {
        t.wait()
    }
    catch const exc {
        e = exc
    }
    assert typeof e == "object"
    assert e.value == "something"
}

do {
    var t       = void
    var done    = false
    var success = false

    fun thread(wait)
    {
        defer { done = true }
        while ! t { }
        if wait {
            t.wait()
        }
        success = true
    }

    # Normal invocation
    t = thread.async(void, [false])
    assert t instanceof base.thread
    while ! done { }
    t.wait()
    assert success
    t       = void
    success = false
    done    = false

    # Exception inside thread
    t = thread.async(void, [true])
    assert t instanceof base.thread
    while ! done { }
    var e = void
    try { t.wait() } catch const exc { e = exc }
    assert ! success
    assert e != void
    t       = void
    success = false
    done    = false

    # Incorrect number of args (not even called)
    e = void
    t = thread.async(void, [])
    assert t instanceof base.thread
    try { t.wait() } catch const exc { e = exc }
    assert ! done
    assert ! success
    assert e != void
}

do {
    var x = void
    const t = base.function.async.apply(fun { x = 42; return 4.2 }, [void, []])
    assert t.wait() == 4.2
    assert x == 42

    expect_fail(() => base.function.async.apply(void, [void, []]))
    expect_fail(() => base.function.async.apply(1, [void, []]))
    expect_fail(() => base.function.async.apply("", [void, []]))
    expect_fail(() => fun {} . async(void))
    expect_fail(() => fun {} . async())
    expect_fail(() => fun {} . async(void, {}))
    expect_fail(() => fun {} . async(void, void))
    expect_fail(() => fun {} . async(void, -42))
    expect_fail(() => fun {} . async(void, "42"))
}

do {
    const obj = { }
    assert ! ("xyz" in obj)

    fun fff
    {
        this.xyz = "42"
    }

    const t = fff.async(obj, [])
    t.wait()

    assert "xyz" in obj
    assert obj.xyz == "42"
}

##############################################################################
# base.count_elements

do {
    assert (["a", "b", "c"] -> base.count_elements) == 3
    expect_fail(() => void -> base.count_elements)
}

##############################################################################
# base.enumerate

do {
    const it = base.enumerate(["abc", 3, 10.5, false])
    for const pair in [ [0, "abc"], [1, 3], [2, 10.5], [3, false] ] {
        const result = it()
        assert result.size == 2
        assert pair[0] == result[0]
        assert pair[1] == result[1]
    }
    expect_fail(it)
}

do {
    const it = base.enumerate(fun {
        yield "first"
        yield "Second"
        yield "thirD"
    }())
    for const pair in [ [0, "first"], [1, "Second"], [2, "thirD"] ] {
        const result = it()
        assert result.size == 2
        assert pair[0] == result[0]
        assert pair[1] == result[1]
    }
    expect_fail(it)
}

##############################################################################
# base.zip

do {
    expect_fail(base.zip)

    var i = 0
    for const ret in base.zip(base.range(10)) {
        assert ret == i
        i += 1
    }

    const expected = [ ["a", 1], ["b", 2], ["c", 3] ]
    i = 0
    for const x, y in base.zip("abcd", base.range(1, 4)) {
        assert x == expected[i][0]
        assert y == expected[i][1]
        i += 1
    }

    i = 0
    for const x, y in base.zip("abc", base.range(1, 10)) {
        assert x == expected[i][0]
        assert y == expected[i][1]
        i += 1
    }

    const strings = [ "kos", "sok", "cat", "dog" ]
    i = 0
    for const a, b, c in base.zip("kscd", "ooaoo", "sktg") {
        assert a + b + c == strings[i]
        i += 1
    }
}

##############################################################################
# base.each

do {
    var sum = 0

    fun update_sum(x)
    {
        sum += x
    }

    base.each(update_sum, [1, 300, 20])

    assert sum == 321

    sum = 0;

    [40, 500, 6000] -> base.each(update_sum)

    assert sum == 6540

    sum = 0;

    [100, 20, 3] -> base.map(x => update_sum(x)) -> base.each()

    assert sum == 123
}
