#
# Copyright (c) 2014-2020 Chris Dragan
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.
#

import base
import test_tools.expect_fail

##############################################################################
# base.number

do {
    assert typeof base.number           == "class"
    assert typeof base.number.prototype == "object"
    assert base.number instanceof base.function
    assert base.number instanceof base.class
}

do {
    const number = base.number()
    assert typeof number == "integer"
    assert number        == 0
}

do {
    const number = base.number(101)
    assert typeof number == "integer"
    assert number        == 101
}

do {
    const number = base.number(10.1)
    assert typeof number == "float"
    assert number        == 10.1
}

do {
    expect_fail(()=>(1).times_three())
    expect_fail(()=>(1.5).times_three())

    base.number.prototype.times_three = () => this*3

    const i = (5).times_three()
    assert typeof i == "integer"
    assert i        == 15

    const f = (5.0).times_three()
    assert typeof f == "float"
    assert f        == 15
}

do {
    expect_fail(()=>base.number(""))
    expect_fail(()=>base.number("a"))
    expect_fail(()=>base.number("e"))
    expect_fail(()=>base.number("123x"))
    expect_fail(()=>base.number("-"))
    expect_fail(()=>base.number("--"))
    expect_fail(()=>base.number("-E"))
    expect_fail(()=>base.number({}))
    expect_fail(()=>base.number([]))
    expect_fail(()=>base.number(()=>void))
    expect_fail(()=>base.number(false))
    expect_fail(()=>base.number(void))

    const _1 = base.number("1")
    assert typeof _1 == "integer"
    assert _1        == 1

    const _2 = base.number("0x002")
    assert typeof _2 == "integer"
    assert _2        == 2

    const _3 = base.number("3.")
    assert typeof _3 == "float"
    assert _3        == 3

    const _0 = base.number(".")
    assert typeof _0 == "float"
    assert _0        == 0

    const _m0 = base.number("-.")
    assert typeof _m0 == "float"
    assert _m0        == 0

    const _0_5 = base.number(".5")
    assert typeof _0_5 == "float"
    assert _0_5        == 0.5
}

do {
    const number = "number"
    const value  = base[number](5)
    assert value        == 5
    assert typeof value == "integer"
}

##############################################################################
# base.integer

do {
    assert typeof base.integer           == "class"
    assert typeof base.integer.prototype == "object"
    assert base.integer instanceof base.function
    assert base.integer instanceof base.class
}

do {
    const number = base.integer()
    assert typeof number == "integer"
    assert number        == 0
}

do {
    const number = base.integer(10)
    assert typeof number == "integer"
    assert number        == 10
}

do {
    const number = base.integer(2.9)
    assert typeof number == "integer"
    assert number        == 2
}

do {
    assert base.integer(2.1)  == 2
    assert base.integer(1.9)  == 1
    assert base.integer(-0.9) == -1
    assert base.integer(-1.1) == -2
    assert base.integer(-1.9) == -2
}

do {
    expect_fail(()=>(3).square())

    base.integer.prototype.square = () => this * this

    assert (3).square() == 9

    expect_fail(()=>(3.0).square())
}

do {
    assert base.integer()     == 0
    assert base.integer(-5)   == -5
    assert base.integer(8.25) == 8
}

do {
    assert 0 instanceof base.integer
    assert 1 instanceof base.integer
    assert 0x7FFFFFFFFFFFFFFF instanceof base.integer
    assert ! (0.0 instanceof base.integer)
    assert ! (0 instanceof 0)
}

do {
    const value = (()=>42)()
    assert value instanceof base.integer
    assert value instanceof base.number
    assert value instanceof base.object
    assert ! (value instanceof base.float)
    assert ! (value instanceof base.string)
    assert ! (value instanceof base.boolean)
}

do {
    expect_fail(()=>base.integer(""))
    expect_fail(()=>base.integer("a"))
    expect_fail(()=>base.integer("e"))
    expect_fail(()=>base.integer("123x"))
    expect_fail(()=>base.integer("-"))
    expect_fail(()=>base.integer("--"))
    expect_fail(()=>base.integer("-E"))
    expect_fail(()=>base.integer("3."))
    expect_fail(()=>base.integer("."))
    expect_fail(()=>base.integer("-."))
    expect_fail(()=>base.integer(".5"))
    expect_fail(()=>base.integer({}))
    expect_fail(()=>base.integer([]))
    expect_fail(()=>base.integer(()=>void))
    expect_fail(()=>base.integer(false))
    expect_fail(()=>base.integer(void))

    const _1 = base.integer("1")
    assert typeof _1 == "integer"
    assert _1        == 1

    const _2 = base.integer("0x002")
    assert typeof _2 == "integer"
    assert _2        == 2
}

##############################################################################
# base.integer.prototype.hex

do {
    assert 0 .hex()   == "0x0"
    assert 1 .hex()   == "0x1"
    assert 18 .hex()  == "0x12"
    assert (-1).hex() == "0xffffffffffffffff"
    assert 0x7fffffffffffffff .hex() == "0x7fffffffffffffff"
    assert 0x781000000 .hex() == "0x781000000"
    assert 0xfedcba .hex() == "0xfedcba"
    assert 0x9876543210 .hex() == "0x9876543210"
    for var i = 0; i <= 16; i += 1 {
        assert 32 .hex(i) == "0x" + "20".zfill(i)
    }

    expect_fail(()=>1.2.hex())
    expect_fail(()=>"1".hex())
    expect_fail(()=>32 .hex(17))
    expect_fail(()=>32 .hex(-1))
}

##############################################################################
# base.float

do {
    assert typeof base.float           == "class"
    assert typeof base.float.prototype == "object"
    assert base.float instanceof base.function
    assert base.float instanceof base.class
}

do {
    const number = base.float()
    assert typeof number == "float"
    assert number        == 0
}

do {
    const number = base.float(10)
    assert typeof number == "float"
    assert number        == 10
}

do {
    const number = base.float(2.9)
    assert typeof number == "float"
    assert number        == 2.9
}

do {
    const number = base.float(4611686018427387904)
    assert typeof number == "float"
    assert number        == 4611686018427387904
}

do {
    assert base.float("+1") == 1
    assert base.float("1e0x10") == 10000000000000000
}

do {
    expect_fail(()=>(3.0).square3())

    base.float.prototype.square3 = () => this * this * this

    assert (3.0).square3() == 27

    expect_fail(()=>(3).square3())
}

do {
    assert base.float()     == 0
    assert base.float(3)    == 3
    assert base.float(-4.5) == -4.5
}

do {
    assert 0.0 instanceof base.float
    assert 0.5 instanceof base.float
    assert ! (0 instanceof base.float)
}

do {
    const value = (()=>42.0)()
    assert value instanceof base.float
    assert value instanceof base.number
    assert value instanceof base.object
    assert ! (value instanceof base.integer)
    assert ! (value instanceof base.string)
    assert ! (value instanceof base.boolean)
}

do {
    expect_fail(()=>base.float(""))
    expect_fail(()=>base.float("a"))
    expect_fail(()=>base.float("e"))
    expect_fail(()=>base.float("123x"))
    expect_fail(()=>base.float("-"))
    expect_fail(()=>base.float("--"))
    expect_fail(()=>base.float("-E"))
    expect_fail(()=>base.float("0x002"))
    expect_fail(()=>base.float({}))
    expect_fail(()=>base.float([]))
    expect_fail(()=>base.float(()=>void))
    expect_fail(()=>base.float(false))
    expect_fail(()=>base.float(void))

    expect_fail(()=>base.float("1.1.1"))

    const _1 = base.float("1")
    assert typeof _1 == "float"
    assert _1        == 1

    const _3 = base.float("3.")
    assert typeof _3 == "float"
    assert _3        == 3

    const _0 = base.float(".")
    assert typeof _0 == "float"
    assert _0        == 0

    const _m0 = base.float("-.")
    assert typeof _m0 == "float"
    assert _m0        == 0

    const _0_5 = base.float(".5")
    assert typeof _0_5 == "float"
    assert _0_5        == 0.5
}

##############################################################################
# void

do {
    assert typeof void == "void"
    expect_fail(fun {
        for const x in void { }
    })

    var count = 0
    for const x in base.deep(void) {
        count += 1
    }
    assert count == 0

    count = 0
    for const x in base.shallow(void) {
        count += 1
    }
    assert count == 0
}

do {
    const value = (()=>void)()
    assert ! (value instanceof base.object)
    assert ! (value instanceof base.integer)
    assert ! (value instanceof base.float)
    assert ! (value instanceof base.number)
    assert ! (value instanceof base.string)
    assert ! (value instanceof base.boolean)
}

##############################################################################
# base.boolean

do {
    assert typeof base.boolean           == "class"
    assert typeof base.boolean.prototype == "object"
    assert base.boolean instanceof base.function
    assert base.boolean instanceof base.class
}

do {
    assert base.boolean(true)
    assert ! base.boolean(false)
    assert base.boolean(3 + 4)
    assert ! base.boolean(5 - 5)
}

do {
    expect_fail(()=>false.negative())
    base.boolean.prototype.negative = ()=>!this
    assert false.negative()
    assert ! true.negative()
}

do {
    assert true  instanceof base.boolean
    assert false instanceof base.boolean
    assert ! (void instanceof base.boolean)

    const a = 10
    const b = 2 * 5
    assert (a == b) instanceof base.boolean
}

do {
    const value = (()=>false)()
    assert value instanceof base.boolean
    assert value instanceof base.object
    assert ! (value instanceof base.integer)
    assert ! (value instanceof base.float)
    assert ! (value instanceof base.number)
    assert ! (value instanceof base.string)
}

##############################################################################
# base.function

do {
    assert base.function instanceof base.function
    assert base.function instanceof base.class
    assert ! (base.function instanceof base.generator)

    assert base.class instanceof base.function
    assert base.class instanceof base.class
    assert ! (base.class instanceof base.generator)

    assert base.generator instanceof base.function
    assert base.generator instanceof base.class
    assert ! (base.generator instanceof base.generator)

    expect_fail(base.class)
    expect_fail(base.generator)
    expect_fail(base.generator_end)

    fun regular_func
    {
    }

    assert regular_func instanceof base.function
    assert ! (regular_func instanceof base.class)
    assert ! (regular_func instanceof base.generator)

    fun generator_func
    {
        yield void
    }

    assert generator_func instanceof base.function
    assert ! (generator_func instanceof base.class)
    assert generator_func instanceof base.generator

    class constructor_func { }

    assert constructor_func instanceof base.function
    assert constructor_func instanceof base.class
    assert ! (constructor_func instanceof base.generator)

    assert ! ("prototype" propertyof regular_func)
    assert ! ("prototype" propertyof generator_func)
    assert "prototype" propertyof constructor_func
    assert "prototype" in constructor_func

    assert typeof constructor_func.prototype == "object"
    expect_fail(()=>regular_func.prototype)
    expect_fail(()=>generator_func.prototype)

    assert regular_func.name == "regular_func"
    var name_from_iter = void
    for const k, v in base.deep(regular_func) {
        if k == "name" {
            name_from_iter = base.stringify(v)
            break
        }
    }
    assert name_from_iter == "regular_func"

    fun some_func { return __line__ }
    assert "line" propertyof some_func
    assert ! ("line" in some_func)
    assert some_func.line == some_func()
}

do {
    class empty { }
    class ctor { constructor { } }
    class noctor { a { } b { } }

    assert empty  instanceof base.function
    assert empty  instanceof base.class
    assert ctor   instanceof base.function
    assert ctor   instanceof base.class
    assert noctor instanceof base.function
    assert noctor instanceof base.class
}

do {
    const f = ()=>void
    assert f instanceof base.function
    assert f instanceof base.object
    assert ! (f instanceof base.integer)
    assert ! (f instanceof base.string)
    assert ! (f instanceof base.array)
}

do {
    const value = ()=>void
    assert value instanceof base.function
    assert value instanceof base.object
    assert ! (value instanceof base.integer)
    assert ! (value instanceof base.float)
    assert ! (value instanceof base.number)
    assert ! (value instanceof base.boolean)
    assert ! (value instanceof base.string)
    assert ! (value instanceof base.array)
}

do {
    const f1 = x => x + 1
    const f2 = x => x + 1
    const f3 = base.function(f1)
    assert f1 == f3
    assert f1 != f2
    assert f2 != f3
}

do {
    const f1 = fun { yield 0 }
    const f2 = base.function(f1)
    assert f1 == f2
}

do {
    const f1 = class { }
    const f2 = base.class(f1)
    assert f1 != f2
    const f3 = base.function(f1)
    assert f1 != f3
}

do {
    class c1 { hello { return "hello" } }
    c1.prototype.x = 42

    const o1 = c1()
    assert o1.hello() == "hello"
    assert o1.x == 42

    const c2 = base.class(c1)

    assert typeof c2.prototype == "void"

    const o2 = c2()
    assert ! ("hello" propertyof o2)
    assert ! ("x" propertyof o2)

    assert ! ("o2" instanceof c1)
    assert o2 instanceof c2

    c2.prototype = c1.prototype

    const o3 = c2()
    assert o3.hello() == "hello"
    assert o3.x == 42

    assert o3 instanceof c1
    assert o3 instanceof c2
}

do {
    class c1 { }
    c1.prototype.x = 42

    const c2 = base.function(c1)

    assert c1 != c2

    const o1 = c1()
    const o2 = c2()

    assert "x" propertyof o1
    assert ! ("x" propertyof o2)
    assert o1.x == 42

    assert "x" in c1.prototype
    assert ! ("x" propertyof c2.prototype)
}

do {
    fun g1 {
        yield 10
        yield 20
    }

    const g2 = base.function(g1)

    assert g1 == g2

    const g3 = g1()
    assert g3() == 10

    assert g1 != g3

    const g4 = base.function(g3)

    assert g3 != g4
    assert g1 != g4

    assert g3() == 20

    const g5 = g4()
    assert typeof g5 == "function"
    assert g5() == 10
}

do {
    fun g1 {
        yield 10
        yield 20
    }

    const g2 = base.generator(g1)

    assert g1 == g2

    const g3 = g1()
    assert g3() == 10

    assert g1 != g3

    const g4 = base.generator(g3)

    assert g3 != g4
    assert g1 != g4

    assert g3() == 20

    const g5 = g4()
    assert typeof g5 == "function"
    assert g5() == 10
}

do {
    expect_fail(()=>base.function())
    expect_fail(()=>base.function(void))
    expect_fail(()=>base.function(0))
    expect_fail(()=>base.function(""))
    expect_fail(()=>base.function([]))
    expect_fail(()=>base.function({}))
}

do {
    expect_fail(()=>base.class())
    expect_fail(()=>base.class(void))
    expect_fail(()=>base.class(0))
    expect_fail(()=>base.class(""))
    expect_fail(()=>base.class([]))
    expect_fail(()=>base.class({}))
    expect_fail(()=>base.class(fun {yield 0}))
    expect_fail(()=>base.class(fun {}))
}

do {
    expect_fail(()=>base.generator())
    expect_fail(()=>base.generator(void))
    expect_fail(()=>base.generator(0))
    expect_fail(()=>base.generator(""))
    expect_fail(()=>base.generator([]))
    expect_fail(()=>base.generator({}))
    expect_fail(()=>base.generator(class{}))
    expect_fail(()=>base.generator(fun{}))
}

##############################################################################
# base.exception

do {
    assert typeof base.exception == "class"
    assert base.exception instanceof base.function
    assert base.exception instanceof base.class
}

do {
    var line      = void
    var exception = void
    assert ! exception
    try {
        line = __line__ ; base.exception()
        assert false
    }
    catch const e {
        exception = e
    }
    assert exception
    assert exception instanceof base.exception
    assert exception.backtrace.size    == 2
    assert exception.backtrace[1].line == line
}

do {
    var exception = void
    assert ! (exception instanceof base.exception)
    try {
        throw void
    }
    catch const e {
        exception = e
    }
    assert exception instanceof base.exception
}

do {
    var ex = void
    try {
        base.exception(42.0)
    }
    catch const e {
        ex = e.value
    }
    assert typeof ex == "float"
    assert ex == 42
}

##############################################################################
# instanceof buffer

do {
    const value = base.buffer()
    assert value instanceof base.buffer
    assert value instanceof base.object
    assert ! (value instanceof base.integer)
    assert ! (value instanceof base.float)
    assert ! (value instanceof base.number)
    assert ! (value instanceof base.boolean)
    assert ! (value instanceof base.string)
    assert ! (value instanceof base.array)

    assert base.buffer instanceof base.function
    assert base.buffer instanceof base.class
}

##############################################################################
# resize

do {
    expect_fail(()=>[].resize(-1))
    expect_fail(()=>base.buffer().resize(-1))
}

##############################################################################
# class selection

do {
    fun new_type(type, args...)
    {
        return base[type].apply(void, args)
    }

    const a = new_type("array", "xy", [2])
    assert typeof a == "array"
    assert a.size   == 3
    assert a[0]     == "x".code()
    assert a[1]     == "y".code()
    assert a[2]     == 2

    const i = new_type("integer")
    assert typeof i == "integer"
    assert i        == 0

    const n = new_type("number", "1.5")
    assert typeof n == "float"
    assert n        == 1.5

    const o = new_type("object")
    assert typeof o == "object"

    const s = new_type("string", 1, "x", 2)
    assert typeof s == "string"
    assert s        == "1x2"

    for const type in ["integer", "float", "string", "boolean", "object", "array"] {
        assert typeof new_type(type) == type
    }
}

##############################################################################
# base.shallow

do {
    const obj  = { a: 42, b: 43, c: 44 }
    const iter = base.shallow(obj)

    var key, value = iter()
    assert key == "a" || key == "b" || key == "c"
    assert value == 42 || value == 43 || value == 44

    key, value = iter()
    assert key == "a" || key == "b" || key == "c"
    assert value == 42 || value == 43 || value == 44

    key, value = iter()
    assert key == "a" || key == "b" || key == "c"
    assert value == 42 || value == 43 || value == 44

    expect_fail(()=>iter())
}

do {
    expect_fail(()=>base.shallow({})())
    expect_fail(()=>base.shallow([1])())
    expect_fail(()=>base.shallow(1)())
    expect_fail(()=>base.shallow("1")())
    expect_fail(()=>base.shallow(true)())
    expect_fail(()=>base.shallow(void)())

    var count = 0
    for const n in base.shallow(()=>void) {
        count += 1
    }
    assert count == 0

    count = 0
    for const n, v in base.shallow({xyz:void}) {
        assert n == "xyz"
        count += 1
    }
    assert count == 1
}

do {
    const a = [ base.shallow(base.array) ... ]
    assert typeof a == "array"
    assert a.size   == 1
    const elem = a[0]
    assert typeof elem == "array"
    assert elem.size   == 2
    assert elem[0]     == "prototype"
}

do {
    const a = [ base.deep(base.array.prototype) ... ]
    var has_size    = false
    var has_indices = false
    var has_apply   = false

    for var i = 0; i < a.size; i += 1 {
        const elem = a[i]
        assert typeof elem == "array"
        assert elem.size   == 2
        switch elem[0] {
            case "size":    has_size = true
            case "indices": has_indices = true
            case "apply":   has_apply = true
        }
    }

    assert has_size
    assert has_indices
    assert ! has_apply
}

do {
    const a = base.array({ a: 11 })
    assert typeof a    == "array"
    assert a.size      == 1
    assert typeof a[0] == "array"
    assert a[0].size   == 2
    assert a[0][0]     == "a"
    assert a[0][1]     == 11
}

do {
    class abase {
        f1 { }
        f2 { }
    }
    class derived extends abase {
        constructor {
            this.first = 101
            this.second = "102"
        }
        f3 { }
    }
    const a = base.array(derived())
    assert typeof a == "array"
    assert a.size   == 2
    a.sort()
    assert a[0][0] == "first"
    assert a[0][1] == 101
    assert a[1][0] == "second"
    assert a[1][1] == "102"
}

do {
    expect_fail(() => base.array(true))
    expect_fail(() => base.array(false))
    expect_fail(() => base.array(fun { }))
}

##############################################################################
# base.range

do {
    expect_fail(base.range)
}

do {
    const iter = base.range(5)
    assert iter() == 0
    assert iter() == 1
    assert iter() == 2
    assert iter() == 3
    assert iter() == 4
    expect_fail(iter)
}

do {
    const iter = base.range(6, 9)
    assert iter() == 6
    assert iter() == 7
    assert iter() == 8
    expect_fail(iter)
}

do {
    const iter = base.range(-10, -5)
    assert iter() == -10
    assert iter() == -9
    assert iter() == -8
    assert iter() == -7
    assert iter() == -6
    expect_fail(iter)
}

do {
    const iter = base.range(10, 5)
    expect_fail(iter)
}

do {
    const iter = base.range(-2, 5, 2)
    assert iter() == -2
    assert iter() == 0
    assert iter() == 2
    assert iter() == 4
    expect_fail(iter)
}

do {
    const iter = base.range(10, 0, -3)
    assert iter() == 10
    assert iter() == 7
    assert iter() == 4
    assert iter() == 1
    expect_fail(iter)
}

##############################################################################
# base.map

do {
    const iter = base.map(()=>void, [])
    assert typeof iter == "function"
    expect_fail(iter)
}

do {
    const f = base.map(x => x)
    assert typeof f == "function"
    const iter = f(["a", "b"])
    assert typeof f == "function"
    assert iter() == "a"
    assert iter() == "b"
    expect_fail(iter)
}

do {
    const iter = base.map(x => x * 10, [2, 3, 4])
    assert typeof iter == "function"
    assert iter()      == 20
    assert iter()      == 30
    assert iter()      == 40
    expect_fail(iter)
}

do {
    const iter = base.map(x=>x+5)(base.range(1, 3))
    assert typeof iter == "function"
    assert iter()      == 6
    assert iter()      == 7
    expect_fail(iter)
}

do {
    const iter = [1, 2, 3].map(x=>-x)
    assert typeof iter == "function"
    assert iter()      == -1
    assert iter()      == -2
    assert iter()      == -3
    expect_fail(iter)
}

do {
    const iter = "mno".map(x => x + "_")
    assert typeof iter == "function"
    assert iter()      == "m_"
    assert iter()      == "n_"
    assert iter()      == "o_"
    expect_fail(iter)
}

do {
    const iter = false.map(x => !x)
    assert typeof iter == "function"
    assert iter()      == true
    expect_fail(iter)
}

do {
    class encap {
        constructor(x) {
            this.x = x + 1
        }
        get_value {
            return this.x * 10
        }
    }

    var i = 10
    for const v in base.range(0, 8, 2) -> base.map(encap) {
        assert v.get_value() == i
        i += 20
    }
    assert i == 90
}

##############################################################################
# base.filter

do {
    const iter = base.filter(()=>true, [])
    expect_fail(iter)
}

do {
    const iter = base.filter(()=>false, [1, 2, 3])
    expect_fail(iter)
}

do {
    const iter = base.filter(x => x & 1, base.range(10))
    assert typeof iter == "function"
    assert iter()      == 1
    assert iter()      == 3
    assert iter()      == 5
    assert iter()      == 7
    assert iter()      == 9
    expect_fail(iter)
}

do {
    const iter = [5, 6, 7].filter(x => x != 6)
    assert typeof iter == "function"
    assert iter()      == 5
    assert iter()      == 7
    expect_fail(iter)
}

do {
    const result = []
    for var elem in base.range(5) ->
                    base.map(x => (x - 2) * 10) ->
                    base.filter(x => x > 0) {
        result.insert(result.size, elem)
    }
    assert result.size == 2
    assert result[0]   == 10
    assert result[1]   == 20
}

##############################################################################
# base.reduce

do {
    const result = base.reduce((x, y)=>x + y, 42, [])
    assert result == 42
}

do {
    const result = base.reduce((x, y)=>x + y, 0, [10])
    assert result == 10
}

do {
    const result = base.reduce((x, y)=>x + y, 1, [2000, 300, 70, 5])
    assert result == 2376
}

do {
    fun fib_elem(elem)
    {
        var prev = 0
        return base.range(1, elem).reduce(fun(accum) {
            const y = prev
            prev    = accum
            return accum + y
        }, 1)
    }

    # 11th element of Fibonacci series
    assert fib_elem(11) == 89
}

do {
    fun fib_on_range
    {
        var prev = 0
        return base.reduce(fun(accum) {
            const y = prev
            prev    = accum
            return accum + y
        }, 1)
    }

    # 12th elem of Fibonacci series
    assert fib_on_range()(base.range(1, 12)) == 144
}

do {
    const result = [1, 2, 3, 4].reduce((x, y)=>x+y, 0)
    assert result == 10
}

do {
    const count = [1, 2, 3, 1, 4, 5, 1, 6, 1, 7].reduce((x, y) => x + (y == 1 ? 1 : 0), 0)
    assert count == 4
}

##############################################################################
# base.sum

do {
    assert base.sum([]) == 0
    assert base.sum([], "") == ""
    assert base.sum([10, 200, 3, 4000]) == 4213
    assert base.sum([4.0, 2.0, 8.0]) == 14.0
    assert base.sum(["ab", "c", "def", "gh"], "") == "abcdefgh"

    expect_fail(base.sum)
    expect_fail(() => base.sum(void))
    expect_fail(()=>base.sum([1], ""))
}

##############################################################################
# base.count

do {
    assert base.count(void, []            ) == 0
    assert base.count("",   [1, 2]        ) == 0
    assert base.count(4,    base.range(10)) == 1
    assert base.count("a",  "abcadefagh"  ) == 3

    assert "Hello, World!".count("l") == 3

    assert base.keys({x: 8, _test_value: 8, y: 8}).count("_test_value") == 1

    assert fun {
        for var i = 0; i < 100; i += 1 {
            yield i / 4
        }
    } () . count(11) == 4

    assert base.count(x => x > 5, [ 1, 7, 2, 6, 5 ]) == 2

    # Count lowercase letters
    assert "ThIs Is A MiXeD StRiNg".filter(x => x.code() >= 97).count() == 8
}

##############################################################################
# base.all

do {
    assert base.all(1, [1, 1.0, 1]) == true
    assert base.all(1, [0, 1, 2])   == false
    assert base.all(x => x > 2, [ 4, 3, 5 ]) == true
    assert base.all(x => x > 2, [ 4, 2, 5 ]) == false
}

##############################################################################
# base.any

do {
    assert base.any(1, [ 0, 2, 3, 4 ]) == false
    assert base.any(2, [ 0, 2, 3, 4 ]) == true
    assert base.any(2, [ 0, 2, 3, 2 ]) == true
    assert base.any(x => x == void, [ 1, 2, 3, 4 ]) == false
    assert base.any(x => x == 3,    [ 1, 2, 3, 4 ]) == true
}

##############################################################################
# base.method

do {
    const o = {
        _i : 0,
        add : fun(x) { const v = this._i ; this._i = v + x ; return v },
        sub : fun(x) { const v = this._i ; this._i = v - x ; return v }
    }

    assert o.add(1) == 0
    assert o._i     == 1

    const m = base.method(o, o.add)
    assert typeof m == "function"

    assert m(2) == 1
    assert o._i == 3
    assert m(1) == 3
    assert o._i == 4

    delete o.add

    expect_fail(()=>o.add(1))

    assert m(3) == 4
    assert o._i == 7

    const ms = base.method(o, "sub")
    assert typeof ms == "function"

    assert ms(1) == 7
    assert o._i  == 6

    assert ms(3) == 6
    assert o._i  == 3

    expect_fail(()=>base.method(o, "_i"))
    expect_fail(()=>base.method(o, "non existent"))
    expect_fail(()=>base.method(o, o._i))
}

##############################################################################
# base.keys

do {
    fun gen
    {
        yield [40, -40]
        yield [-40, 50]
        yield [700, 8]
    }

    const it0 = gen()
    assert it0()[0] == 40
    assert it0()[0] == -40
    assert it0()[0] == 700
    expect_fail(it0)

    const it = base.keys(gen())
    assert it() == 40
    assert it() == -40
    assert it() == 700
    expect_fail(it)
}

do {
    const obj = { "0" : 10, "1" : 200, "2" : 3000, "3" : 4000 }
    const a = [ false, false, false, false ]
    for const key in base.keys(obj) {
        assert typeof key == "string"
        const value = base.integer(key)
        assert value >= 0 && value <= 3
        assert ! a[value]
        a[value] = true
    }
    for const value in a {
        assert typeof value == "boolean"
        assert value
    }
}

do {
    fun gen
    {
        const it = base.range(4)
        loop { yield it }
    }

    const it = base.keys(gen())
    assert it() == 0
    assert it() == 1
    assert it() == 2
    assert it() == 3
    expect_fail(it)
}

do {
    const a  = [ base.range(10, 20),
                 base.range(5, 6),
                 base.range(-100, -200, -1) ]
    const it = base.keys(a)
    assert it() == 10
    assert it() == 5
    assert it() == -100
    expect_fail(it)
}

do {
    const a = [ [1, 2], [3], [4, 5], [], [6] ]
    const it = base.keys(a)
    assert it() == 1
    assert it() == 3
    assert it() == 4
    expect_fail(it)
    expect_fail(it)
}

##############################################################################
# base.stringify

do {
    assert base.stringify()              == ""
    assert base.stringify("a")           == "a"
    assert base.stringify(false)         == "false"
    assert base.stringify(true)          == "true"
    assert base.stringify(void)          == "void"
    assert base.stringify(1)             == "1"
    assert base.stringify(1.5)           == "1.5"
    assert base.stringify([])            == "[]"
    assert base.stringify([1])           == "[1]"
    assert base.stringify([2, 33, 444])  == "[2, 33, 444]"
    assert base.stringify(["true",true]) == "[\"true\", true]"

    assert base.stringify(false, 2, "o") == "false2o"
}

do {
    const a = []
    a.push(a)
    assert base.stringify(a) == "[[...]]"
}

do {
    const o = {}
    o.o = o
    assert base.stringify(o) == "{\"o\": {...}}"
}

do {
    const a = []
    const o = {}
    o.a = a
    a.push(o)
    assert base.stringify(o) == "{\"a\": [{...}]}"
    assert base.stringify(a) == "[{\"a\": [...]}]"
}

do {
    // Float number from fuzzer
    assert base.stringify(882799999999999937953023393792.5) == "882799999999999937953023393792."
}

##############################################################################
# base.hex

do {
    assert base.hex(42) == "0x2a"

    expect_fail(()=>base.hex(3.5))
}

##############################################################################
# base.args

do {
    assert typeof base.args == "array"
    assert base.args.size   == 1
    assert base.args[0].ends_with("module_base.kos")
}

##############################################################################
# base.thread

do {
    expect_fail(base.thread)

    const o = { t1: 0, t2: 0, done: false }

    fun thread1
    {
        while ! o.t2 { }
        o.t1 += 1
    }

    fun thread2
    {
        while ! o.done { }
        o.t2 += 1
        while ! o.t1 { }
    }

    const t1 = thread1.async(void, [])
    const t2 = thread2.async(void, [])

    assert t1 instanceof base.thread
    assert t1 instanceof base.object
    assert t2 instanceof base.thread
    assert t2 instanceof base.object

    o.done = true
    t1.wait()
    t2.wait()

    assert o.t1 == 1
    assert o.t2 == 1
}

do {
    fun sum(a, b)
    {
        return a + b
    }

    const t = sum.async(void, [10, 24]);

    assert t instanceof base.thread

    const result = t.wait()

    assert result == 34

    expect_fail(()=>t.wait())
}

do {
    fun thread(a)
    {
        return a * 10
    }

    assert thread(-42) == -420

    do {
        const t = thread.async(void, [2])
        assert t.wait() == 20
    }

    do {
        const t = thread.async(void, [123])
        assert t.wait() == 1230
    }
}

do {
    fun thread
    {
        throw "something"
    }

    const t = thread.async(void, [])
    var   e = void
    try {
        t.wait()
    }
    catch const exc {
        e = exc
    }
    assert typeof e == "object"
    assert e.value == "something"
}

do {
    var t       = void
    var done    = false
    var success = false

    fun thread(wait)
    {
        defer { done = true }
        while ! t { }
        if wait {
            t.wait()
        }
        success = true
    }

    # Normal invocation
    t = thread.async(void, [false])
    assert t instanceof base.thread
    while ! done { }
    t.wait()
    assert success
    t       = void
    success = false
    done    = false

    # Exception inside thread
    t = thread.async(void, [true])
    assert t instanceof base.thread
    while ! done { }
    var e = void
    try { t.wait() } catch const exc { e = exc }
    assert ! success
    assert e != void
    t       = void
    success = false
    done    = false

    # Incorrect number of args (not even called)
    e = void
    t = thread.async(void, [])
    assert t instanceof base.thread
    try { t.wait() } catch const exc { e = exc }
    assert ! done
    assert ! success
    assert e != void
}

do {
    var x = void
    const t = base.function.async.apply(fun { x = 42; return 4.2 }, [void, []])
    assert t.wait() == 4.2
    assert x == 42

    expect_fail(() => base.function.async.apply(void, [void, []]))
    expect_fail(() => base.function.async.apply(1, [void, []]))
    expect_fail(() => base.function.async.apply("", [void, []]))
    expect_fail(() => fun {} . async(void))
    expect_fail(() => fun {} . async())
    expect_fail(() => fun {} . async(void, {}))
    expect_fail(() => fun {} . async(void, void))
    expect_fail(() => fun {} . async(void, -42))
    expect_fail(() => fun {} . async(void, "42"))
}

do {
    const obj = { }
    assert ! ("xyz" propertyof obj)

    fun fff
    {
        this.xyz = "42"
    }

    const t = fff.async(obj, [])
    t.wait()

    assert "xyz" propertyof obj
    assert "xyz" in obj
    assert obj.xyz == "42"
}

##############################################################################
# base.count_elements

do {
    assert (["a", "b", "c"] -> base.count_elements) == 3
    expect_fail(() => void -> base.count_elements)
}

##############################################################################
# base.enumerate

do {
    const it = base.enumerate(["abc", 3, 10.5, false])
    for const pair in [ [0, "abc"], [1, 3], [2, 10.5], [3, false] ] {
        const result = it()
        assert result.size == 2
        assert pair[0] == result[0]
        assert pair[1] == result[1]
    }
    expect_fail(it)
}

do {
    const it = base.enumerate(fun {
        yield "first"
        yield "Second"
        yield "thirD"
    }())
    for const pair in [ [0, "first"], [1, "Second"], [2, "thirD"] ] {
        const result = it()
        assert result.size == 2
        assert pair[0] == result[0]
        assert pair[1] == result[1]
    }
    expect_fail(it)
}

##############################################################################
# base.zip

do {
    expect_fail(base.zip)

    var i = 0
    for const ret in base.zip(base.range(10)) {
        assert ret == i
        i += 1
    }

    const expected = [ ["a", 1], ["b", 2], ["c", 3] ]
    i = 0
    for const x, y in base.zip("abcd", base.range(1, 4)) {
        assert x == expected[i][0]
        assert y == expected[i][1]
        i += 1
    }

    i = 0
    for const x, y in base.zip("abc", base.range(1, 10)) {
        assert x == expected[i][0]
        assert y == expected[i][1]
        i += 1
    }

    const strings = [ "kos", "sok", "cat", "dog" ]
    i = 0
    for const a, b, c in base.zip("kscd", "ooaoo", "sktg") {
        assert a + b + c == strings[i]
        i += 1
    }

    const a = [ base.zip(base.range(2), "abc", base.range(10)) ... ]
    assert a.size == 2
    assert a[0] == [0, "a", 0]
    assert a[1] == [1, "b", 1]
}

##############################################################################
# base.each

do {
    var sum = 0

    fun update_sum(x)
    {
        sum += x
    }

    base.each(update_sum, [1, 300, 20])

    assert sum == 321

    sum = 0;

    [40, 500, 6000] -> base.each(update_sum)

    assert sum == 6540

    sum = 0;

    [100, 20, 3] -> base.map(x => update_sum(x)) -> base.each()

    assert sum == 123
}

##############################################################################
# base.join

do {
    assert base.join("", [])               == ""
    assert base.join("-", [])              == ""
    assert base.join("", ["a"])            == "a"
    assert base.join("-", ["a"])           == "a"
    assert base.join("", ["a", "b", "c"])  == "abc"
    assert base.join("-", ["a", "b", "c"]) == "a-b-c"
    assert base.join(" :x: ", [1, base.buffer([0x33, 0x30]), "a"]) == "1 :x: 30 :x: a"

    assert base.join("")([])     == ""
    assert base.join("")([""])   == ""
    assert base.join("_")("xy")  == "x_y"
    assert base.join("_")("xyz") == "x_y_z"

    expect_fail(() => base.join(void, []))
    expect_fail(() => base.join({}, []))
    expect_fail(() => base.join([], []))
    expect_fail(() => base.join([], void))
    expect_fail(() => base.join([], {}))
}
