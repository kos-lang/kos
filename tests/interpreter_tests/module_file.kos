#
# Copyright (c) 2014-2017 Chris Dragan
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.
#

import file
import lang

fun expect_fail(function)
{
    var failed = false
    try {
        function()
    }
    catch const e {
        failed = true
    }
    assert failed
}

##############################################################################
# file.open, file.is_file, file.remove

{
    assert typeof file.file           == "function"
    assert typeof file.file.prototype == "object"
}

{
    const name = "__test_file"
    file.remove(name)
    assert ! file.is_file(name)

    {
        const f = file.open(name, file.create)
        assert typeof f == "object"

        assert f.size == 0

        const init_buf = new lang.buffer(9)
        for var i in lang.range(init_buf.size) {
            init_buf[i] = i
        }

        assert f.write(init_buf) == f
        assert f.write(init_buf).write(init_buf) == f

        assert f.size == 27

        f.close()

        expect_fail(λ->(f.size))
        expect_fail(λ->(f.read()))
        expect_fail(λ->(f.write(init_buf)))
    }

    assert file.is_file(name)

    with const f = file.open(name, file.ro) {
        const buf = f.read()

        assert typeof buf == "buffer"
        assert buf.size   == 27

        for var i in lang.range(buf.size) {
            assert (i % 9) == buf[i]
        }

        expect_fail(λ->(f.write(buf)))
    }

    assert file.remove(name)
    assert ! file.remove(name)
}

{
    var failed = true
    try {
        file.open("", void)
    }
    catch const e {
        failed = false
    }
    assert ! failed
}

##############################################################################
# file.close

{
    const name = "__test_file"
    var failed = true
    var f = file.open(name, file.create)
    try {
        defer {
            f.close()
        }
        f.close.apply(void, [])
    }
    catch const e {
        failed = false
    }
    assert ! failed
}

##############################################################################
# file.size, file.position

{
    const name = "./__test_file"
    file.remove(name)
    assert ! file.is_file(name)

    with const f = new file.file(name, file.create) {
        const buf = new lang.buffer(100)
        for var i in lang.range(buf.size) {
            buf[i] = i + 100
        }
        f.write(buf)
    }

    with const f = new file.file(name, file.ro) {
        assert f.size     == 100
        assert f.position == 0

        f.seek(50)
        assert f.position == 50

        const buf = f.read(2)
        assert f.position == 52
        assert buf.size   == 2
        assert buf[0]     == 150
        assert buf[1]     == 151

        f.position = 200
        assert f.position == 200

        const buf2 = f.read(10)
        assert f.position == 200
        #assert buf2.size  == 0
    }

    assert file.remove(name)
    assert ! file.is_file(name)
}

##############################################################################
# file.stdin, file.stdout, file.stderr

{
    assert file.stdin  instanceof file.file
    assert file.stdout instanceof file.file
    assert file.stderr instanceof file.file
}

##############################################################################
# file.read_line

{
    const name = "./__text_line"
    file.remove(name)
    assert ! file.is_file(name)

    with const f = file.open(name, file.create) {
        const lines = "abcdefg\nhijklm\nnop";
        f.write((new lang.buffer).pack("s\(lines.size)", lines))
    }

    with const f = file.open(name, file.ro) {
        expect_fail(λ->(f.read_line(-1)))
        expect_fail(λ->(f.read_line(0)))
        var line = f.read_line(1)
        assert line == "abcdefg\n"
        line = f.read_line()
        assert line == "hijklm\n"
        line = f.read_line()
        assert line == "nop"
        assert f.eof
        assert ! f.error
        assert f.read_line() == ""
        assert f.eof
        assert ! f.error
    }

    assert file.remove(name)
    assert ! file.remove(name)
}

##############################################################################
# file.read_lines

{
    const name = "./__text_file"
    file.remove(name)
    assert ! file.is_file(name)

    with const f = file.open(name, file.create) {
        const lines = "abc\n\ndef\n\rxyz"
        f.write((new lang.buffer).pack("s\(lines.size)", lines))
    }

    with const f = file.open(name, file.ro) {
        const lines = f.read_lines()
        assert lines() == "abc\n"
        assert lines() == "\n"
        assert lines() == "def\n"
        assert lines() == "\r"
        assert lines() == "xyz"
        expect_fail(λ->(lines()))
        assert f.eof
        assert ! f.error
    }

    with const f = file.open(name, file.ro) {
        const lines = f.read_lines(1)
        assert lines() == "abc\n"
        assert lines() == "\n"
        assert lines() == "def\n"
        assert lines() == "\r"
        assert lines() == "xyz"
        expect_fail(λ->(lines()))
        assert f.eof
        assert ! f.error
    }

    with const f = file.open(name, file.create) {
        const lines = "xy\r\nz\x{FF}\n"
        f.write((new lang.buffer).pack("s", lines))
    }

    with const f = file.open(name, file.ro) {
        var a = []
        for var line in f.read_lines() {
            const i = a.size
            a.resize(i + 1)
            a[i] = line
        }
        assert a.size == 2
        assert a[0]   == "xy\r\n"
        assert a[1]   == "z\xFF\n"
        assert f.eof
        assert ! f.error
    }

    assert file.remove(name)
    assert ! file.is_file(name)
}
