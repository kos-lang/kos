#
# Copyright (c) 2014-2019 Chris Dragan
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.
#
fun expect_fail(function)
{
    var failed = false
    try {
        function()
    }
    catch const e {
        failed = true
    }
    assert failed
}

expect_fail(()=>{}[""])

do {
    const a = {}
    a[""] = 1
    assert a[""] == 1
}

do {
    const a = {}
    a.x = 0
    assert a.x == 0
}

do {
    const a = { x: 1, y: 2 }
    assert a.x == 1
    assert a.x == a["x"]
    const yy = "y"
    assert a[yy] == 2
    assert a.y == a["y"]
    a["x"]
}

do {
    var a = { aa: 11, bb: 22 }
    assert delete a.x == void
    assert a.aa == 11
    assert a.bb == 22

    assert delete a.bb == void
    assert a.aa == 11
    expect_fail(()=>a.bb)

    const aa = "aa"
    assert delete a[aa] == void
    expect_fail(()=>a.aa)
}

do {
    const o = {
        "orange" : 0,
        lemon    : 1,
        "apple"  : 2,
        pear     : 3,
        "melon"  : 4,
        peach    : 5
    }

    assert o.orange   == 0
    assert o["lemon"] == 1
    assert o.apple    == 2
    assert o["pear"]  == 3
    assert o.melon    == 4
    assert o["peach"] == 5
}

do {
    fun constr
    {
    }

    expect_fail(fun {
        constr.prototype = {}
    })
}

do {
    class constr {
        constructor {
            this.b = "b"
        }
    }

    constr.prototype = { a: "a" }

    const obj = constr()
    assert obj instanceof constr
    assert obj.a == "a"
    assert obj.b == "b"

    delete obj.a
    assert obj.a == "a"

    obj.a = "x"
    assert obj.a == "x"

    delete obj.a
    assert obj.a == "a"

    assert obj.b == "b"
    delete obj.b
    expect_fail(()=>obj.b)
}

do {
    class constr {
        constructor(a) {
            this.a = a + 1
        }
    }

    expect_fail(()=>constr())

    const obj = constr(8)

    assert obj.a == 9
}

do {
    var obj = class { constructor { this.a = 123 } }
    obj = obj()
    assert typeof obj == "object"
    assert obj.a      == 123
}

do {
    class constr {
        constructor(a) {
            this.a = a + 2
        }
    }

    var obj = 10
    obj = constr(obj)
    assert typeof obj == "object"
    assert obj.a      == 12
}

do {
    const base = [void, void, void]

    class constr {
        constructor(a) {
            this.a = a * 2
        }
    }

    constr.prototype = base

    const obj = constr(5)
    assert obj instanceof constr

    assert obj.a == 10
    expect_fail(()=>obj[0])
    expect_fail(()=>obj.length)
}

do {
    const obj = {}
    assert ! ("xyz" in obj)
    obj.xyz = void
    assert "xyz" in obj
}

do {
    const obj   = {}
    const prop  = "xyz"
    const value = 123
    assert ! (prop in obj)
    obj[prop] = value
    assert prop in obj
    assert prop  == "xyz"
    assert value == 123
}

do {
    class constr1 {
        constructor (a) {
            this.a = a
        }
    }

    class constr2 {
        constructor {
            this.a = void
        }
    }

    const obj   = constr1(42)
    const other = { a: 42 }

    assert obj != other

    assert obj instanceof constr1
    assert ! (other instanceof constr1)
    assert ! (obj instanceof constr2)

    assert obj.a   == 42
    assert other.a == 42

    constr1.prototype = {}

    assert ! (obj instanceof constr1)
}

do {
    class constr {
        constructor {
            this.c = 0
            this.d = 1
            this.e = 2
        }
    }

    constr.prototype.a = 10
    constr.prototype.b = 11

    const obj =  constr()

    const values = ["c", "d", "e"]

    for const key, value in obj {
        const value = obj[key]
        if typeof value == "integer" && value >= 0 && value < values.size {
            assert values[value] == key
            values[value] = void
        }
    }

    for var i = 0; i < values.size; i += 1 {
        assert values[i] == void
    }
}

do {
    fun get_constr
    {
        return class { }
    }

    const o1 = get_constr()()
    const o2 = get_constr()()

    assert o1 instanceof get_constr()
    assert o2 instanceof get_constr()
}

do {
    class complex {
        constructor(re, im)
        {
            this.re = re
            this.im = im
        }

        add(other)
        {
            return complex(this.re + other.re,
                           this.im + other.im)
        }

        dot(other)
        {
            return this.re * other.re +
                   this.im * other.im
        }
    }

    assert typeof complex == "class"

    const c1 = complex(-1, 2)
    const c2 = complex(3, -5)
    const c3 = c1.add(c2)
    const d  = c1.dot(c2)

    assert c1 instanceof complex
    assert c2 instanceof complex
    assert c3 instanceof complex
    assert typeof d == "integer"

    assert c3.re == 2
    assert c3.im == -3
    assert d     == -13

    expect_fail(complex)
    expect_fail(()=>complex(1))
}

do {
    class value {
        setv(x) {
            this.x = x
        }
        getv() {
            return this.x
        }
    }

    assert typeof value == "class"

    const v = value();
    expect_fail(()=>v.getv())
    assert v.setv(42) == void
    assert v.getv() == 42
}

do {
    class empty_ctor {
        constructor {
            this.x = 42
        }
    }

    assert typeof empty_ctor == "class"

    const v = empty_ctor()
    assert v.x == 42
}

do {
    class empty { }

    empty.a = 1
    empty.b = 2

    const e = empty()

    expect_fail(()=>e.a)
    expect_fail(()=>e.b)

    assert empty.a == 1
    assert empty.b == 2
}

# prototype preservation
do {
    fun get_class(a)
    {
        return class {
            constructor {
                this.a = a
            }
        }
    }

    const c1 = get_class(42)
    const c2 = get_class("xyz")

    const o1 = c1()
    const o2 = c2()

    assert o1.a == 42
    assert o2.a == "xyz"

    assert o1 instanceof c1
    assert o1 instanceof c2
    assert o2 instanceof c1
    assert o2 instanceof c2

    assert ! ("b" in o1)
    assert ! ("b" in o2)
    expect_fail(()=>o1.b)
    expect_fail(()=>o2.b)
    assert ! ("b" in c1.prototype)
    assert ! ("b" in c2.prototype)
    expect_fail(()=>c1.prototype.b)
    expect_fail(()=>c2.prototype.b)

    c1.prototype.b = 8

    assert "b" in o1
    assert "b" in o2
    assert "b" in c1.prototype
    assert "b" in c2.prototype
    assert o1.b == 8
    assert o2.b == 8
    assert o1.a == 42
    assert o2.a == "xyz"
}

# different prototypes
do {
    fun get_class(a)
    {
        return class {
            constructor {
                this.a = a
            }
            get_a {
                return this.a
            }
        }
    }

    const c1 = get_class("x")
    const c2 = get_class("y")

    const o1 = c1()
    const o2 = c2()

    assert o1.a == "x"
    assert o2.a == "y"

    assert o1 instanceof c1
    assert o2 instanceof c2
    assert ! (o1 instanceof c2)
    assert ! (o2 instanceof o1)

    c1.prototype.b = "a"
    assert ! ("b" in c2.prototype)
    c2.prototype.b = "b"

    assert o1.b == "a"
    assert o2.b == "b"
}

# changed prototype
do {
    class c1 {
        constructor {
            this.a = 3
        }
        getvalue {
            return this.a
        }
        geta {
            return -this.a
        }
    }

    class c2 {
        constructor {
            this.b = 4
        }
        getvalue {
            return this.b
        }
        getb {
            return -this.b
        }
    }

    const o1 = c1()
    const o2 = c2()

    assert o1 instanceof c1
    assert o2 instanceof c2
    assert ! (o1 instanceof c2)
    assert ! (o2 instanceof c1)

    assert o1.getvalue() == 3
    assert o2.getvalue() == 4
    assert "a" in o1
    assert "b" in o2
    assert "geta" in o1
    assert "getb" in o2
    assert o1.a == 3
    assert o2.b == 4
    assert o1.geta() == -3
    assert o2.getb() == -4

    # now swap the prototypes
    do {
        const tmp = c1.prototype
        c1.prototype = c2.prototype
        c2.prototype = tmp
    }

    assert o1 instanceof c2
    assert o2 instanceof c1
    assert ! (o1 instanceof c1)
    assert ! (o2 instanceof c2)

    assert o1.getvalue() == 3
    assert o2.getvalue() == 4
    assert "a" in o1
    assert "b" in o2
    assert "geta" in o1
    assert "getb" in o2
    assert o1.a == 3
    assert o2.b == 4
    assert o1.geta() == -3
    assert o2.getb() == -4

    const x1 = c1()
    const x2 = c2()

    assert "a" in x1
    assert "b" in x2
    assert "getb" in x1
    assert "geta" in x2
    assert x1.a == 3
    assert x2.b == 4
    expect_fail(() => x1.geta())
    expect_fail(() => x1.getb())
    expect_fail(() => x2.geta())
    expect_fail(() => x2.getb())
    expect_fail(() => x1.getvalue())
    expect_fail(() => x2.getvalue())
}

# extends
do {
    class c0 {
        a { return 1 }
        b { return 2 }
    }

    class c1 extends c0 {
        c { return 3 }
    }

    const x0 = c0()
    const x1 = c1()

    assert "a" in x0
    assert "b" in x0
    assert ! ("c" in x0)

    assert "a" in x1
    assert "b" in x1
    assert "c" in x1

    assert x0.a() == 1
    assert x0.b() == 2
    expect_fail(() => x0.c())
    assert x0 instanceof c0

    assert x1.a() == 1
    assert x1.b() == 2
    assert x1.c() == 3
    assert x1 instanceof c0
    assert x1 instanceof c1

    assert "iterator" in x0
    assert "iterator" in x1

    class c2 extends void {
        d { return 4 }
    }

    const x2 = c2()

    assert x2 instanceof c2

    assert "d" in x2
    assert ! ("iterator" in x2)
    assert x2.d() == 4
}

# Invalid extends
do {
    # Base object must be a class
    expect_fail(() => class extends true { })
    expect_fail(() => class extends 1 { })
    expect_fail(() => class extends 1.5 { })
    expect_fail(() => class extends "x" { })
    expect_fail(() => class extends {} { })
    expect_fail(() => class extends [] { })
    expect_fail(() => class extends () => { } { })
}

# extends, constructor in base, but not in derived
do {
    class b {
        constructor {
            this.x = "xyz"
        }
    }

    class d extends b {
        getx {
            return this.x
        }
    }

    const o1 = b()
    const o2 = d()

    assert o1 instanceof b
    assert ! (o1 instanceof d)

    assert o2 instanceof b
    assert o2 instanceof d

    assert "x" in o1
    assert "x" in o2

    assert ! ("getx" in o1)
    assert "getx" in o2

    assert o2.getx() == "xyz"
}

# pass arguments to base
do {
    class b {
        constructor(aa, bb) {
            this.x = aa + 1
            this.y = bb + 1
        }
    }

    class d extends b {
        constructor(m) {
            super(m * 2, m * 3)
        }
    }

    const o = d(7)

    assert o.x == 15
    assert o.y == 22
}

# multiple super constructor invocations
do {
    class Base {
        constructor {
            if "x" in this {
                this.y = this.x + 1
            }
            else {
                this.z = 42
            }
        }
    }

    class Final extends Base {
        constructor(m) {
            assert ! ("x" in this)
            assert ! ("y" in this)
            assert ! ("z" in this)

            super()

            assert ! ("x" in this)
            assert ! ("y" in this)
            assert this.z == 42

            this.x = m

            super()

            assert "x" in this
            assert "y" in this
            assert "z" in this
        }
    }

    const o = Final(101)
    assert o.x == 101
    assert o.y == 102
    assert o.z == 42
}

# pass many types of args to super constructor
do {
    const bobo = fun
    {
        var count = 0

        class dodo {
            constructor(rest) {

                this.rest = rest

                count += 1
            }
        }

        class bobo extends dodo {
            constructor(a00, a01, a02, a03, a04, a05, a06, a07, a08, a09,
                        a10, a11, a12, a13, a14, a15, a16, a17, a18, a19,
                        a20, a21, a22, a23, a24, a25, a26, a27, a28, a29,
                        a30=-30, a31=-31, a32=-32, as...) {

                this.sum = a00 + a01 + a02 + a03 + a04 + a05 + a06 + a07 + a08 + a09 +
                           a10 + a11 + a12 + a13 + a14 + a15 + a16 + a17 + a18 + a19 +
                           a20 + a21 + a22 + a23 + a24 + a25 + a26 + a27 + a28 + a29 +
                           a30 + a31 + a32

                this.id = count

                super(as)
            }
        }

        return bobo
    } ()

    var o = bobo(0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
    assert typeof o.rest == "array"
    assert o.rest.size == 0
    assert o.id == 0
    assert o.sum == -93

    o = bobo( 0,  1,  2,  3,  4,  5,  6,  7,  8,  9,
             10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
             20, 21, 22, 23, 24, 25, 26, 27, 28, 29,
             30, 31, 32, 33, 34)
    assert typeof o.rest == "array"
    assert o.rest.size == 2
    assert o.rest[0] == 33
    assert o.rest[1] == 34
    assert o.id == 1
    assert o.sum == 528

    o = bobo(1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
             1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
             1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
             1, 1, 1000, -1, -2, -3, -4, -5)
    assert typeof o.rest == "array"
    assert o.rest.size == 5
    for var i = 0; i < 5; i += 1 {
        assert o.rest[i] == -1 - i
    }
    assert o.id == 2
    assert o.sum == 1032
}

# implicitly invoke base constructor
do {
    class first {
        constructor {
            this.abc = 42
        }
    }

    class second extends first {
        constructor {
            assert "abc" in this
            assert this.abc == 42
            this.bcd = 84
        }
    }

    const o = second()
    assert o.abc == 42
    assert o.bcd == 84
}
