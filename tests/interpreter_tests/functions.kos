# SPDX-License-Identifier: MIT
# Copyright (c) 2014-2021 Chris Dragan

import base
import base.generator_end
import test_tools.expect_fail

##############################################################################

do {
    fun no_work
    {
    }

    assert no_work() == void
    assert typeof no_work() == "void"
}

do {
    fun zero_args
    {
        return 123
    }

    assert typeof zero_args == "function"

    const a = zero_args()

    assert a == 123
}

do {
    fun one_arg(a)
    {
        return a + 3
    }

    const a = one_arg(-10)

    assert a == -7

    expect_fail(()=>one_arg())
}

do {
    fun two_args(a, b)
    {
        return a + 2 * b
    }

    const a = two_args(5, 10)

    assert a == 25

    expect_fail(()=>two_args(1))
}

do {
    var a = 1

    fun(b) { a = a + b } (3)

    assert a == 4
}


do {
    var x = 0
    fun get_x
    {
        return x
    }

    assert get_x() == 0

    x = 500

    assert get_x() == 500
}

do {
    fun make(x)
    {
        var a = x + 1
        return fun(y) {
            a += y
            return a
        }
    }

    const next = make(10)
    assert typeof next == "function"
    assert next(0) == 11
    assert next(9) == 20
    assert next(3) == 23
    assert next(-20) == 3
}

public var global_a = "a"
public var global_b = "b"

do {
    var indep_c = "c"
    var indep_d = "d"

    fun depth1(x)
    {
        var indep_level1_e = x + "e"
        var indep_level1_f = x + "f"

        fun depth2(x)
        {
            var indep_level2_g = x + "g"
            var indep_level2_h = x + "h"

            fun depth3(x)
            {
                global_a =  x + "A"
                global_b += x

                indep_c =  x + "C"
                indep_d += x

                indep_level1_e =  x + "E"
                indep_level1_f += x

                indep_level2_g =  x + "G"
                indep_level2_h += x

                return [ indep_level1_e,
                         indep_level1_f,
                         indep_level2_g,
                         indep_level2_h ]
            }

            return depth3
        }

        return depth2
    }

    do {
        const d2 = depth1("%")
        const d3 = d2("^")

        assert global_a == "a"
        assert global_b == "b"
        assert indep_c  == "c"
        assert indep_d  == "d"

        const test1 = d3("$")
        assert global_a == "$A"
        assert global_b == "b$"
        assert indep_c  == "$C"
        assert indep_d  == "d$"
        assert test1[0] == "$E"
        assert test1[1] == "%f$"
        assert test1[2] == "$G"
        assert test1[3] == "^h$"

        const test2 = d3("@")
        assert global_a == "@A"
        assert global_b == "b$@"
        assert indep_c  == "@C"
        assert indep_d  == "d$@"
        assert test2[0] == "@E"
        assert test2[1] == "%f$@"
        assert test2[2] == "@G"
        assert test2[3] == "^h$@"
    }

    do {
        const d2 = depth1("#")
        const d3 = d2("!")

        assert global_a == "@A"
        assert global_b == "b$@"
        assert indep_c  == "@C"
        assert indep_d  == "d$@"

        const test3 = d3("&")
        assert global_a == "&A"
        assert global_b == "b$@&"
        assert indep_c  == "&C"
        assert indep_d  == "d$@&"
        assert test3[0] == "&E"
        assert test3[1] == "#f&"
        assert test3[2] == "&G"
        assert test3[3] == "!h&"

        do {
            const d3 = d2("*")

            const test4 = d3("?")
            assert global_a == "?A"
            assert global_b == "b$@&?"
            assert indep_c  == "?C"
            assert indep_d  == "d$@&?"
            assert test4[0] == "?E"
            assert test4[1] == "#f&?"
            assert test4[2] == "?G"
            assert test4[3] == "*h?"
        }
    }
}

do {
    fun gen
    {
        yield 100
        yield 200
        yield 300
    }

    const iter = gen()
    assert iter() == 100
    assert iter() == 200
    assert iter() == 300
    expect_fail(iter)
}

do {
    fun gen(x)
    {
        yield x+1
        yield x+2
    }

    const iter1 = gen(8)
    const iter2 = gen(20)
    assert iter1() == 9
    assert iter2() == 21
    assert iter1() == 10
    assert iter2() == 22
    expect_fail(iter1)
    expect_fail(iter2)
}

do {
    fun gen(a, b, c)
    {
        a = yield a
        b = yield a + b
        c = yield b + c
        return void
    }

    const iter = gen(2, 3, 4)
    assert iter() == 2
    assert iter(10) == 13
    assert iter(20) == 24
    expect_fail(iter)
}

do {
    fun gen
    {
        var a = yield 10
        a = yield a
        yield a
        return void
    }

    const iter = gen()
    assert iter(0) == 10
    assert iter() == void
    assert iter(20) == 20
    expect_fail(iter)
}

do {
    fun gen(a)
    {
        loop {
            a = yield a + 1
        }
    }

    expect_fail(gen)

    const iter = gen(7)
    assert iter() == 8
    assert iter(1) == 2
    assert iter(-7) == -6
    assert iter(9) == 10
}

do {
    fun gen
    {
        yield 2
        yield 4
        throw 6
    }

    const iter = gen()
    assert iter() == 2
    assert iter() == 4

    try {
        iter()
        throw "Unexpected value yielded"
    }
    catch const e {
        assert e.value == 6
    }

    var thrown = false
    try {
        iter()
    }
    catch const e {
        thrown = true
        assert e.value instanceof generator_end
    }
    assert thrown
}

do {
    fun gen
    {
        yield 2
        throw 3
        yield 5
        return 4
    }

    const iter = gen()
    assert iter() == 2

    var thrown = false
    try {
        iter()
    }
    catch const e {
        thrown = true
        assert e.value == 3
    }
    assert thrown

    thrown = false
    try {
        iter()
    }
    catch const e {
        thrown = true
        assert e.value instanceof generator_end
    }
    assert thrown
}

do {
    fun gen(a, last)
    {
        const ret = a + "1"
        var b = yield ret
        b = yield b + "2"
        const c = yield ret + b
        last.push(yield c)
    }

    const last = []
    const g = gen("x", last)
    assert g("a") == "x1"
    assert g("b") == "b2"
    assert g("c") == "x1c"
    assert g("d") == "d"
    expect_fail(() => g("e"))
    assert last.size == 1
    assert last[0] == "e"
}

do {
    var type = void
    var size = void

    fun with_ellipsis(a, b, c...)
    {
        type = typeof c
        size = c.size
    }

    with_ellipsis(1, 2, 3, 4, 5, 6)
    assert type == "array"
    assert size == 4

    with_ellipsis("x", "y")
    assert type == "array"
    assert size == 0
}

do {
    fun add_all(a...)
    {
        var sum = 0
        for var i in a {
            sum += i
        }
        return sum
    }

    assert add_all()                        == 0
    assert add_all(-10)                     == -10
    assert add_all(2000, 30)                == 2030
    assert add_all(70, 8000, 40000, 3, 900) == 48973
}

do {
    fun add_all(x, y, a...)
    {
        var sum = x + y
        for var i in a {
            sum += i
        }
        return sum
    }

    expect_fail(add_all)
    expect_fail(()=>add_all(100))
    assert add_all(10, 2)                   == 12
    assert add_all(70, 8000, 40000, 3, 900) == 48973
}

do {
    fun args_len(a...)
    {
        return a.size
    }

    assert args_len()                 == 0
    assert args_len(void, void, void) == 3
}

do {
    fun args_len(x, y, z, a...)
    {
        return a.size
    }

    assert args_len(void, void, void)             == 0
    assert args_len(void, void, void, void, void) == 2
}

do {
    fun get_index(idx, a...)
    {
        return a[idx]
    }

    assert get_index(0,  "a", "b", "c", "d", "e", "f", "g", "h") == "a"
    assert get_index(-1, "a", "b", "c", "d", "e", "f", "g", "h") == "h"
    assert get_index(5,  "a", "b", "c", "d", "e", "f", "g", "h") == "f"
}

do {
    fun elem(x, a...)
    {
        if a.size == 0 {
            a = [1]
        }
        else {
            a = elem(1, 2)
        }
        return a[x]
    }

    const result = elem(0)
    assert typeof result == "integer"
    assert result        == 1
}

do {
    fun number(a)
    {
        loop {
            yield a
        }
    }

    const one = number(1)
    const two = number(2)
    const six = number(6)
    assert one() == 1
    assert two() == 2
    assert six() == 6
    assert two() == 2
    assert one() == 1
    assert six() == 6
}

do {
    fun number(a)
    {
        const value = a
        loop {
            yield value
        }
    }

    const one = number(1)
    const two = number(2)
    const six = number(6)
    assert one() == 1
    assert two() == 2
    assert six() == 6
    assert two() == 2
    assert one() == 1
    assert six() == 6
}

do {
    var idx = 0

    fun arg(cur)
    {
        assert idx == cur
        idx += 1
    }

    fun noop
    {
    }

    noop(arg(0), arg(1), arg(2), arg(3), arg(4), arg(5), arg(6))
}

do {
    fun plus_six(x)
    {
        return
        x + 5 +
        3 -
        2
    }

    assert plus_six(3) == 9
}

do {
    fun three_args(a, b, c)
    {
        return a + b + c
    }

    var prev = 0

    fun order(pos)
    {
        assert pos > prev
        prev = pos
        return pos
    }

    three_args(order(1), order(2), order(prev * 3 + 10 > 0 ? prev * 10 : 0))

    prev = 0

    three_args(order(prev + 1 * 8 < 0 ? 1 : prev + 2), order(3), order(4))
}

# Deep expression
do {
    fun add_1(x)
    {
        return x + 1
    }

    fun expr
    {
        return 1 + 2 * add_1(
               2 + 2 * add_1(
               3 + 2 * add_1(
               4 + 2 * add_1(
               5 + 2 * add_1(
               6 + 2 * add_1(
               7 + 2 * add_1(
               8 + 2 * add_1(
               9 + 2 * add_1(
              10 + 2 * add_1(
              11 + 2 * add_1(
              12 + 2 * add_1(
              13 + 2 * add_1(
              14 + 2 * add_1(
              15 + 2 * add_1(
              16 + 2 * add_1(
              17 + 2 * add_1(
              18 + 2 * add_1(
              19 + 2 * add_1(
              20 + 2 * add_1(
              21 + 2 * add_1(
              22 + 2 * add_1(
              23 + 2 * add_1(
              24 + 2 * add_1(
              25 + 2 * add_1(
              26 + 2 * add_1(
              27 + 2 * add_1(
              28 + 2 * add_1(
              29 + 2 * add_1(
              30 + 2 * add_1(
              31 + 2 * add_1(
              32 + 2 * add_1(
              33))))))))))))))))))))))))))))))))
    }

    fun recursive(x, stop)
    {
        if x == stop {
            return stop
        }
        return x + 2 * add_1(recursive(x+1, stop))
    }

    assert expr() == recursive(1, 33)
}

do {
    fun add(x, y)
    {
        return x + y
    }

    var accum = 1
    accum     = add(accum, 2)

    assert accum == 3
}

do {
    var obj = fun(x, y) { return x + y }
    obj     = obj(4, -1)

    assert obj == 3
}

do {
    var obj = {
        a: 12,
        f: () => this.a + 1
    }
    obj = obj.f()
    assert obj == 13
}

public var global = 1
do {
    var global = global + 9
    assert global == 10
    fun f
    {
        var global = global + 10
        assert global == 20
        var count = 0
        do {
            var global = global + 10
            while global == 30 {
                try {
                    defer {
                        global += 3
                    }
                    assert global == 30
                    do {
                        const global = global + 10
                        assert global == 40
                    }
                    assert global == 30
                    count += 1
                    throw global + 5
                    count += 1
                }
                catch const global {
                    assert global.value == 35
                }
                assert global == 33
                global += 1
            }
        }
        assert count  == 1
        assert global == 20
    }
    f()
    assert global == 10
    f()
}
assert global == 1

do {
    # The only case when using the variable in the expression is allowed
    const recurse = fun(level) {
        if level == 0 {
            return recurse(1) * 10
        }
        return 2
    }
    assert recurse(0) == 20
}

do {
    fun outer(a, b)
    {
        return fun {
            return b
        }
    }

    assert outer(1, 2)()      == 2
    assert outer(void, "x")() == "x"
}

do {
    fun outer(a...)
    {
        return fun {
            return a
        }
    }

    const a1 = outer(1, 2, 3)()
    assert typeof a1 == "array"
    assert a1.size   == 3
    assert a1[0]     == 1
    assert a1[1]     == 2
    assert a1[2]     == 3
}

do {
    fun outer(x, a...)
    {
        return fun {
            return a
        }
    }

    const a1 = outer("skip", void, "m")()
    assert typeof a1 == "array"
    assert a1.size   == 2
    assert a1[0]     == void
    assert a1[1]     == "m"
}

do {
    fun add_21(x)
    {
        return x + 21
    }

    fun shl_1(x)
    {
        return x << 1
    }

    fun to_str(x)
    {
        return "\(x)";
    }

    const result = 5.1 -> shl_1 -> add_21 -> to_str

    assert result == "31"
}

do {
    fun add_5(source)
    {
        for var elem in source {
            yield elem + 5
        }
    }

    fun mul_3(source)
    {
        for var elem in source {
            yield elem * 3
        }
    }

    const iter = [4, -2, 1] -> mul_3 -> add_5

    assert typeof iter == "function"
    assert iter()      == 17
    assert iter()      == -1
    assert iter()      == 8
    expect_fail(iter)
}

do {
    const a = 10;
    const result = a -> x => x/2
    assert result == 5
}

# stream operator with refinement
do {
    class c1 {
        constructor {
            this.x = void
        }
        set1(x) {
            this.x = x
            return x + 1
        }
    }

    class c2 {
        constructor {
            this.x = void
        }
        set2(x) {
            this.x = x * 10
            return x + 2
        }
    }

    const o1 = c1()
    const o2 = c2()

    const result = 5 -> o1.set1 -> o2.set2

    assert o1.x   == 5
    assert o2.x   == 60
    assert result == 8
}

# call finished generator
do {
    fun gen
    {
        yield 42
    }

    const iter = gen()
    assert iter() == 42
    expect_fail(()=>iter())
    expect_fail(()=>iter())
}

# call non-generator function like a generator
do {
    fun not_gen
    {
    }

    expect_fail(fun {
        var a = 0
        for var i in not_gen {
            a += i
        }
        return a
    })
}

# call constructor function like a generator
do {
    class not_gen { }

    expect_fail(fun {
        var a = 0
        for var i in not_gen {
            a += i
        }
        return a
    })
}

# call generator from itself
do {
    fun gen
    {
        var x = yield 0
        yield x()
    }

    var it = gen()
    assert it(it) == 0
    var except = void
    try {
        it(it)
    }
    catch const e {
        except = e
    }
    assert except != void
}

# lots of arguments
do {
    fun lots_of_args(a0, args...)
    {
        var prev = a0
        for const i in base.range(args.size) {
            assert prev + 1 == args[i]
            prev = args[i]
        }
    }
    lots_of_args(  1,   2,   3,   4,   5,   6,   7,   8,   9,  10,
                  11,  12,  13,  14,  15,  16,  17,  18,  19,  20,
                  21,  22,  23,  24,  25,  26,  27,  28,  29,  30,
                  31,  32,  33,  34,  35,  36,  37,  38,  39,  40,
                  41,  42,  43,  44,  45,  46,  47,  48,  49,  50,
                  51,  52,  53,  54,  55,  56,  57,  58,  59,  60,
                  61,  62,  63,  64,  65,  66,  67,  68,  69,  70,
                  71,  72,  73,  74,  75,  76,  77,  78,  79,  80,
                  81,  82,  83,  84,  85,  86,  87,  88,  89,  90,
                  91,  92,  93,  94,  95,  96,  97,  98,  99, 100,
                 101, 102, 103, 104, 105, 106, 107, 108, 109, 110,
                 111, 112, 113, 114, 115, 116, 117, 118, 119, 120,
                 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,
                 131, 132, 133, 134, 135, 136, 137, 138, 139, 140,
                 141, 142, 143, 144, 145, 146, 147, 148, 149, 150,
                 151, 152, 153, 154, 155, 156, 157, 158, 159, 160,
                 161, 162, 163, 164, 165, 166, 167, 168, 169, 170,
                 171, 172, 173, 174, 175, 176, 177, 178, 179, 180,
                 181, 182, 183, 184, 185, 186, 187, 188, 189, 190,
                 191, 192, 193, 194, 195, 196, 197, 198, 199, 200)
}

# independent argument from two functions up
do {
    fun f1(a)
    {
        fun f2(b)
        {
            fun f3(c)
            {
                return a + b + c
            }
            return f3
        }
        return f2
    }
    const x = f1(20)
    const y = x(400)
    const z = y(1000)
    assert z == 1420
}

# bind to a variable and access it later (JS's setTimeout pitfall)
do {
    fun n_times(n)
    {
        var later = []
        var i     = 0
        while (i < n) {
            later.push(()=>i)
            i += 1
        }
        return later
    }

    const later = n_times(4)

    assert later.size == 4
    assert later[0]() == 4
    assert later[1]() == 4
    assert later[2]() == 4
    assert later[3]() == 4
}

# function node promoted during optimization
do {
    fun f(x)
    {
        return false ? void :
            fun(arg)
            {
                const op = x
                arg[0] = op
            }
    }

    const a = [ 0 ]
    f(10)(a)
    assert typeof a == "array"
    assert a.size == 1
    assert a[0] == 10
}

# test for correct processing of ?: with arguments
do {
    fun f(x)
    {
        return ! x ? void :
            fun(arg)
            {
                arg[0] = x
            }
    }

    const a = [ 0 ]
    f(10)(a)
    assert typeof a == "array"
    assert a.size == 1
    assert a[0] == 10
}

# mix tail call optimization with independent variables
do {
    fun outer(a)
    {
        const b = a + 1
        fun inner
        {
            return () => a * b
        }
        return inner()
    }

    assert outer(5)()  == 30
    assert outer(-7)() == 42
}

# call a non-callable
do {
    expect_fail((()=>()=>3) () ())
}

# independent variable from inner scope must not be reused
do {
    fun test
    {
        const obj = { }

        do {
            const v = 42

            obj.f = fun {
                assert v == 42
                return v + 1
            }
        }

        do {
            assert obj.f() == 43
            assert obj.f() == 43
        }
    }

    test()
}

# default arguments
do {
    fun defaults(a = 1, b = 10, c = 100, d = 1000)
    {
        return a + b + c + d
    }

    assert defaults()           == 1111
    assert defaults(5)          == 1115
    assert defaults(2, 2)       == 1104
    assert defaults(3, 5, 7)    == 1015
    assert defaults(2, 2, 2, 2) == 8
}

# mixture of default and non-default arguments
do {
    fun defaults(a, b=2, c=3, d...)
    {
        var sum = a + b + c
        for var x in d {
            sum += x
        }
        return sum
    }

    expect_fail(()=>defaults())

    assert defaults(0)                == 5
    assert defaults(1)                == 6
    assert defaults(1, 20, 300)       == 321
    assert defaults(0, 0, 0, 10, 200) == 210
    assert defaults(1000, 200, 30, 4) == 1234
}

# mixture of default arguments and independent variables
do {
    fun defaults(a, b=2, c=void)
    {
        var d = a + b
        fun {
            if c != void {
                d += c
            }
        } ()
        return d
    }

    expect_fail(()=>defaults())

    assert defaults(1)          == 3
    assert defaults(20, 300)    == 320
    assert defaults(100, 20, 3) == 123
}

# default arguments with side effects
do {
    var count = 0

    fun increment
    {
        count += 1
        return count
    }

    fun defaults(x = increment())
    {
        return x
    }

    assert defaults()     == 1
    assert defaults()     == 1
    assert defaults(void) == void
    assert defaults()     == 1
    assert defaults()     == 1
    assert count == 1

    fun unused_defaults(a, x = increment())
    {
        return a
    }

    assert count == 2
    assert unused_defaults(4) == 4
    assert count == 2
    assert unused_defaults(5) == 5
    assert count == 2

    fun lots_of_unused_defaults(a0,  a1,  a2,  a3,  a4,  a5,  a6,  a7,  a8,  a9,
                                a10, a11, a12, a13, a14, a15, a16, a17, a18, a19,
                                a20, a21, a22, a23, a24, a25, a26, a27, a28, a29,
                                a30, a31, a32, a33, a34, a35, a36, a37, a38, a39,
                                a40 = 42, a41 = 2 + increment() * 3, a42 = 44)
    {
        return a0 + a1
    }

    const args = [ 100, 101, 102, 103, 104, 105, 106, 107, 108, 109,
                   110, 111, 112, 113, 114, 115, 116, 117, 118, 119,
                   120, 121, 122, 123, 124, 125, 126, 127, 128, 129,
                   130, 131, 132, 133, 134, 135, 136, 137, 138, 139,
                   140, 141, 142, 143, 144, 145, 146, 147, 148, 149 ]

    assert lots_of_unused_defaults.apply(void, args) == 201
    assert count == 3
}

# unused default arguments with side effects
# use globals to avoid closures
public var unused_default_counter = 0
public fun add_to_unused_default_counter(x)
{
    unused_default_counter += x
}
do {
    fun container1(incr_value)
    {
        fun unused1(x = 1, y = add_to_unused_default_counter(incr_value), z = 2)
        {
            return void
        }

        return unused1
    }

    assert unused_default_counter == 0
    const f1 = container1(5)
    assert unused_default_counter == 5
    const a1 = f1("a", "b", "c", "d", "e", "f")
    assert a1 == void
}
do {
    fun container2(incr_value)
    {
        fun unused2(x = 1, y = add_to_unused_default_counter(incr_value * 2), z = 2, all...)
        {
            return [all...]
        }

        return unused2
    }

    assert unused_default_counter == 5
    const f1 = container2(2)
    assert unused_default_counter == 9
    const a1 = f1("a", "b", "c", "d", "e", "f")
    assert typeof a1 == "array"
    assert a1.size == 3
    assert a1[0] == "d"
    assert a1[1] == "e"
    assert a1[2] == "f"
}

# test correct placement of arguments for generator with independent variables
do {
    fun args_and_indep_vars(input)
    {
        const brackets = input + 1

        fun save()
        {
            return brackets
        }

        yield input
        yield save
    }
    const it = args_and_indep_vars(12)
    assert it()   == 12
    assert it()() == 13
    expect_fail(it)
}

# early end generator during a for-in loop
do {
    fun gen
    {
        yield 10
        yield 20
        fun break_from_gen
        {
            return void
            yield 1
        }
        break_from_gen()()
        yield 1
        yield 2
    }
    var expected = 10
    for var elem in gen() {
        assert elem == expected
        expected += 10
    }
    assert expected == 30
}

# end generator during for-in loop via modified exception
do {
    fun gen
    {
        yield "a"
        yield "b"
        try {
            throw void
        }
        catch const e {
            delete e.value
            e.proof = "hello"
            throw e
        }
        yield "c"
    }

    const items = []
    var   ex    = void

    try {
        for const elem in gen() {
            items.push(elem)
        }
    }
    catch const e {
        ex = e
    }

    assert items.size == 2
    assert items[0]   == "a"
    assert items[1]   == "b"
    assert typeof ex  == "object"
    assert ! ("value" propertyof ex)
    assert "proof" propertyof ex
    assert "proof" in ex
    assert ex.proof == "hello"
}

# break generator with a exception during for-in loop
do {
    fun gen
    {
        yield 8
        throw "finished"
    }

    const items = []
    var   ex    = void

    try {
        for const elem in gen() {
            items.push(elem)
        }
    }
    catch const e {
        ex = e
    }

    assert items.size == 1
    assert items[0]   == 8
    assert ex.value   == "finished"
}

# generator.prototype.next function
do {
    fun gen
    {
        yield 1
        yield 2
        yield 3
        yield 4
    }

    const it = gen()
    assert it() == 1
    assert it.next() == 2
    assert it() == 3
    assert it.next() == 4
    expect_fail(() => it.next())
}

# incorrect uses of generator.prototype.next function
do {
    fun gen { yield 42 }

    assert gen.next.apply(gen(), []) == 42

    expect_fail(() => gen.next.apply(fun{}, []))
    expect_fail(() => gen.next.apply(class{}, []))
    expect_fail(() => gen.next.apply(gen, []))
    expect_fail(() => gen.next())
}

# pass argument through generator.prototype.next function
do {
    fun gen(a)
    {
        a.push(yield 1)
        a.push(yield 2)
    }

    var a = []
    const it = gen(a)
    assert it("a") == 1
    assert it("b") == 2
    expect_fail(() => it("c"))

    assert a.size == 2
    assert a[0] == "b"
    assert a[1] == "c"
}

# test generator state
do {
    var it = void

    fun gen(a)
    {
        a.push(it.state)
        a.push(yield 1)
        a.push(yield 2)
        a.push(it.state)
    }

    var a = []
    it = gen(a)

    assert gen instanceof base.generator
    assert gen.state == "init"
    assert it instanceof base.generator
    assert it.state == "ready"
    assert a.size == 0

    assert it("a") == 1
    assert it.state == "active"
    assert a.size == 1
    assert a[0] == "running"

    assert it("b") == 2
    assert it.state == "active"
    assert a.size == 2
    assert a[0] == "running"
    assert a[1] == "b"

    expect_fail(() => it("c"))
    assert it.state == "done"
    assert a.size == 4
    assert a[0] == "running"
    assert a[1] == "b"
    assert a[2] == "c"
    assert a[3] == "running"

    expect_fail(() => base.generator.prototype.state)
}

# pass function as a default arg
do {
    fun do_something(x, something = x => x + 1)
    {
        return something(x)
    }

    assert do_something(5) == 6
    assert do_something(5, x => x - 1) == 4
}

# arg referenced in inner function's default arg
do {
    var x = 1

    fun my(arg)
    {
        fun with_default(def = () => arg + x)
        {
            return def()
        }
        return with_default
    }

    const f1 = my(5)
    assert f1() == 6
    assert f1() == 6
    x = -3
    assert f1() == 2

    const f2 = my(10)
    assert f2() == 7
}

# arg referenced in inner function's default arg
do {
    fun add(a, b)
    {
        fun plus_1(def = () => a + 1)
        {
            return def()
        }
        return plus_1() + b
    }

    assert add(5, 8) == 14
    assert add(-4, 4) == 1
}

# expanded arguments
do {
    fun gen1
    {
        yield "a"
        yield 10.5
    }
    fun gen2(x)
    {
        for const i in base.range(x) {
            yield i
        }
    }
    fun yield_args(args...)
    {
        for const v in args {
            yield v
        }
    }
    do {
        const a = [1, 2, 3]
        const it = yield_args(8, a..., gen1(), gen1()..., typeof void ..., gen2(3)...)
        assert it() == 8
        assert it() == 1
        assert it() == 2
        assert it() == 3
            const f = it()
            assert typeof f == "function"
            assert f() == "a"
            assert f() == 10.5
            expect_fail(f)
        assert it() == "a"
        assert it() == 10.5
        assert it() == "v"
        assert it() == "o"
        assert it() == "i"
        assert it() == "d"
        assert it() == 0
        assert it() == 1
        assert it() == 2
        expect_fail(it)
    }
    do {
        fun expand(a)
        {
            a = [a...]
            return a
        }
        const a = expand([10, 20, 30])
        assert typeof a == "array"
        assert a.size == 3
        assert a[0] == 10
        assert a[1] == 20
        assert a[2] == 30
    }
}

# expand args and return array
do {
    fun return_args(a, b, c, d...)
    {
        return [a, d..., b, c]
    }
    do {
        const a = return_args(1, "str"..., 2)
        assert typeof a == "array"
        assert a.size == 5
        assert a[0] == 1
        assert a[1] == "r"
        assert a[2] == 2
        assert a[3] == "s"
        assert a[4] == "t"
    }
}

# expand args multiple times
do {
    fun invoke_aba(f, a, b)
    {
        return f(a..., b..., a...)
    }

    fun plus_1(a...)
    {
        return a.map(x => x+1)
    }

    const it = invoke_aba(plus_1, [1, 5], [10, 20])
    assert it() == 2
    assert it() == 6
    assert it() == 11
    assert it() == 21
    assert it() == 2
    assert it() == 6
    expect_fail(it)
}

# cannot expand these
do {
    fun f { }
    expect_fail(() => f(1 ...))
    expect_fail(() => f(1.5...))
    expect_fail(() => f(false...))
    expect_fail(() => f(void...))
    expect_fail(() => f({}...))
    expect_fail(() => f(fun{}...))
}

# throw exception during function argument expansion
do {
    var value     = void
    var exception = void

    fun set_value
    {
        value = 7
    }

    fun will_throw
    {
        yield 23
        throw 29
    }

    try {
        set_value(will_throw()...)
    }
    catch const e {
        exception = e.value
    }

    assert exception    == 29
    assert typeof value == "void"
}

# expand generator into array
do {
    fun gen(a, b)
    {
        for const i in base.range(a, b) {
            yield i
        }
    }

    const a = [ gen(5, 8) ... ]
    assert typeof a == "array"
    assert a.size == 3
    assert a[0] == 5
    assert a[1] == 6
    assert a[2] == 7

    const b = [ gen(5, 5) ... ]
    assert typeof b == "array"
    assert b.size == 0

    const c = [ gen, gen(1, 2) ]
    assert typeof c == "array"
    assert c.size == 2
    assert c[0] == gen
    assert typeof c[1] == "function"
    assert c[1]() == 1
    expect_fail(c[1])

    const gen_d = gen(2, 5)
    const d = [ gen_d..., gen_d..., gen_d..., 0, gen_d... ]
    assert typeof d == "array"
    assert d.size == 4
    assert d[0] == 2
    assert d[1] == 3
    assert d[2] == 4
    assert d[3] == 0
}

# set prototype on constructor
do {
    class c1 { }

    const c2 = class { }

    c1.prototype = c2
    c2.prototype = c1
}

# set prototype on regular function
do {
    fun f
    {
    }

    expect_fail(fun { f.prototype = {} })
}

# set prototype on generator
do {
    fun g
    {
        yield void
    }

    expect_fail(fun { g.prototype = {} })
}

# dynamic prototype
do {
    const proto1 = { x: 1 }
    const proto2 = { y: 2 }

    fun obj_with_proto(proto)
    {
        class ctor { }
        ctor.prototype = proto
        return ctor()
    }

    const o1 = obj_with_proto(proto1)
    const o2 = obj_with_proto(proto2)

    assert o1.x == 1
    assert o2.y == 2
}

# ellipsis after lots of args
do {
    fun the_call(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15,
                 b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15,
                 c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15,
                 d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15,
                 e0, e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11, e12, e13, e14, e15,
                 f0, f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12, f13, f14, f15,
                 g0, g1, g2, g3, g4, g5, g6, g7, g8, g9, g10, g11, g12, g13, g14, g15,
                 h0, h1, h2, h3, h4, h5, h6, h7, h8, h9, h10, h11, h12, h13, h14, h15,
                 rest...)
    {
        return rest.reduce((x, y) => x + y, 0)
    }

    const args = [ base.range(200) ... ]

    const result = the_call.apply(void, args)

    assert result == ((199 * 200) >> 1) - ((127 * 128) >> 1)
}

# default values for lots and lots of args
do {
    fun the_call(a000=0X000, a001=0X001, a002=0X002, a003=0X003, a004=0X004, a005=0X005, a006=0X006, a007=0X007, a008=0X008, a009=0X009, a00A=0X00A, a00B=0X00B, a00C=0X00C, a00D=0X00D, a00E=0X00E, a00F=0X00F,
                 a010=0X010, a011=0X011, a012=0X012, a013=0X013, a014=0X014, a015=0X015, a016=0X016, a017=0X017, a018=0X018, a019=0X019, a01A=0X01A, a01B=0X01B, a01C=0X01C, a01D=0X01D, a01E=0X01E, a01F=0X01F,
                 a020=0X020, a021=0X021, a022=0X022, a023=0X023, a024=0X024, a025=0X025, a026=0X026, a027=0X027, a028=0X028, a029=0X029, a02A=0X02A, a02B=0X02B, a02C=0X02C, a02D=0X02D, a02E=0X02E, a02F=0X02F,
                 a030=0X030, a031=0X031, a032=0X032, a033=0X033, a034=0X034, a035=0X035, a036=0X036, a037=0X037, a038=0X038, a039=0X039, a03A=0X03A, a03B=0X03B, a03C=0X03C, a03D=0X03D, a03E=0X03E, a03F=0X03F,
                 a040=0X040, a041=0X041, a042=0X042, a043=0X043, a044=0X044, a045=0X045, a046=0X046, a047=0X047, a048=0X048, a049=0X049, a04A=0X04A, a04B=0X04B, a04C=0X04C, a04D=0X04D, a04E=0X04E, a04F=0X04F,
                 a050=0X050, a051=0X051, a052=0X052, a053=0X053, a054=0X054, a055=0X055, a056=0X056, a057=0X057, a058=0X058, a059=0X059, a05A=0X05A, a05B=0X05B, a05C=0X05C, a05D=0X05D, a05E=0X05E, a05F=0X05F,
                 a060=0X060, a061=0X061, a062=0X062, a063=0X063, a064=0X064, a065=0X065, a066=0X066, a067=0X067, a068=0X068, a069=0X069, a06A=0X06A, a06B=0X06B, a06C=0X06C, a06D=0X06D, a06E=0X06E, a06F=0X06F,
                 a070=0X070, a071=0X071, a072=0X072, a073=0X073, a074=0X074, a075=0X075, a076=0X076, a077=0X077, a078=0X078, a079=0X079, a07A=0X07A, a07B=0X07B, a07C=0X07C, a07D=0X07D, a07E=0X07E, a07F=0X07F,
                 a080=0X080, a081=0X081, a082=0X082, a083=0X083, a084=0X084, a085=0X085, a086=0X086, a087=0X087, a088=0X088, a089=0X089, a08A=0X08A, a08B=0X08B, a08C=0X08C, a08D=0X08D, a08E=0X08E, a08F=0X08F,
                 a090=0X090, a091=0X091, a092=0X092, a093=0X093, a094=0X094, a095=0X095, a096=0X096, a097=0X097, a098=0X098, a099=0X099, a09A=0X09A, a09B=0X09B, a09C=0X09C, a09D=0X09D, a09E=0X09E, a09F=0X09F,
                 a0A0=0X0A0, a0A1=0X0A1, a0A2=0X0A2, a0A3=0X0A3, a0A4=0X0A4, a0A5=0X0A5, a0A6=0X0A6, a0A7=0X0A7, a0A8=0X0A8, a0A9=0X0A9, a0AA=0X0AA, a0AB=0X0AB, a0AC=0X0AC, a0AD=0X0AD, a0AE=0X0AE, a0AF=0X0AF,
                 a0B0=0X0B0, a0B1=0X0B1, a0B2=0X0B2, a0B3=0X0B3, a0B4=0X0B4, a0B5=0X0B5, a0B6=0X0B6, a0B7=0X0B7, a0B8=0X0B8, a0B9=0X0B9, a0BA=0X0BA, a0BB=0X0BB, a0BC=0X0BC, a0BD=0X0BD, a0BE=0X0BE, a0BF=0X0BF,
                 a0C0=0X0C0, a0C1=0X0C1, a0C2=0X0C2, a0C3=0X0C3, a0C4=0X0C4, a0C5=0X0C5, a0C6=0X0C6, a0C7=0X0C7, a0C8=0X0C8, a0C9=0X0C9, a0CA=0X0CA, a0CB=0X0CB, a0CC=0X0CC, a0CD=0X0CD, a0CE=0X0CE, a0CF=0X0CF,
                 a0D0=0X0D0, a0D1=0X0D1, a0D2=0X0D2, a0D3=0X0D3, a0D4=0X0D4, a0D5=0X0D5, a0D6=0X0D6, a0D7=0X0D7, a0D8=0X0D8, a0D9=0X0D9, a0DA=0X0DA, a0DB=0X0DB, a0DC=0X0DC, a0DD=0X0DD, a0DE=0X0DE, a0DF=0X0DF,
                 a0E0=0X0E0, a0E1=0X0E1, a0E2=0X0E2, a0E3=0X0E3, a0E4=0X0E4, a0E5=0X0E5, a0E6=0X0E6, a0E7=0X0E7, a0E8=0X0E8, a0E9=0X0E9, a0EA=0X0EA, a0EB=0X0EB, a0EC=0X0EC, a0ED=0X0ED, a0EE=0X0EE, a0EF=0X0EF,
                 a0F0=0X0F0, a0F1=0X0F1, a0F2=0X0F2, a0F3=0X0F3, a0F4=0X0F4, a0F5=0X0F5, a0F6=0X0F6, a0F7=0X0F7, a0F8=0X0F8, a0F9=0X0F9, a0FA=0X0FA, a0FB=0X0FB, a0FC=0X0FC, a0FD=0X0FD, a0FE=0X0FE)
    {
        var a = a000 + a001 + a002 + a003 + a004 + a005 + a006 + a007 + a008 + a009 + a00A + a00B + a00C + a00D + a00E + a00F +
                a010 + a011 + a012 + a013 + a014 + a015 + a016 + a017 + a018 + a019 + a01A + a01B + a01C + a01D + a01E + a01F +
                a020 + a021 + a022 + a023 + a024 + a025 + a026 + a027 + a028 + a029 + a02A + a02B + a02C + a02D + a02E + a02F +
                a030 + a031 + a032 + a033 + a034 + a035 + a036 + a037 + a038 + a039 + a03A + a03B + a03C + a03D + a03E + a03F
        a +=    a040 + a041 + a042 + a043 + a044 + a045 + a046 + a047 + a048 + a049 + a04A + a04B + a04C + a04D + a04E + a04F +
                a050 + a051 + a052 + a053 + a054 + a055 + a056 + a057 + a058 + a059 + a05A + a05B + a05C + a05D + a05E + a05F +
                a060 + a061 + a062 + a063 + a064 + a065 + a066 + a067 + a068 + a069 + a06A + a06B + a06C + a06D + a06E + a06F +
                a070 + a071 + a072 + a073 + a074 + a075 + a076 + a077 + a078 + a079 + a07A + a07B + a07C + a07D + a07E + a07F
        a +=    a080 + a081 + a082 + a083 + a084 + a085 + a086 + a087 + a088 + a089 + a08A + a08B + a08C + a08D + a08E + a08F +
                a090 + a091 + a092 + a093 + a094 + a095 + a096 + a097 + a098 + a099 + a09A + a09B + a09C + a09D + a09E + a09F +
                a0A0 + a0A1 + a0A2 + a0A3 + a0A4 + a0A5 + a0A6 + a0A7 + a0A8 + a0A9 + a0AA + a0AB + a0AC + a0AD + a0AE + a0AF +
                a0B0 + a0B1 + a0B2 + a0B3 + a0B4 + a0B5 + a0B6 + a0B7 + a0B8 + a0B9 + a0BA + a0BB + a0BC + a0BD + a0BE + a0BF
        a +=    a0C0 + a0C1 + a0C2 + a0C3 + a0C4 + a0C5 + a0C6 + a0C7 + a0C8 + a0C9 + a0CA + a0CB + a0CC + a0CD + a0CE + a0CF +
                a0D0 + a0D1 + a0D2 + a0D3 + a0D4 + a0D5 + a0D6 + a0D7 + a0D8 + a0D9 + a0DA + a0DB + a0DC + a0DD + a0DE + a0DF +
                a0E0 + a0E1 + a0E2 + a0E3 + a0E4 + a0E5 + a0E6 + a0E7 + a0E8 + a0E9 + a0EA + a0EB + a0EC + a0ED + a0EE + a0EF +
                a0F0 + a0F1 + a0F2 + a0F3 + a0F4 + a0F5 + a0F6 + a0F7 + a0F8 + a0F9 + a0FA + a0FB + a0FC + a0FD + a0FE
        return a
    }

    const result = the_call(7)

    assert result == 7 + ((254 * 255) >> 1)
}

# call itself
do {
    fun self(x)
    {
        if x == 0 {
            return 42
        }
        return self(x - 1)
    }

    assert self(10) == 42
}

# call itself via bind
do {
    fun self(x)
    {
        fun inner
        {
            return self(8)
        }
        if x == 0 {
            return inner()
        }
        else {
            return x + 3
        }
    }

    assert self(1) == 4
    assert self(0) == 11
}

# call itself via arg
do {
    fun self
    {
        return "widget"
    }

    do {
        fun self(x = self())
        {
            return x
        }

        assert self(1) == 1
        assert self()  == "widget"
    }

    do {
        fun self(x = () => self())
        {
            return x
        }

        assert self(10) == 10
        const f = self()
        assert typeof f == "function"
        assert f() == "widget"
    }
}

# call itself, binds occur later in the function
do {
    fun contained(ext)
    {
        fun self(idx)
        {
            if idx {
                return self(idx - 1)
            }
            return ext + 1
        }

        return self(1)
    }

    assert contained(3) == 4
}

# ensure independent variable is preserved across separate binds
do {
    fun get_closure(a)
    {
        var b = a + 1
        return fun { b += 1; return b }
    }

    const f1 = get_closure(10)
    const f2 = get_closure(200)

    assert f1() == 12
    assert f2() == 202
    assert f1() == 13
    assert f2() == 203
}

# ensure independent argument is preserved across separate binds
do {
    fun get_closure(a, b)
    {
        b += a
        return fun { b += 1; return b }
    }

    const f1 = get_closure(10, 1)
    const f2 = get_closure(200, 1)

    assert f1() == 12
    assert f2() == 202
    assert f1() == 13
    assert f2() == 203
}

# ensure independent ellipsis is preserved across separate binds
do {
    fun get_closure(a, b...)
    {
        b[0] += a
        return fun { b[0] += 1; return b[0] }
    }

    const f1 = get_closure(10, 1)
    const f2 = get_closure(200, 1)

    assert f1() == 12
    assert f2() == 202
    assert f1() == 13
    assert f2() == 203
}

# ensure independent ellipsis is preserved across separate binds
do {
    fun get_closure(b...)
    {
        b[0] += 1
        return fun { b[0] += 1; return b[0] }
    }

    const a1 = [10]
    const a2 = [200]

    const f1 = get_closure.apply(void, a1)
    const f2 = get_closure.apply(void, a2)

    assert f1() == 12
    assert f2() == 202
    assert f1() == 13
    assert f2() == 203
    assert a1[0] == 10
    assert a2[0] == 200
}

# independent variables inside a constructor
do {
    var o = { }
    assert ! ("x" propertyof o)
    class {
        constructor(arg) {
            class {
                constructor {
                    arg.x = 42
                }
            } ()
        }
    } (o)
    assert o["x"] == 42
}

# shadowing (test case from fuzzer)
do {
    const foo = 0
    do {
        fun { return foo }
        const foo = fun { }
    }
}

# shadowing
do {
    var foo = 0
    var bar = 0
    do {
        fun { foo |= 1 }
        fun { foo |= 2 } ()
        assert typeof foo == "integer"
        const foo = fun { bar |= 4 }
        assert typeof foo == "function"
        foo()
    }
    assert foo == 2
    assert bar == 4
}

# invoke with argument which generates its own register
# (test case from fuzzer)
do {
    const value = ((x,y)=>x+y)("abc"[1:], "d")
    assert value == "bcd"
}

# Raw return
do {
    if (() => false) () {
        return false
    }
}

# Chained lambdas
do {
    const lambda = x => (y , z) => w => x * 1000 + y * 100 + z * 10 + w

    assert lambda(8)(2,5)(3) == 8253
}

# Independent args which don't fit in registers
do {
    fun lots_of_args(a00, a01, a02, a03, a04, a05, a06, a07, a08, a09, a0a, a0b, a0c, a0d, a0e, a0f,
                     a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a1a, a1b, a1c, a1d, a1e, a1f,
                     a20, a21, a22, a23, a24, a25, a26, a27, a28, a29, a2a, a2b, a2c, a2d, a2e, a2f,
                     a30, a31, a32, a33, a34, a35, a36, a37, a38, a39, a3a, a3b, a3c, a3d, a3e, a3f,
                     a40)
    {
        const sum1 = a00 * 1000 + a40
        var   sum2 = void

        fun update(x1, x2)
        {
            fun inner
            {
                a00 += x1
                a40 += x2
                sum2 = x1 * 1000 + x2
            }

            return inner()
        }

        update(a01, a3f)

        const sum3 = a00 * 1000 + a40

        return [sum1, sum2, sum3]
    }

    const a1, a2, a3 = lots_of_args(1, 2, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
                                    9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
                                    9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
                                    9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 3,
                                    4)

    assert a1 == 1004
    assert a2 == 2003
    assert a3 == 3007
}

# Unused default args
do {
    var thing = void

    fun touch(x)
    {
        thing = x
    }

    fun dummy(a, b = touch(42))
    {
        return a + 1
    }

    assert thing == 42
    thing = void
    assert dummy(10) == 11
    assert thing == void
}

# Unused default args and a closure
do {
    fun less_than(a, b)
    {
        fun greater_than_a(b, c = 4)
        {
            return b > a
        }

        return greater_than_a(b)
    }

    assert less_than(1, 2)
    assert ! less_than(5, -5)
}

# Closure used only for storing data
do {
    fun external
    {
        var a = 0

        return fun(x)
        {
            a += x
        }
    }

    const f = external()
    f(1)
    f(2)
}

# Closures and constructors
do {
    fun make_it(z)
    {
        var a = 101

        fun inner(y)
        {
            var b = 102

            class Base
            {
                constructor
                {
                    this.c = 103
                }
            }

            class Derived extends Base
            {
                constructor(x)
                {
                    super()
                    a += x
                    this.a = a
                    b += x
                    this.b = b
                }
            }

            return Derived(y)
        }

        return inner(z)
    }

    const o = make_it(30)

    assert o.a == 131
    assert o.b == 132
    assert o.c == 103
}

# Writes to variable which is never read should be optimized out
# Test case from fuzzer.
do {
    fun {
        var a = void
        fun {
            a = 42
        }
        . size
    } ()
}

# Super with stream operator
do {
    var value = void

    class call_super_base {
        constructor(x) {
            value = x
        }
    }

    class call_super extends call_super_base {
        constructor(x) {
            x + 1 -> super
        }
    }

    assert value == void
    call_super(55)
    assert value == 56
}

# Named args
do {
    fun add(first, second)
    {
        return first + second
    }

    assert add(1, 2) == 3
    assert add(second=3, first=10) == 13
    expect_fail(fun { add(first=1) })
    expect_fail(fun { add(second=1) })
    expect_fail(fun { add(first=1, second=2, third=3) })

    fun add_with_def(first, second = 1, third = 10, fourth = 100)
    {
        return first + second + third + fourth
    }

    assert add_with_def(0)                          == 111
    assert add_with_def(first = 2000)               == 2111
    assert add_with_def(second = 3, first = 4000)   == 4113
    assert add_with_def(third = 20, first = 3000)   == 3121
    assert add_with_def(first = 9000, fourth = 200) == 9211
}

# Recursion
do {
    const max_level = 5

    fun spawn(level = 0)
    {
        if (level < max_level) {
            return spawn(level + 1)
        }
        return level
    }

    assert spawn(0) == 5
}

# Closure used via self-referencing function
do {
    fun level0(a)
    {
        fun level1
        {
            fun level2(b)
            {
                return [b, level1]
            }
            return [a, level2]
        }
        return level1
    }

    const level1 = level0(42)
    const ret1   = level1()
    assert typeof ret1 == "array"
    assert ret1.size == 2
    assert ret1[0] == 42
    assert typeof ret1[1] == "function"
    const level2 = ret1[1]
    const ret2   = level2(24)
    assert typeof ret2 == "array"
    assert ret2.size == 2
    assert ret2[0] == 24
    assert ret2[1] == level1
}

##############################################################################
# Iterate over functions
do {
    fun func
    {
        return 42
    }

    class ctor {
        constructor {
            this.xyz = 42
        }
    }

    fun gen
    {
        yield 1
        yield 2
    }

    assert typeof func == "function"
    assert typeof ctor == "class"
    assert typeof gen  == "function"

    assert func instanceof base.function
    assert ctor instanceof base.class
    assert gen  instanceof base.generator

    const a = []
    var except = void
    try {
        for const x in func {
            a.push(x)
        }
    }
    catch const e {
        except = e
    }
    assert a.size == 0
    assert except != void
    except = void

    a.resize(0)
    for const x in func() {
        a.push(x)
    }
    assert a.size == 1
    assert a[0] == 42

    a.resize(0)
    for const x in ctor {
        a.push(x)
    }
    assert a.size == 1
    assert typeof a[0] == "array"
    assert a[0].size == 2
    assert a[0][0] == "prototype"

    a.resize(0)
    for const x in ctor() {
        a.push(x)
    }
    assert a.size == 1
    assert typeof a[0] == "array"
    assert a[0][0] == "xyz"
    assert a[0][1] == 42

    a.resize(0)
    try {
        for const x in gen {
            a.push(x)
        }
    }
    catch const e {
        except = e
    }
    assert a.size == 0
    assert except != void

    a.resize(0)
    for const x in gen() {
        a.push(x)
    }
    assert a.size == 2
    assert a[0] == 1
    assert a[1] == 2
}

##############################################################################
# base.function.prototype.prototype

do {
    class ctor { }

    ctor.prototype = base.function.prototype

    const o = ctor()

    expect_fail(()=>o.prototype)
}

##############################################################################
# base.function.prototype.*statistics*

do {
    assert "name"         in base.function.prototype
    assert "registers"    in base.function.prototype
    assert "instructions" in base.function.prototype
    assert "size"         in base.function.prototype
    assert "name"         propertyof base.function.prototype
    assert "registers"    propertyof base.function.prototype
    assert "instructions" propertyof base.function.prototype
    assert "size"         propertyof base.function.prototype

    expect_fail(()=>base.function.prototype.name)
    expect_fail(()=>base.function.prototype.registers)
    expect_fail(()=>base.function.prototype.instructions)
    expect_fail(()=>base.function.prototype.size)
    expect_fail(()=>base.function.prototype.offset)

    fun f { }

    assert f.name         == "f"
    assert f.registers    == 1
    assert f.instructions == 2 # LOAD.VOID, RETURN
    assert f.size         == 4
    assert f.offset       >  0

    assert base.function.name         == "function"
    assert base.function.registers    == 0
    assert base.function.instructions == 0
    assert base.function.size         == 0
    assert base.function.offset       == 0
}

##############################################################################
# base.function.prototype.line

do {
    expect_fail(()=>base.function.prototype.line)
}

##############################################################################
# base.function.prototype.apply

do {
    fun method(arg)
    {
        return this + arg
    }

    assert method.apply(500, [70]) == 570

    expect_fail(()=>method.apply(void, []))
    expect_fail(()=>method.apply(void, void))
    expect_fail(()=>method.apply(void))
    expect_fail(()=>method.apply())
}

do {
    fun method
    {
        throw ""
    }

    expect_fail(()=>method.apply(void, []))
}

do {
    fun method(args...)
    {
        args.resize(1)
        args[0] = 123
    }

    const args = [1, 2, 3]
    method.apply(void, args)

    assert args.size == 3
    assert args[0]   == 1
    assert args[1]   == 2
    assert args[2]   == 3
}

do {
    class ctor {
        constructor {
            this.a = 42
        }
    }
    ctor.prototype.x = -1

    assert typeof ctor == "class"

    const co = ctor()
    assert typeof co == "object"
    assert "a" in co
    assert "a" propertyof co
    assert ! ("x" in co)
    assert "x" propertyof co
    assert co.a == 42
    assert co.x == -1
    assert co instanceof ctor

    const o = { b: 39 }
    assert typeof o == "object"
    assert ! ("a" propertyof o)
    assert o.b == 39
    assert ! (o instanceof ctor)

    const ret = ctor.apply(o, [])
    assert ret == o
    assert "a" in o
    assert "b" in o
    assert ! ("x" in o)
    assert "a" propertyof o
    assert "b" propertyof o
    assert ! ("x" propertyof o)
    assert o.a == 42
    assert o.b == 39
    assert ret.a == 42
    assert ret.b == 39
    assert ! (o instanceof ctor)
    assert ! (ret instanceof ctor)
    expect_fail(()=>o.x)
    expect_fail(()=>ret.x)
}

do {
    expect_fail(fun {
        (()=>void) . apply . apply(void, [])
    })
}

do {
    const arg_list = [ 1, 2, 3 ]
    fun(args...) {
        args[0] = 4
        args[1] = 5
        args[2] = 6
    } . apply(void, arg_list)

    fun resize(args...) { args.resize(1) }

    for const i in base.range(3) {
        resize(arg_list...)
    }
    for const i in base.range(3) {
        resize.apply(void, arg_list)
    }
    for const i in base.range(3) {
        resize(arg_list...)
        resize.apply(void, arg_list)
        resize(arg_list...)
        resize.apply(void, arg_list)
    }

    assert arg_list.size == 3
    assert arg_list[0] == 1
    assert arg_list[1] == 2
    assert arg_list[2] == 3
}

do {
    fun some
    {
        return this.size
    }

    const str = "abcd"
    assert str.size == 4
    assert some.apply(str, []) == 4
    assert some.apply(args = [], obj = str) == 4
}

##############################################################################
# function constuctors

do {
    fun f
    {
    }

    class c
    {
    }

    fun g
    {
        yield void
    }

    assert f instanceof base.function
    assert ! (f instanceof base.class)
    assert ! (f instanceof base.generator)

    assert c instanceof base.function
    assert c instanceof base.class
    assert ! (c instanceof base.generator)

    assert g instanceof base.function
    assert ! (g instanceof base.class)
    assert g instanceof base.generator
}

##############################################################################
# base.generator.slice

do {
    fun primes
    {
        for const v in [2, 3, 5, 7, 11, 13, 17, 19] {
            yield v
        }
    }

    const all = [ primes()[:] ... ]
    assert typeof all == "array"
    assert all.size   == 8
    assert all[0]     == 2
    assert all[1]     == 3
    assert all[2]     == 5
    assert all[3]     == 7
    assert all[4]     == 11
    assert all[5]     == 13
    assert all[6]     == 17
    assert all[7]     == 19

    const some4 = [ primes()[3:7] ... ]
    assert typeof some4 == "array"
    assert some4.size   == 4
    assert some4[0]     == 7
    assert some4[1]     == 11
    assert some4[2]     == 13
    assert some4[3]     == 17

    const somend = [ primes()[5:] ... ]
    assert typeof somend == "array"
    assert somend.size   == 3
    assert somend[0]     == 13
    assert somend[1]     == 17
    assert somend[2]     == 19

    const negative1 = primes()[-5:5]
    assert typeof negative1 == "array"
    assert negative1.size   == 2
    assert negative1[0]     == 7
    assert negative1[1]     == 11

    const negative2 = primes()[:-6]
    assert typeof negative2 == "array"
    assert negative2.size   == 2
    assert negative2[0]     == 2
    assert negative2[1]     == 3
}
