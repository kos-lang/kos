#
# Copyright (c) 2014-2017 Chris Dragan
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.
#
fun expect_fail(function)
{
    var failed = false
    try {
        function()
    }
    catch const e {
        failed = true
    }
    assert failed
}

do {
    fun no_work
    {
    }

    assert no_work() == void
    assert typeof no_work() == "void"
}

do {
    fun zero_args
    {
        return 123
    }

    assert typeof zero_args == "function"

    const a = zero_args()

    assert a == 123
}

do {
    fun one_arg(a)
    {
        return a + 3
    }

    const a = one_arg(-10)

    assert a == -7

    expect_fail(λ->(one_arg()))
}

do {
    fun two_args(a, b)
    {
        return a + 2 * b
    }

    const a = two_args(5, 10)

    assert a == 25

    expect_fail(λ->(two_args(1)))
}

do {
    var a = 1

    fun(b) { a = a + b } (3)

    assert a == 4
}

do {
    fun make(x)
    {
        var a = x + 1
        return fun(y) {
            a += y
            return a
        }
    }

    const next = make(10)
    assert typeof next == "function"
    assert next(0) == 11
    assert next(9) == 20
    assert next(3) == 23
    assert next(-20) == 3
}

var global_a = "a"
var global_b = "b"

do {
    var indep_c = "c"
    var indep_d = "d"

    fun depth1(x)
    {
        var indep_level1_e = x + "e"
        var indep_level1_f = x + "f"

        fun depth2(x)
        {
            var indep_level2_g = x + "g"
            var indep_level2_h = x + "h"

            fun depth3(x)
            {
                global_a =  x + "A"
                global_b += x

                indep_c =  x + "C"
                indep_d += x

                indep_level1_e =  x + "E"
                indep_level1_f += x

                indep_level2_g =  x + "G"
                indep_level2_h += x

                return [ indep_level1_e,
                         indep_level1_f,
                         indep_level2_g,
                         indep_level2_h ]
            }

            return depth3
        }

        return depth2
    }

    do {
        const d2 = depth1("%")
        const d3 = d2("^")

        assert global_a == "a"
        assert global_b == "b"
        assert indep_c  == "c"
        assert indep_d  == "d"

        const test1 = d3("$")
        assert global_a == "$A"
        assert global_b == "b$"
        assert indep_c  == "$C"
        assert indep_d  == "d$"
        assert test1[0] == "$E"
        assert test1[1] == "%f$"
        assert test1[2] == "$G"
        assert test1[3] == "^h$"

        const test2 = d3("@")
        assert global_a == "@A"
        assert global_b == "b$@"
        assert indep_c  == "@C"
        assert indep_d  == "d$@"
        assert test2[0] == "@E"
        assert test2[1] == "%f$@"
        assert test2[2] == "@G"
        assert test2[3] == "^h$@"
    }

    do {
        const d2 = depth1("#")
        const d3 = d2("!")

        assert global_a == "@A"
        assert global_b == "b$@"
        assert indep_c  == "@C"
        assert indep_d  == "d$@"

        const test3 = d3("&")
        assert global_a == "&A"
        assert global_b == "b$@&"
        assert indep_c  == "&C"
        assert indep_d  == "d$@&"
        assert test3[0] == "&E"
        assert test3[1] == "#f&"
        assert test3[2] == "&G"
        assert test3[3] == "!h&"

        do {
            const d3 = d2("*")

            const test4 = d3("?")
            assert global_a == "?A"
            assert global_b == "b$@&?"
            assert indep_c  == "?C"
            assert indep_d  == "d$@&?"
            assert test4[0] == "?E"
            assert test4[1] == "#f&?"
            assert test4[2] == "?G"
            assert test4[3] == "*h?"
        }
    }
}

do {
    fun gen
    {
        yield 100
        yield 200
        yield 300
    }

    const iter = gen()
    assert iter() == 100
    assert iter() == 200
    assert iter() == 300
    expect_fail(iter)
}

do {
    fun gen(x)
    {
        yield x+1
        yield x+2
    }

    const iter1 = gen(8)
    const iter2 = gen(20)
    assert iter1() == 9
    assert iter2() == 21
    assert iter1() == 10
    assert iter2() == 22
    expect_fail(iter1)
    expect_fail(iter2)
}

do {
    fun gen(a, b, c)
    {
        a = yield a
        b = yield a + b
        c = yield b + c
        return void
    }

    const iter = gen(2, 3, 4)
    assert iter() == 2
    assert iter(10) == 13
    assert iter(20) == 24
    expect_fail(iter)
}

do {
    fun gen
    {
        var a = yield 10
        a = yield a
        yield a
        return void
    }

    const iter = gen()
    assert iter(0) == 10
    assert iter() == void
    assert iter(20) == 20
    expect_fail(iter)
}

do {
    fun gen(a)
    {
        loop {
            a = yield a + 1
        }
    }

    expect_fail(gen)

    const iter = gen(7)
    assert iter() == 8
    assert iter(1) == 2
    assert iter(-7) == -6
    assert iter(9) == 10
}

do {
    fun gen
    {
        yield 2
        yield 4
        throw 6
    }

    const iter = gen()
    assert iter() == 2
    assert iter() == 4

    try {
        iter()
        throw "Unexpected value yielded"
    }
    catch const e {
        assert e.value == 6
    }

    var thrown = false
    try {
        iter()
    }
    catch const e {
        thrown = true
        assert e.value == "generator"
    }
    assert thrown
}

do {
    fun gen
    {
        yield 2
        throw 3
        yield 5
        return 4
    }

    const iter = gen()
    assert iter() == 2

    var thrown = false
    try {
        iter()
    }
    catch const e {
        thrown = true
        assert e.value == 3
    }
    assert thrown

    thrown = false
    try {
        iter()
    }
    catch const e {
        thrown = true
        assert e.value == "generator"
    }
    assert thrown
}

do {
    var type = void
    var size = void

    fun with_ellipsis(a, b, c...)
    {
        type = typeof c
        size = c.size
    }

    with_ellipsis(1, 2, 3, 4, 5, 6)
    assert type == "array"
    assert size == 4

    with_ellipsis("x", "y")
    assert type == "array"
    assert size == 0
}

do {
    fun add_all(a...)
    {
        var sum = 0
        for var i in a {
            sum += i
        }
        return sum
    }

    assert add_all()                        == 0
    assert add_all(-10)                     == -10
    assert add_all(2000, 30)                == 2030
    assert add_all(70, 8000, 40000, 3, 900) == 48973
}

do {
    fun add_all(x, y, a...)
    {
        var sum = x + y
        for var i in a {
            sum += i
        }
        return sum
    }

    expect_fail(add_all)
    expect_fail(λ->(add_all(100)))
    assert add_all(10, 2)                   == 12
    assert add_all(70, 8000, 40000, 3, 900) == 48973
}

do {
    fun args_len(a...)
    {
        return a.size
    }

    assert args_len()                 == 0
    assert args_len(void, void, void) == 3
}

do {
    fun args_len(x, y, z, a...)
    {
        return a.size
    }

    assert args_len(void, void, void)             == 0
    assert args_len(void, void, void, void, void) == 2
}

do {
    fun get_index(idx, a...)
    {
        return a[idx]
    }

    assert get_index(0,  "a", "b", "c", "d", "e", "f", "g", "h") == "a"
    assert get_index(-1, "a", "b", "c", "d", "e", "f", "g", "h") == "h"
    assert get_index(5,  "a", "b", "c", "d", "e", "f", "g", "h") == "f"
}

do {
    fun elem(x, a...)
    {
        if a.size == 0 {
            a = [1]
        }
        else {
            a = elem(1, 2)
        }
        return a[x]
    }

    const result = elem(0)
    assert typeof result == "integer"
    assert result        == 1
}

do {
    fun number(a)
    {
        loop {
            yield a
        }
    }

    const one = number(1)
    const two = number(2)
    const six = number(6)
    assert one() == 1
    assert two() == 2
    assert six() == 6
    assert two() == 2
    assert one() == 1
    assert six() == 6
}

do {
    fun number(a)
    {
        const value = a
        loop {
            yield value
        }
    }

    const one = number(1)
    const two = number(2)
    const six = number(6)
    assert one() == 1
    assert two() == 2
    assert six() == 6
    assert two() == 2
    assert one() == 1
    assert six() == 6
}

do {
    var idx = 0

    fun arg(cur)
    {
        assert idx == cur
        idx += 1
    }

    fun noop
    {
    }

    noop(arg(0), arg(1), arg(2), arg(3), arg(4), arg(5), arg(6))
}

do {
    fun plus_six(x)
    {
        return
        x + 5 +
        3 -
        2
    }

    assert plus_six(3) == 9
}

do {
    fun three_args(a, b, c)
    {
        return a + b + c
    }

    var prev = 0

    fun order(pos)
    {
        assert pos > prev
        prev = pos
        return pos
    }

    three_args(order(1), order(2), order(prev * 3 + 10 > 0 ? prev * 10 : 0))

    prev = 0

    three_args(order(prev + 1 * 8 < 0 ? 1 : prev + 2), order(3), order(4))
}

# Deep expression
do {
    fun add_1(x)
    {
        return x + 1
    }

    fun expr
    {
        return 1 + 2 * add_1(
               2 + 2 * add_1(
               3 + 2 * add_1(
               4 + 2 * add_1(
               5 + 2 * add_1(
               6 + 2 * add_1(
               7 + 2 * add_1(
               8 + 2 * add_1(
               9 + 2 * add_1(
              10 + 2 * add_1(
              11 + 2 * add_1(
              12 + 2 * add_1(
              13 + 2 * add_1(
              14 + 2 * add_1(
              15 + 2 * add_1(
              16 + 2 * add_1(
              17 + 2 * add_1(
              18 + 2 * add_1(
              19 + 2 * add_1(
              20 + 2 * add_1(
              21 + 2 * add_1(
              22 + 2 * add_1(
              23 + 2 * add_1(
              24 + 2 * add_1(
              25 + 2 * add_1(
              26 + 2 * add_1(
              27 + 2 * add_1(
              28 + 2 * add_1(
              29 + 2 * add_1(
              30 + 2 * add_1(
              31 + 2 * add_1(
              32 + 2 * add_1(
              33 + 2 * add_1(
              34 + 2 * add_1(
              35 + 2 * add_1(
              36 + 2 * add_1(
              37 + 2 * add_1(
              38 + 2 * add_1(
              39 + 2 * add_1(
              40 + 2 * add_1(
              41 + 2 * add_1(
              42 + 2 * add_1(
              43 + 2 * add_1(
              44 + 2 * add_1(
              45 + 2 * add_1(
              46 + 2 * add_1(
              47 + 2 * add_1(
              48 + 2 * add_1(
              49 + 2 * add_1(
              50 + 2 * add_1(
              51 + 2 * add_1(
              52 + 2 * add_1(
              53 + 2 * add_1(
              54 + 2 * add_1(
              55 + 2 * add_1(
              56 + 2 * add_1(
              57 + 2 * add_1(
              58 + 2 * add_1(
              59 + 2 * add_1(
              60 + 2 * add_1(
              61 + 2 * add_1(
              62 + 2 * add_1(
              63 + 2 * add_1(
              64)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
    }
    #          64 + 2 * add_1(
    #          65 + 2 * add_1(
    #          66 + 2 * add_1(
    #          67 + 2 * add_1(
    #          68 + 2 * add_1(
    #          69 + 2 * add_1(
    #          70 + 2 * add_1(
    #          71 + 2 * add_1(
    #          72 + 2 * add_1(
    #          73 + 2 * add_1(
    #          74 + 2 * add_1(
    #          75 + 2 * add_1(
    #          76 + 2 * add_1(
    #          77 + 2 * add_1(
    #          78 + 2 * add_1(
    #          79 + 2 * add_1(
    #          80 + 2 * add_1(
    #          81 + 2 * add_1(
    #          82 + 2 * add_1(
    #          83 + 2 * add_1(
    #          84 + 2 * add_1(
    #          85 + 2 * add_1(
    #          86 + 2 * add_1(
    #          87 + 2 * add_1(
    #          88 + 2 * add_1(
    #          89 + 2 * add_1(
    #          90 + 2 * add_1(
    #          91 + 2 * add_1(
    #          92 + 2 * add_1(
    #          93 + 2 * add_1(
    #          94 + 2 * add_1(
    #          95 + 2 * add_1(
    #          96 + 2 * add_1(
    #          97 + 2 * add_1(
    #          98 + 2 * add_1(
    #          99 + 2 * add_1(
    #          100
    #          )))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
    #}

    fun recursive(x, stop)
    {
        if x == stop {
            return stop
        }
        return x + 2 * add_1(recursive(x+1, stop))
    }

    assert expr() == recursive(1, 64)
}

do {
    fun add(x, y)
    {
        return x + y
    }

    var accum = 1
    accum     = add(accum, 2)

    assert accum == 3
}

do {
    var obj = fun(x, y) { return x + y }
    obj     = obj(4, -1)

    assert obj == 3
}

do {
    var obj = {
        a: 12,
        f: λ->(this.a + 1)
    }
    obj = obj.f()
    assert obj == 13
}

var global = 1
do {
    var global = global + 9
    assert global == 10
    fun f
    {
        var global = global + 10
        assert global == 20
        var count = 0
        for var global = global + 10; global == 30; global += 1 {
            try {
                defer {
                    global += 3
                }
                assert global == 30
                do {
                    const global = global + 10
                    assert global == 40
                }
                assert global == 30
                count += 1
                throw global + 5
                count += 1
            }
            catch const global {
                assert global.value == 35
            }
            assert global == 33
        }
        assert count  == 1
        assert global == 20
    }
    f()
    assert global == 10
    f()
}
assert global == 1

do {
    # The only case when using the variable in the expression is allowed
    const recurse = fun(level) {
        if level == 0 {
            return recurse(1) * 10
        }
        return 2
    }
    assert recurse(0) == 20
}

do {
    fun outer(a, b)
    {
        return fun {
            return b
        }
    }

    assert outer(1, 2)()      == 2
    assert outer(void, "x")() == "x"
}

do {
    fun outer(a...)
    {
        return fun {
            return a
        }
    }

    const a1 = outer(1, 2, 3)()
    assert typeof a1 == "array"
    assert a1.size   == 3
    assert a1[0]     == 1
    assert a1[1]     == 2
    assert a1[2]     == 3
}

do {
    fun outer(x, a...)
    {
        return fun {
            return a
        }
    }

    const a1 = outer("skip", void, "m")()
    assert typeof a1 == "array"
    assert a1.size   == 2
    assert a1[0]     == void
    assert a1[1]     == "m"
}

do {
    fun add_21(x)
    {
        return x + 21
    }

    fun shl_1(x)
    {
        return x << 1
    }

    fun to_str(x)
    {
        return "\(x)";
    }

    const result = 5.1 -> shl_1 -> add_21 -> to_str

    assert result == "31"
}

do {
    fun add_5(source)
    {
        for var elem in source {
            yield elem + 5
        }
    }

    fun mul_3(source)
    {
        for var elem in source {
            yield elem * 3
        }
    }

    const iter = [4, -2, 1] -> mul_3 -> add_5

    assert typeof iter == "function"
    assert iter()      == 17
    assert iter()      == -1
    assert iter()      == 8
    expect_fail(iter)
}

do {
    const a = 10;
    const result = a -> λ(x)->(x/2)
    assert result == 5
}

# call finished generator
do {
    fun gen
    {
        yield 42
    }

    const iter = gen()
    assert iter() == 42
    expect_fail(λ->(iter()))
    expect_fail(λ->(iter()))
}

# call non-generator function like a generator
do {
    fun not_gen
    {
    }

    expect_fail(fun {
        var a = 0
        for var i in not_gen {
            a += i
        }
        return a
    })
}

# call constructor function like a generator
do {
    constructor not_gen
    {
    }

    expect_fail(fun {
        var a = 0
        for var i in not_gen {
            a += i
        }
        return a
    })
}

# lots of arguments
do {
    fun lots_of_args(a0, args...)
    {
        var prev = a0
        for var i = 0; i < args.size; i += 1 {
            assert prev + 1 == args[i]
            prev = args[i]
        }
    }
    lots_of_args(  1,   2,   3,   4,   5,   6,   7,   8,   9,  10,
                  11,  12,  13,  14,  15,  16,  17,  18,  19,  20,
                  21,  22,  23,  24,  25,  26,  27,  28,  29,  30,
                  31,  32,  33,  34,  35,  36,  37,  38,  39,  40,
                  41,  42,  43,  44,  45,  46,  47,  48,  49,  50,
                  51,  52,  53,  54,  55,  56,  57,  58,  59,  60,
                  61,  62,  63,  64,  65,  66,  67,  68,  69,  70,
                  71,  72,  73,  74,  75,  76,  77,  78,  79,  80,
                  81,  82,  83,  84,  85,  86,  87,  88,  89,  90,
                  91,  92,  93,  94,  95,  96,  97,  98,  99, 100,
                 101, 102, 103, 104, 105, 106, 107, 108, 109, 110,
                 111, 112, 113, 114, 115, 116, 117, 118, 119, 120,
                 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,
                 131, 132, 133, 134, 135, 136, 137, 138, 139, 140,
                 141, 142, 143, 144, 145, 146, 147, 148, 149, 150,
                 151, 152, 153, 154, 155, 156, 157, 158, 159, 160,
                 161, 162, 163, 164, 165, 166, 167, 168, 169, 170,
                 171, 172, 173, 174, 175, 176, 177, 178, 179, 180,
                 181, 182, 183, 184, 185, 186, 187, 188, 189, 190,
                 191, 192, 193, 194, 195, 196, 197, 198, 199, 200)
}

# independent argument from two functions up
do {
    fun f1(a)
    {
        fun f2(b)
        {
            fun f3(c)
            {
                return a + b + c
            }
            return f3
        }
        return f2
    }
    const x = f1(20)
    const y = x(400)
    const z = y(1000)
    assert z == 1420
}

# bind to a variable and access it later (JS's setTimeout pitfall)
do {
    fun n_times(n)
    {
        var later = []
        for var i = 0; i < n; i += 1 {
            later.push(λ->(i))
        }
        return later
    }

    const later = n_times(4)

    assert later.size == 4
    assert later[0]() == 4
    assert later[1]() == 4
    assert later[2]() == 4
    assert later[3]() == 4
}

# function node promoted during optimization
do {
    fun f(x)
    {
        return false ? void :
            fun(arg)
            {
                const op = x
                arg[0] = op
            }
    }

    const a = [ 0 ]
    f(10)(a)
    assert typeof a == "array"
    assert a.size == 1
    assert a[0] == 10
}

# test for correct processing of ?: with arguments
do {
    fun f(x)
    {
        return ! x ? void :
            fun(arg)
            {
                arg[0] = x
            }
    }

    const a = [ 0 ]
    f(10)(a)
    assert typeof a == "array"
    assert a.size == 1
    assert a[0] == 10
}

# mix tail call optimization with independent variables
do {
    fun outer(a)
    {
        const b = a + 1
        fun inner
        {
            return λ->( a * b )
        }
        return inner()
    }

    assert outer(5)()  == 30
    assert outer(-7)() == 42
}

# call a non-callable
do {
    expect_fail(λ->(λ->(3)()()))
}
